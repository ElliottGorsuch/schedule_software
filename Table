<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Therapist Schedule Table</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 5px; /* Reduced padding */
      height: 98vh; /* Use viewport height to fill the screen */
      display: flex;
      flex-direction: column;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 5px; /* Reduced margin */
    }
    
    /* Table container to allow scrolling with fixed header */
    .table-container {
      flex: 1; /* Make table container fill available space */
      overflow: auto;
      position: relative;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px; /* Slightly reduced padding */
      text-align: left;
    }
    
    th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
      z-index: 10; /* Ensure header stays above content when scrolling */
    }
    
    /* Add alternating background colors for therapist groups */
    .therapist-group-even {
      background-color: rgba(245, 245, 245, 0.4);
    }

    /* Add a stronger bottom border to the last row of each therapist group */
    .therapist-group-end {
      border-bottom: 2px solid #aaa;
    }
    
    .time-block {
      font-weight: bold;
      background-color: #f9f9f9;
    }
    
    .assigned {
      background-color: #e8f5e9;
      cursor: pointer;
      position: relative;
      padding-right: 8px; /* Reduced padding */
    }
    
    /* Play Pals assignments get blue tint */
    .assigned.play-pals {
      background-color: #e3f2fd; /* Light blue background */
      border-left: 4px solid #2196F3; /* Blue left border indicator */
    }
    
    /* Multi-therapist assignments styling */
    .assigned.multi-therapist {
      background-color: #fff3e0; /* Light orange background */
      border-left: 4px solid #ff9800; /* Orange left border indicator */
      border-right: 4px solid #ff9800; /* Orange right border for emphasis */
    }
    
    .assigned.multi-therapist.play-pals {
      background-color: #f3e5f5; /* Light purple for multi-therapist + play pals */
      border-left: 4px solid #9c27b0; /* Purple left border */
      border-right: 4px solid #9c27b0; /* Purple right border */
    }
    
    .therapist-count-badge {
      display: block;
      font-size: 10px;
      font-weight: 600;
      color: #ff9800;
      margin-top: 2px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .multi-therapist .therapist-count-badge {
      color: #e65100; /* Darker orange for better contrast */
    }
    
    .multi-therapist.play-pals .therapist-count-badge {
      color: #6a1b9a; /* Purple for multi-therapist + play pals */
    }
    
    /* Assignment status text colors */
    .status-red {
      color: #d32f2f; /* Red text for ideas/can be bumped */
      font-weight: 500;
    }
    
    .status-orange {
      color: #f57c00; /* Orange text for start date planned */
      font-weight: 500;
    }
    
    .status-green {
      color: #388e3c; /* Green text for officially started */
      font-weight: 500;
    }
    
    /* Special styling for Play Pals + status combinations */
    .assigned.play-pals .status-red {
      color: #c62828; /* Slightly darker red on blue background */
    }
    
    .assigned.play-pals .status-orange {
      color: #ef6c00; /* Slightly darker orange on blue background */
    }
    
    .assigned.play-pals .status-green {
      color: #2e7d32; /* Slightly darker green on blue background */
    }
    
    .open {
      background-color: #ffebee;
      cursor: pointer;
      min-height: 40px;
      min-width: 60px;
    }
    
    .na {
      background-color: #212121;
      color: white;
    }
    
    .filters {
      margin-bottom: 10px; /* Reduced margin */
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .filter-group {
      margin-right: 15px;
    }
    
    label {
      font-weight: bold;
      margin-right: 5px;
    }
    
    select {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    
    /* Same time slot options as map for consistency */
    #timeSlotContainer {
      padding: 5px;
      background: #f5f5f5;
      margin-bottom: 5px; /* Reduced margin */
    }
    
    /* New styles for client selection popup */
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }
    
    .popup-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 700px; /* Increased from 500px */
      width: 95%;
      max-height: 85vh; /* Slightly increased */
      overflow-y: auto;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
    }
    
    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    .popup-header h3 {
      margin: 0;
      font-size: 18px;
    }
    
    .close-popup {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .client-list {
      min-height: 250px;
      max-height: 350px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
      margin: 10px 0;
    }
    
    /* Further enhance the client option display */
    .client-option {
      padding: 12px 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color 0.15s ease;
    }
    
    .client-option:hover,
    .client-option.selected {
      background-color: #e3f2fd;
    }
    
    .client-option:active {
      background-color: #bbdefb;
    }
    
    .client-option:last-child {
      border-bottom: none;
    }
    
    .client-name {
      font-weight: bold;
      flex-grow: 1;
      margin-right: 10px;
      font-size: 15px;
    }
    
    .client-distance {
      color: #666;
      font-size: 13px;
      white-space: nowrap;
      background-color: #f1f5f9;
      border-radius: 4px;
      padding: 3px 8px;
      font-weight: 500;
    }
    
    .popup-actions {
      margin-top: 15px;
      display: flex;
      justify-content: space-between;
    }
    
    .popup-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .assign-button {
      background-color: #4CAF50;
      color: white;
    }
    
    .clear-button {
      background-color: #f44336;
      color: white;
    }
    
    .cancel-button {
      background-color: #ccc;
    }
    
    /* Hover effect for cells */
    .open:hover, .assigned:hover {
      opacity: 0.8;
      box-shadow: inset 0 0 0 2px #2196F3;
    }
    
    /* Success/error message styling */
    .status-message {
      padding: 10px;
      margin: 5px 0; /* Reduced margin */
      border-radius: 4px;
      display: none;
    }
    
    .success {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .error {
      background-color: #ffebee;
      color: #c62828;
    }
    
    /* Editable notes cell styling */
    .notes-cell {
      min-width: 150px;
      position: relative;
    }
    
    .notes-cell:hover {
      background-color: #f5f5f5;
    }
    
    .notes-cell:focus {
      outline: 2px solid #2196F3;
      background-color: white;
      box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
    }
    
    .notes-cell:empty:before {
      content: "Click to add note";
      color: #999;
      font-style: italic;
    }
    
    /* Note editing state */
    .notes-cell.editing {
      background-color: #fff3cd !important;
      border: 2px solid #ffc107 !important;
      outline: none;
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }
    
    .notes-cell.editing:before {
      content: none; /* Hide the placeholder when editing */
    }
    
    /* Assigned cell styling with clear button */
    .assigned {
      background-color: #e8f5e9;
      cursor: pointer;
      position: relative;
      padding-right: 8px; /* Reduced padding */
    }
    
    .clear-btn {
      position: absolute;
      right: 4px;
      top: 4px;
      background-color: rgba(244, 67, 54, 0.8); /* Semi-transparent red */
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 8px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0; /* Hidden by default */
      transition: opacity 0.2s ease-in-out;
    }
    
    td:hover .clear-btn {
      opacity: 1.0;
    }
    
    .clear-btn:hover {
      opacity: 1 !important;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
      background-color: #f44336; /* Brighter red on hover */
    }
    
    /* Drag and drop styles */
    .draggable {
      cursor: grab;
    }
    
    .dragging {
      opacity: 0.6;
      border: 2px dashed #2196F3;
      cursor: grabbing;
      background-color: rgba(232, 245, 233, 0.7) !important;
    }
    
    .drag-over {
      background-color: #e3f2fd !important;
      box-shadow: inset 0 0 0 2px #2196F3;
    }
    
    .drag-invalid {
      background-color: #ffcdd2 !important;
      cursor: not-allowed;
    }
    
    /* Search bar styling */
    .search-container {
      flex-grow: 1;
      max-width: 400px;
    }
    
    .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }
    
    #searchInput {
      width: 100%;
      padding: 5px 28px 5px 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-size: 14px;
    }
    
    #searchInput:focus {
      border-color: #2196F3;
      outline: none;
      box-shadow: 0 0 3px rgba(33, 150, 243, 0.3);
    }
    
    .clear-search {
      position: absolute;
      right: 5px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 18px;
      color: #999;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .clear-search:hover {
      color: #f44336;
    }
    
    .highlight {
      background-color: #fff59d;
      padding: 0 2px;
      border-radius: 2px;
    }
    
    /* Client popup search styling */
    .popup-search {
      margin: 5px 0 15px 0;
      width: 100%;
    }
    
    #popupSearchInput {
      width: 100%;
      padding: 8px 28px 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }
    
    #popupSearchInput:focus {
      border-color: #2196F3;
      outline: none;
      box-shadow: 0 0 3px rgba(33, 150, 243, 0.3);
    }
    
    .popup-search .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      width: 100%;
    }
    
    .no-clients-message {
      padding: 30px 20px;
      text-align: center;
      color: #777;
      font-style: italic;
      background-color: #f9f9f9;
      border-radius: 4px;
      margin: 20px 0;
    }
    
    /* Compact alert styling */
    .alert {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 4px;
      font-size: 13px;
      line-height: 1.3;
    }
    
    .alert.warning {
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
    }
    
    .alert.info {
      background-color: #d1ecf1;
      border: 1px solid #b8daff;
      color: #0c5460;
    }
    
    /* Drag operation tooltip */
    .drag-tooltip {
      position: fixed;
      background-color: rgba(76, 175, 80, 0.8); /* Always green for copy */
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Context Menu */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      min-width: 180px;
      padding: 6px 0;
    }
    
    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      color: #333;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .context-menu-item:hover {
      background-color: #f5f5f5;
    }
    
    .context-menu-item.disabled {
      color: #999;
      cursor: not-allowed;
    }
    
    .context-menu-item.disabled:hover {
      background-color: transparent;
    }
    
    .context-menu-divider {
      height: 1px;
      background-color: #eee;
      margin: 4px 0;
    }
    
    /* Status indicators in context menu */
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .status-indicator.red { background-color: #d32f2f; }
    .status-indicator.orange { background-color: #f57c00; }
    .status-indicator.green { background-color: #388e3c; }
    
    /* Alert styling */
    .alert {
      padding: 12px 16px;
      margin: 10px 0;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .alert.warning {
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
    }
    
    .alert.info {
      background-color: #d1ecf1;
      border: 1px solid #b8daff;
      color: #0c5460;
    }
    
    /* Assignment Management UI */
    .assignment-controls {
      margin: 10px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: #f8f9fa;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      align-items: start;
    }
    
    .assignment-controls .full-width {
      grid-column: 1 / -1;
    }
    
    .assignment-controls label {
      display: block;
      margin-bottom: 4px;
      font-weight: 500;
      color: #333;
      font-size: 14px;
    }
    
    .assignment-controls select {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 0;
    }
    
    .assignment-controls input[type="date"] {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 0;
    }
    
    .assignment-controls textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      resize: vertical;
      min-height: 50px;
      max-height: 80px;
    }
    
    /* Schedule Tabs */
    .schedule-tabs {
      display: flex;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
      padding: 0 5px;
      margin-bottom: 10px;
    }
    
    .schedule-tab {
      padding: 10px 20px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #666;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
    }
    
    .schedule-tab:hover {
      color: #333;
      background-color: rgba(33, 150, 243, 0.1);
    }
    
    .schedule-tab.active {
      color: #2196F3;
      border-bottom-color: #2196F3;
      font-weight: 600;
    }
    
    .schedule-tab.future.active {
      color: #9C27B0;
      border-bottom-color: #9C27B0;
    }
    
    .schedule-actions {
      margin-left: auto;
      display: flex;
      align-items: center;
    }
    
    .copy-schedule-btn {
      padding: 8px 12px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background-color 0.2s ease;
    }
    
    .copy-schedule-btn:hover {
      background-color: #388E3C;
    }
    
    .copy-schedule-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    /* Copy Schedule Dropdown */
    .copy-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1000;
      min-width: 200px;
      display: none;
    }
    
    .copy-menu-item {
      padding: 10px 15px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      font-size: 14px;
      color: #333;
    }
    
    .copy-menu-item:hover {
      background-color: #f5f5f5;
    }
    
    .copy-menu-item:last-child {
      border-bottom: none;
    }
    
    .copy-menu-item.disabled {
      color: #999;
      cursor: not-allowed;
    }
    
    .copy-menu-item.disabled:hover {
      background-color: transparent;
    }
    
    /* Copy selected therapists functionality */
    .therapist-checkbox {
      width: 20px;
      text-align: center;
      vertical-align: middle;
      padding: 4px;
    }
    
    .therapist-checkbox input[type="checkbox"] {
      transform: scale(1.1);
      cursor: pointer;
    }
    
    .therapist-row-selected {
      background-color: rgba(33, 150, 243, 0.1) !important;
      border-left: 4px solid #2196F3;
    }
    
    .therapist-row-selected.therapist-group-even {
      background-color: rgba(33, 150, 243, 0.15) !important;
    }
    
    .select-all-checkbox {
      margin-right: 8px;
    }
    
    .copy-schedule-btn.has-selection {
      background-color: #FF9800;
      animation: pulse-selection 2s infinite;
    }
    
    .copy-schedule-btn.has-selection:hover {
      background-color: #F57C00;
    }
    
    @keyframes pulse-selection {
      0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.4); }
      70% { box-shadow: 0 0 0 8px rgba(255, 152, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
    }
    
    .selection-counter {
      font-size: 12px;
      color: #666;
      margin-left: 10px;
    }
    
    /* Patch distances button */
    .patch-distances-btn {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin-left: 10px;
      transition: background-color 0.2s ease;
    }
    
    .patch-distances-btn:hover {
      background-color: #1976D2;
    }
    
    .patch-distances-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    /* Patch dialog styles */
    .patch-dialog {
      max-width: 500px;
    }
    
    .patch-progress {
      margin: 15px 0;
    }
    
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .patch-results {
      margin-top: 15px;
    }
    
    .result-summary {
      background-color: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    
    .result-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }
    
    .error-list {
      max-height: 150px;
      overflow-y: auto;
      background-color: #fff5f5;
      border: 1px solid #ffcdd2;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
    }
    
    .error-item {
      font-size: 12px;
      color: #d32f2f;
      margin: 2px 0;
    }
    
    /* Alert styles */
    .alert {
      padding: 12px;
      margin: 10px 0;
      border-radius: 4px;
      border-left: 4px solid;
    }
    
    .alert.warning {
      background-color: #fff3cd;
      border-color: #ffc107;
      color: #856404;
    }
    
    .alert.info {
      background-color: #d1ecf1;
      border-color: #17a2b8;
      color: #0c5460;
    }
    
    .alert.success {
      background-color: #d4edda;
      border-color: #28a745;
      color: #155724;
    }
    
    .alert.error {
      background-color: #f8d7da;
      border-color: #dc3545;
      color: #721c24;
    }
    
    /* Multi-therapist assignment styles */
    .multi-therapist {
      position: relative;
      padding: 6px 8px 4px 8px;
      line-height: 1.2;
    }
    
    .client-name-multi {
      display: block;
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
    }
    
    .therapist-count {
      display: block;
      font-size: 11px;
      color: #666;
      font-weight: 500;
      margin-bottom: 3px;
    }
    
    .therapist-names-list {
      font-size: 10px;
      color: #777;
      line-height: 1.1;
      margin-top: 2px;
    }
    
    .therapist-name-item {
      font-weight: 500;
    }
    
    .therapist-separator {
      color: #999;
      font-weight: normal;
    }
    
    /* Multi-therapist with Play Pals styling */
    .multi-therapist.play-pals {
      background-color: #e3f2fd;
      border-left: 4px solid #2196F3;
    }
    
    .multi-therapist.play-pals .therapist-count {
      color: #1976D2;
    }
    
    .multi-therapist.play-pals .therapist-names-list {
      color: #1565C0;
    }
    
    /* Multi-therapist clear button positioning */
    .multi-therapist .clear-btn {
      position: absolute;
      right: 2px;
      top: 2px;
      width: 14px;
      height: 14px;
      font-size: 7px;
      line-height: 1;
    }
    
    /* Enhanced multi-therapist display */
    .therapist-distances {
      font-size: 9px;
      color: #888;
      margin-top: 2px;
      line-height: 1.1;
    }
    
    .therapist-distance-item {
      display: block;
      margin: 1px 0;
    }
    
    .therapist-distance-name {
      font-weight: 500;
      color: #666;
    }
    
    .therapist-distance-value {
      color: #999;
      margin-left: 4px;
    }
    
    /* Multi-therapist management UI */
    .therapist-list-section {
      border-top: 1px solid #eee;
      padding-top: 15px;
      margin-top: 15px;
    }
    
    .therapist-selection-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      margin: 10px 0;
    }
    
    .therapist-selection-item {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .therapist-selection-item:last-child {
      border-bottom: none;
    }
    
    .therapist-selection-item.selected {
      background-color: #e3f2fd;
    }
    
    .therapist-checkbox {
      margin: 0;
    }
    
    .therapist-info {
      flex-grow: 1;
    }
    
    .therapist-name-select {
      font-weight: 500;
      font-size: 14px;
    }
    
    .therapist-distance-info {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }
    
    .selected-therapists-summary {
      background-color: #f0f8ff;
      border: 1px solid #b8daff;
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
    }
    
    .selected-therapists-list {
      font-size: 13px;
      color: #333;
    }
    
    .therapist-tag {
      display: inline-block;
      background-color: #2196F3;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      margin: 2px 4px 2px 0;
    }
    
    .add-therapist-section {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .multi-therapist-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .add-therapist-btn {
      background-color: #28a745;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .add-therapist-btn:hover {
      background-color: #218838;
    }
    
    .remove-therapist-btn {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .remove-therapist-btn:hover {
      background-color: #c82333;
    }
    
    /* Multi-therapist edit popup specific styles */
    .edit-multi-therapist .popup-content {
      max-width: 800px;
    }
    
    .therapist-management-section {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
      background-color: #f8f9fa;
    }
    
    .therapist-management-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .current-therapists-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin: 10px 0;
    }
    
    .current-therapist-tag {
      background-color: #2196F3;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .remove-therapist-x {
      cursor: pointer;
      font-weight: bold;
      margin-left: 3px;
    }
    
    .remove-therapist-x:hover {
      color: #ffcccc;
    }
    
    /* Lead BCBA dropdown styling */
    .lead-bcba-dropdown {
      background: transparent;
      border: 1px solid transparent;
      padding: 2px 4px;
      font-family: inherit;
      font-size: inherit;
      color: inherit;
      cursor: pointer;
      border-radius: 3px;
      min-width: 120px;
      max-width: 180px;
    }
    
    .lead-bcba-dropdown:hover {
      background-color: #f5f5f5;
      border-color: #ddd;
    }
    
    .lead-bcba-dropdown:focus {
      outline: none;
      background-color: white;
      border-color: #2196F3;
      box-shadow: 0 0 3px rgba(33, 150, 243, 0.3);
    }
    
    .lead-bcba-dropdown option {
      padding: 4px 8px;
    }
    
    .lead-bcba-loading {
      color: #999;
      font-style: italic;
    }
  </style>
</head>
<body>
  <!-- Schedule Tabs -->
  <div class="schedule-tabs">
    <button id="currentScheduleTab" class="schedule-tab active" onclick="switchSchedule('current')">
      Current Schedule
    </button>
    <button id="futureScheduleTab" class="schedule-tab" onclick="switchSchedule('future')">
      Future Schedule
    </button>
    
    <div class="schedule-actions">
      <button id="copyScheduleButton" class="copy-schedule-btn" onclick="showCopyScheduleMenu()">
        <span id="copyScheduleText">Copy to Future</span> ▼
      </button>
      <span id="selectionCounter" class="selection-counter" style="display: none;"></span>
      
      <button id="patchDistancesButton" class="patch-distances-btn" onclick="showPatchDistancesDialog()" title="Fix missing distance calculations">
        🔧 Patch
      </button>
      
      <button id="diagnosticsButton" class="patch-distances-btn" onclick="runDiagnostics()" title="Run system diagnostics">
        🔍 Diagnostics
      </button>
      
      <button id="clientDistancesButton" class="patch-distances-btn" onclick="showClientDistancesDialog()" title="Manage client-to-client distances">
        📍 Client Distances
      </button>
    </div>
  </div>
  
  <!-- Copy Schedule Dropdown Menu -->
  <div class="copy-menu" id="copyScheduleMenu">
    <div class="copy-menu-item" onclick="copyEntireSchedule()">
      <span id="copyEntireText">Copy Entire Current Schedule to Future</span>
    </div>
    <div class="copy-menu-item" onclick="copySelectedTherapists()" id="copySelectedMenuItem">
      <span id="copySelectedText">Copy Selected Therapists to Future</span>
    </div>
    <div class="copy-menu-item" onclick="copySelectedTimeSlot()">
      <span>Copy Selected Time Slot to Other Schedule</span>
    </div>
  </div>
  
  <!-- Filters -->
  <div class="filters">
    <div class="filter-group">
      <label for="therapistFilter">Therapist:</label>
      <select id="therapistFilter">
        <option value="all">All Therapists</option>
        <!-- Will be populated with therapists -->
      </select>
    </div>
    
    <div class="filter-group">
      <label for="leadFilter">Lead BCBA:</label>
      <select id="leadFilter">
        <option value="all">All Leads</option>
        <!-- Will be populated with leads -->
      </select>
    </div>
    
    <div class="filter-group search-container">
      <label for="searchInput">Search:</label>
      <div class="search-input-wrapper">
        <input type="text" id="searchInput" placeholder="Search names, clients or notes..." />
        <button id="clearSearch" class="clear-search" title="Clear search">&times;</button>
      </div>
    </div>
  </div>
  
  <!-- Status message area -->
  <div id="statusMessage" class="status-message"></div>
  
  <!-- Schedule Table in a container for scrolling -->
  <div class="table-container">
    <table id="scheduleTable">
      <thead>
        <tr>
          <th class="therapist-checkbox">
            <input type="checkbox" id="selectAllTherapists" class="select-all-checkbox" title="Select/Deselect All">
          </th>
          <th>Team Member</th>
          <th>Lead BCBA</th>
          <th>Block</th>
          <th>Monday</th>
          <th>Tuesday</th>
          <th>Wednesday</th>
          <th>Thursday</th>
          <th>Friday</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody id="scheduleBody">
        <!-- Table content will be generated here -->
      </tbody>
    </table>
  </div>
  
  <!-- Drag operation tooltip -->
  <div id="dragTooltip" class="drag-tooltip">Drag to duplicate assignment</div>
  
  <!-- Client Selection Popup -->
  <div class="popup-overlay" id="assignmentPopup">
    <div class="popup-content">
      <div class="popup-header">
        <h3 id="popupTitle">Select Client</h3>
        <button class="close-popup" id="closePopup">&times;</button>
      </div>
      
      <!-- Add search bar to popup -->
      <div class="popup-search">
        <div class="search-input-wrapper">
          <input type="text" id="popupSearchInput" placeholder="Search clients..." autocomplete="off" />
          <button id="clearPopupSearch" class="clear-search" title="Clear search">&times;</button>
        </div>
      </div>
      
      <!-- Assignment Controls -->
      <div class="assignment-controls">
        <div>
          <label for="assignmentType">Assignment Type:</label>
          <select id="assignmentType">
            <option value="regular">Regular Assignment</option>
            <option value="playPals">Play Pals Session</option>
          </select>
        </div>
        
        <div>
          <label for="assignmentStatus">Assignment Status:</label>
          <select id="assignmentStatus">
            <option value="red">🔴 Idea / Can be bumped</option>
            <option value="orange">🟠 Start date planned</option>
            <option value="green">🟢 Officially started</option>
          </select>
        </div>
        
        <div id="startDateSection" style="display: none;">
          <label for="startDate">Start Date:</label>
          <input type="date" id="startDate" />
        </div>
        
        <div class="full-width" id="assignmentTypeInfo" style="display: none;">
          <div class="alert info">
            <strong>Play Pals Sessions:</strong> These will show with a blue background in the schedule.
          </div>
        </div>
        
        <div class="full-width" id="startDateWarning" style="display: none;">
          <div class="alert warning">
            <strong>Orange Status:</strong> Please enter a start date above or mention it in notes below.
          </div>
        </div>
        
        <div class="full-width">
          <label for="assignmentNotes">Notes:</label>
          <textarea id="assignmentNotes" placeholder="Add any notes about this assignment..."></textarea>
        </div>
      </div>
      
      <!-- Client Selection Section -->
      <div style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px;">
        <h4 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">Select Client:</h4>
      
      <div class="client-list" id="clientList">
        <!-- Client options will be added here -->
        </div>
      </div>
      
      <!-- Multi-Therapist Management Section -->
      <div class="therapist-list-section" id="therapistListSection" style="display: none;">
        <h4 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">
          <input type="checkbox" id="enableMultiTherapist" style="margin-right: 8px;" />
          Select Additional Therapists (Optional)
        </h4>
        
        <div id="multiTherapistControls" style="display: none;">
          <div class="selected-therapists-summary" id="selectedTherapistsSummary" style="display: none;">
            <strong>Selected Therapists:</strong>
            <div class="selected-therapists-list" id="selectedTherapistsList"></div>
          </div>
          
          <div class="add-therapist-section">
            <label style="font-weight: 500; margin-bottom: 8px; display: block;">Add Additional Therapists:</label>
            <div class="search-input-wrapper" style="margin-bottom: 8px;">
              <input type="text" id="therapistSearchInput" placeholder="Search therapists..." autocomplete="off" />
              <button id="clearTherapistSearch" class="clear-search" title="Clear search">&times;</button>
            </div>
            <div class="therapist-selection-list" id="therapistSelectionList">
              <!-- Available therapists will be populated here -->
            </div>
          </div>
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button clear-button" id="clearAssignment">Clear Assignment</button>
        <button class="popup-button cancel-button" id="cancelAssignment">Cancel</button>
        <button class="popup-button assign-button" id="assignClientButton" style="display: none;">Assign Client</button>
      </div>
    </div>
  </div>
  
  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="setNAMenuItem">Mark as N/A</div>
    <div class="context-menu-item" id="removeNAMenuItem">Remove N/A</div>
    <div class="context-menu-divider" id="assignmentDivider" style="display: none;"></div>
    <div class="context-menu-item" id="changeStatusMenuItem" style="display: none;">
      <span class="status-indicator red"></span>Change Status
    </div>
    <div class="context-menu-item" id="changeTypeMenuItem" style="display: none;">
      Change Type
    </div>
    <div class="context-menu-item" id="editNotesMenuItem" style="display: none;">
      Edit Notes
    </div>
  </div>
  
  <!-- Assignment Edit Modal -->
  <div class="popup-overlay" id="assignmentEditPopup" style="display: none;">
    <div class="popup-content">
      <div class="popup-header">
        <h3 id="editPopupTitle">Edit Assignment</h3>
        <button class="close-popup" id="closeEditPopup">&times;</button>
      </div>
      
      <div class="assignment-controls">
        <label for="editAssignmentType">Assignment Type:</label>
        <select id="editAssignmentType">
          <option value="regular">Regular Assignment</option>
          <option value="playPals">Play Pals Session</option>
        </select>
        
        <label for="editAssignmentStatus">Assignment Status:</label>
        <select id="editAssignmentStatus">
          <option value="red">🔴 Idea / Can be bumped</option>
          <option value="orange">🟠 Start date planned (requires date)</option>
          <option value="green">🟢 Officially started</option>
        </select>
        
        <div id="editStartDateSection" style="display: none;">
          <label for="editStartDate">Start Date:</label>
          <input type="date" id="editStartDate" />
        </div>
        
        <label for="editAssignmentNotes">Notes:</label>
        <textarea id="editAssignmentNotes" placeholder="Add any notes about this assignment..."></textarea>
        
        <div class="alert warning" id="editStartDateWarning" style="display: none;">
          <strong>Orange Status:</strong> Please enter a start date in the notes or date field above.
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button" id="saveAssignmentChanges">Save Changes</button>
        <button class="popup-button cancel-button" id="cancelAssignmentEdit">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Multi-Therapist Edit Modal -->
  <div class="popup-overlay edit-multi-therapist" id="multiTherapistEditPopup" style="display: none;">
    <div class="popup-content">
      <div class="popup-header">
        <h3 id="multiEditPopupTitle">Edit Multi-Therapist Assignment</h3>
        <button class="close-popup" id="closeMultiEditPopup">&times;</button>
      </div>
      
      <!-- Assignment Details Section -->
      <div class="assignment-controls">
        <label for="multiEditAssignmentType">Assignment Type:</label>
        <select id="multiEditAssignmentType">
          <option value="regular">Regular Assignment</option>
          <option value="playPals">Play Pals Session</option>
        </select>
        
        <label for="multiEditAssignmentStatus">Assignment Status:</label>
        <select id="multiEditAssignmentStatus">
          <option value="red">🔴 Idea / Can be bumped</option>
          <option value="orange">🟠 Start date planned (requires date)</option>
          <option value="green">🟢 Officially started</option>
        </select>
        
        <div id="multiEditStartDateSection" style="display: none;">
          <label for="multiEditStartDate">Start Date:</label>
          <input type="date" id="multiEditStartDate" />
        </div>
        
        <label for="multiEditAssignmentNotes">Notes:</label>
        <textarea id="multiEditAssignmentNotes" placeholder="Add any notes about this assignment..."></textarea>
        
        <div class="alert warning" id="multiEditStartDateWarning" style="display: none;">
          <strong>Orange Status:</strong> Please enter a start date in the notes or date field above.
        </div>
      </div>
      
      <!-- Therapist Management Section -->
      <div class="therapist-management-section">
        <div class="therapist-management-header">
          <h4 style="margin: 0; font-size: 16px;">Assigned Therapists</h4>
          <span id="therapistCountDisplay" style="color: #666; font-size: 14px;"></span>
        </div>
        
        <div class="current-therapists-list" id="currentTherapistsList">
          <!-- Current therapist tags will be populated here -->
        </div>
        
        <div class="add-therapist-section">
          <label style="font-weight: 500; margin-bottom: 8px; display: block;">Add/Remove Therapists:</label>
          <div class="therapist-selection-list" id="multiEditTherapistList">
            <!-- Available therapists will be populated here -->
          </div>
        </div>
        
        <!-- Travel Distance Summary -->
        <div id="travelDistanceSummary" style="margin-top: 15px; padding: 10px; background-color: #f0f8ff; border-radius: 4px;">
          <h5 style="margin: 0 0 8px 0; font-size: 14px; color: #333;">Travel Distance Summary:</h5>
          <div id="travelDistanceList" style="font-size: 12px; color: #666;">
            <!-- Travel distances will be populated here -->
          </div>
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button" id="saveMultiTherapistChanges">Save Changes</button>
        <button class="popup-button cancel-button" id="cancelMultiTherapistEdit">Cancel</button>
        <button class="popup-button clear-button" id="clearMultiTherapistAssignment" style="margin-right: auto;">Clear Entire Assignment</button>
      </div>
    </div>
  </div>
  
  <!-- Patch Distances Confirmation Dialog -->
  <div class="popup-overlay" id="patchConfirmationPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>Patch Missing Distances</h3>
        <button class="close-popup" id="closePatchConfirmation">&times;</button>
      </div>
      
      <div id="patchConfirmationContent">
        <p id="patchConfirmationMessage">Checking for sessions with missing distance data...</p>
        
        <div id="patchConfirmationDetails" style="display: none;">
          <div class="result-summary">
            <div class="result-item">
              <span>Total Sessions:</span>
              <span id="totalSessionsCount">-</span>
            </div>
            <div class="result-item">
              <span>Sessions Needing Patch:</span>
              <span id="missingSessionsCount">-</span>
            </div>
          </div>
          
          <p><strong>This will recalculate missing distance and travel time data using Google Maps.</strong></p>
          
          <div class="alert warning">
            <strong>Note:</strong> This may take a few minutes and will use Google Maps API calls.
          </div>
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button" id="confirmPatchButton" style="display: none;" onclick="startPatchProcess()">
          Start Patching
        </button>
        <button class="popup-button cancel-button" id="cancelPatchButton" onclick="closePatchConfirmation()">
          Cancel
        </button>
      </div>
    </div>
  </div>
  
  <!-- Patch Progress Dialog -->
  <div class="popup-overlay" id="patchProgressPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>Patching Distances...</h3>
      </div>
      
      <div class="patch-progress">
        <p id="patchProgressMessage">Starting patch process...</p>
        
        <div class="progress-bar">
          <div class="progress-fill" id="patchProgressFill"></div>
        </div>
        
        <div id="patchProgressDetails">
          <small id="patchProgressText">Preparing...</small>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Patch Results Dialog -->
  <div class="popup-overlay" id="patchResultsPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>Patch Results</h3>
        <button class="close-popup" id="closePatchResults">&times;</button>
      </div>
      
      <div id="patchResultsContent">
        <div class="result-summary">
          <div class="result-item">
            <span>Sessions Found:</span>
            <span id="resultTotalSessions">-</span>
          </div>
          <div class="result-item">
            <span>Successfully Patched:</span>
            <span id="resultPatchedSessions" style="color: #4CAF50; font-weight: bold;">-</span>
          </div>
          <div class="result-item">
            <span>Failed to Patch:</span>
            <span id="resultFailedSessions" style="color: #f44336; font-weight: bold;">-</span>
          </div>
        </div>
        
        <div id="patchErrorSection" style="display: none;">
          <h4>Errors:</h4>
          <div class="error-list" id="patchErrorList">
            <!-- Error items will be added here -->
          </div>
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button" id="closePatchResultsButton" onclick="closePatchResults()">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <!-- Client Distances Management Dialog -->
  <div class="popup-overlay" id="clientDistancesPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>📍 Client Distance Management</h3>
        <button class="close-popup" id="closeClientDistances">&times;</button>
      </div>
      
      <div id="clientDistancesContent">
        <div class="result-summary">
          <div class="result-item">
            <span>Total Clients:</span>
            <span id="totalClientsCount">-</span>
          </div>
          <div class="result-item">
            <span>Expected Calculations:</span>
            <span id="expectedCalculationsCount">-</span>
          </div>
          <div class="result-item">
            <span>Current Calculations:</span>
            <span id="currentCalculationsCount">-</span>
          </div>
          <div class="result-item">
            <span>Completion:</span>
            <span id="completionPercentage">-</span>
          </div>
        </div>
        
        <!-- Processing Mode Selection -->
        <div style="border: 1px solid #ddd; border-radius: 6px; padding: 15px; margin: 15px 0; background-color: #f9f9f9;">
          <h4 style="margin: 0 0 15px 0;">🔧 Processing Options</h4>
          
          <!-- Limited Test Section -->
          <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: white;">
            <h5 style="margin: 0 0 10px 0; color: #2196F3;">🧪 Limited Test (Recommended for First Run)</h5>
            <p style="margin: 5px 0; font-size: 13px; color: #666;">Test with a smaller number of clients first (~2-5 minutes, $2-5)</p>
            
            <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
              <label>Process first:</label>
              <select id="limitedClientCount" style="flex: 0 0 80px;">
                <option value="10">10 clients</option>
                <option value="15">15 clients</option>
                <option value="20" selected>20 clients</option>
                <option value="25">25 clients</option>
              </select>
              <button class="popup-button" onclick="initializeLimitedClientDistances()" style="background-color: #4CAF50;">
                🚀 Run Limited Test
              </button>
            </div>
          </div>
          
          <!-- Chunked Processing Section -->
          <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background-color: white;">
            <h5 style="margin: 0 0 10px 0; color: #FF9800;">📦 Chunked Processing (For Large Sets)</h5>
            <p style="margin: 5px 0; font-size: 13px; color: #666;">Process all clients in manageable chunks with progress saving</p>
            
            <div id="chunkedControls">
              <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
                <label>Chunk size:</label>
                <select id="chunkSize" style="flex: 0 0 100px;">
                  <option value="10">10 clients</option>
                  <option value="15" selected>15 clients</option>
                  <option value="20">20 clients</option>
                </select>
                <button class="popup-button" id="startChunkedButton" onclick="startChunkedProcessing()" style="background-color: #FF9800;">
                  ▶️ Start Chunked
                </button>
                <button class="popup-button" id="continueChunkedButton" onclick="continueChunkedProcessing()" style="background-color: #2196F3; display: none;">
                  ▶️ Continue Next Chunk
                </button>
              </div>
              
              <div id="chunkedProgress" style="display: none; margin: 10px 0; padding: 10px; background-color: #f0f8ff; border-radius: 4px;">
                <div style="font-size: 13px; margin-bottom: 5px;">
                  <span>Progress: </span>
                  <span id="chunkedProgressText">0 / 119 clients processed (0%)</span>
                </div>
                <div style="background-color: #ddd; height: 8px; border-radius: 4px; overflow: hidden;">
                  <div id="chunkedProgressBar" style="background-color: #4CAF50; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- New Clients Only Processing Section -->
          <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #e8f5e9; border-radius: 4px; background-color: white;">
            <h5 style="margin: 0 0 10px 0; color: #4CAF50;">🆕 New Clients Only (Smart Detection)</h5>
            <p style="margin: 5px 0; font-size: 13px; color: #666;">Automatically find and process only clients with no distance records</p>
            
            <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
              <span id="newClientsCount" style="font-weight: 500; color: #666;">Detecting new clients...</span>
              <button class="popup-button" id="processNewClientsButton" onclick="processNewClients()" style="background-color: #4CAF50; display: none;">
                🚀 Process New Clients
              </button>
              <button class="popup-button" id="refreshNewClientsButton" onclick="refreshNewClientsDetection()" style="background-color: #2196F3;">
                🔄 Refresh Detection
              </button>
            </div>
          </div>
          
          <!-- Full Processing Section -->
          <div style="padding: 10px; border: 1px solid #ffcdd2; border-radius: 4px; background-color: #fff5f5;">
            <h5 style="margin: 0 0 10px 0; color: #f44336;">⚠️ Full Processing (Use with Caution)</h5>
            <p style="margin: 5px 0; font-size: 13px; color: #666;">Process all 119 clients at once (~1-2 hours, ~$70)</p>
            
            <button class="popup-button" id="initializeDistancesButton" onclick="initializeClientDistances()" style="background-color: #f44336;">
              ⚡ Initialize All Client Distances
            </button>
          </div>
          
          <div style="margin-top: 15px;">
            <button class="popup-button" id="refreshStatsButton" onclick="refreshClientDistanceStats()" style="background-color: #2196F3;">
              🔄 Refresh Stats
            </button>
            <button class="popup-button" onclick="verifyNoDuplicates()" style="background-color: #9C27B0;">
              🔍 Verify No Duplicates
            </button>
            <button class="popup-button" onclick="findOptimalStart()" style="background-color: #FF9800;">
              🎯 Find Optimal Start
            </button>
          </div>
        </div>
        
        <!-- Manual Client-by-Client Mode -->
        <div id="manualModeSection" style="border: 1px solid #ddd; border-radius: 6px; padding: 15px; margin: 15px 0; background-color: #f9f9f9;">
          <h4 style="margin: 0 0 15px 0;">✋ Manual Client-by-Client Mode</h4>
          <p style="margin: 5px 0; font-size: 13px; color: #666;">Select a source client to calculate distances to all other clients, verify, and save.</p>
          
          <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
            <select id="manualSourceClient" style="flex: 1;">
              <option value="">Select source client...</option>
            </select>
            <button class="popup-button" id="calculateManualButton" style="background-color: #2196F3;">
              🔄 Calculate
            </button>
          </div>
          
          <div id="manualResults" style="display: none; margin-top: 15px;">
            <h5>Results:</h5>
            <div id="manualResultsTable" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
              <!-- Results table will be populated here -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 10px; justify-content: flex-end;">
              <button class="popup-button" id="approveManualButton" style="background-color: #4CAF50;">✅ Approve & Save</button>
              <button class="popup-button" id="recalculateSelectedButton" style="background-color: #FF9800;">🔄 Recalculate Selected</button>
              <button class="popup-button" id="exportManualCSV" style="background-color: #9C27B0;">📥 Export CSV</button>
            </div>
          </div>
        </div>
        
        <div id="clientDistancesStatus">
          <p id="clientDistancesMessage">Loading statistics...</p>
        </div>
        
        <!-- Test Section -->
        <div style="border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;">
          <h4>Test Proximity Ranking</h4>
          <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
            <select id="testClientSelect" style="flex: 1;">
              <option value="">Select a client to test...</option>
            </select>
            <button class="popup-button" onclick="testClientProximity()" style="background-color: #FF9800;">
              Test
            </button>
            <button class="popup-button" onclick="calculateFullDistancesForClient()" style="background-color: #FF5722; margin-left: 10px;">
              🔍 Calc Full Distances
            </button>
          </div>
          <div id="proximityTestResults" style="display: none;">
            <h5>Nearby Clients (within 15 minutes):</h5>
            <div id="proximityResultsList" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 4px;">
              <!-- Test results will go here -->
            </div>
          </div>
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button cancel-button" id="closeClientDistancesButton" onclick="closeClientDistancesDialog()">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <!-- Client Distances Progress Dialog -->
  <div class="popup-overlay" id="clientDistancesProgressPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>📍 Calculating Client Distances...</h3>
      </div>
      
      <div class="patch-progress">
        <p id="clientDistancesProgressMessage">Starting distance calculations...</p>
        
        <div class="progress-bar">
          <div class="progress-fill" id="clientDistancesProgressFill"></div>
        </div>
        
        <div id="clientDistancesProgressDetails">
          <small id="clientDistancesProgressText">Preparing...</small>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Client Distances Results Dialog -->
  <div class="popup-overlay" id="clientDistancesResultsPopup" style="display: none;">
    <div class="popup-content patch-dialog">
      <div class="popup-header">
        <h3>📍 Distance Calculation Results</h3>
        <button class="close-popup" id="closeClientDistancesResults">&times;</button>
      </div>
      
      <div id="clientDistancesResultsContent">
        <div class="result-summary">
          <div class="result-item">
            <span>Clients Processed:</span>
            <span id="resultClientsProcessed">-</span>
          </div>
          <div class="result-item">
            <span>Calculations Completed:</span>
            <span id="resultCalculationsCompleted" style="color: #4CAF50; font-weight: bold;">-</span>
          </div>
          <div class="result-item">
            <span>Processing Time:</span>
            <span id="resultProcessingTime">-</span>
          </div>
          <div class="result-item">
            <span>API Calls Used:</span>
            <span id="resultApiCalls">-</span>
          </div>
        </div>
        
        <div id="clientDistancesResultMessage" style="padding: 15px; background-color: #f0f8ff; border-radius: 4px; margin: 10px 0;">
          <!-- Result message will be shown here -->
        </div>
      </div>
      
      <div class="popup-actions">
        <button class="popup-button" id="closeClientDistancesResultsButton" onclick="closeClientDistancesResults()">
          Close
        </button>
      </div>
    </div>
  </div>
  
  <script>
    // Backend API Communication Functions
    // Determine and cache the web app URL for direct doPost calls
    let __WEB_APP_URL = null;
    function getWebAppUrlCached() {
      return new Promise((resolve, reject) => {
        if (__WEB_APP_URL) return resolve(__WEB_APP_URL);
        if (typeof google !== 'undefined' && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler((url) => { __WEB_APP_URL = url; resolve(url); })
            .withFailureHandler(reject)
            .getScriptUrl();
        } else {
          reject(new Error('google.script.run not available'));
        }
      });
    }
    
    /**
     * Generic function to call backend API functions
     * @param {string} action - The backend function to call
     * @param {object} params - Parameters to send to the backend
     * @returns {Promise} - Promise that resolves with the API response
     */
    function callBackendAPI(action, params = {}) {
      return new Promise((resolve, reject) => {
        console.log('[TABLE] Calling backend API:', action);
        
            // SIMPLIFIED: Use doPost for data loading functions (Method 1 only)
    const doPostActions = ['getMapData', 'getEssentialData', 'getSessionsData', 'getScheduleData'];
    
    if (doPostActions.includes(action)) {
      console.log('[TABLE] Using server-side doPost proxy for API call:', action);
      // Avoid CORS by calling the backend from Apps Script itself
      google.script.run
        .withSuccessHandler((data) => {
          try {
            const parsed = (typeof data === 'string') ? JSON.parse(data) : data;
            console.log('[TABLE] doPost response for', action, ':', parsed);
            resolve(parsed);
          } catch (e) {
            console.error('[TABLE] Failed to parse doPost response:', e, data);
            resolve(null);
          }
        })
        .withFailureHandler((error) => {
          console.error('[TABLE] doPost error for', action, ':', error);
          reject(error);
        })
        .makeDoPostRequest(action, params);
          
        } else if (typeof google !== 'undefined' && google.script && google.script.run) {
          console.log('[TABLE] Using google.script.run for API call:', action);
          
          // Create the API call based on action
          switch(action) {
            case 'getMapData':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .getMapData();
              break;
              
            case 'copySelectedTherapists':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .copySelectedTherapists(params);
              break;
              
            case 'checkMissingDistances':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .checkMissingDistances();
              break;
              
            case 'patchMissingDistances':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .patchMissingDistances();
              break;
              
            case 'copyEntireSchedule':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .copyEntireSchedule(params);
              break;
              
            case 'setNAStatus':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .setNAStatus(params);
              break;
              
            case 'removeNAStatus':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .removeNAStatus(params);
              break;
              
            case 'toggleNAStatus':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .toggleNAStatus(params);
              break;
              
            case 'createAssignment':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .createAssignment(params);
              break;
              
            case 'clearAssignment':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .clearAssignment(params);
              break;
              
            case 'clearTherapistAssignments':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .clearTherapistAssignments(params);
              break;
              
            case 'getAssignmentDetails':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .getAssignmentDetails(params);
              break;
              
            case 'updateAssignmentDetails':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .updateAssignmentDetails(params);
              break;
              
            case 'testGrokConnectivity':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .testGrokConnectivity();
              break;
              
            case 'getClientDistanceStats':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .getClientDistanceStats();
              break;
              
            case 'initializeClientDistancesAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .initializeClientDistancesAPI();
              break;
              
            case 'testProximityRanking':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .testProximityRanking(params.clientId);
              break;
              
            case 'initializeClientDistancesLimitedAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .initializeClientDistancesLimitedAPI(params.maxClients);
              break;
              
            case 'initializeClientDistancesChunkedAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .initializeClientDistancesChunkedAPI(params.chunkSize, params.startIndex);
              break;
              
            case 'verifyNoDuplicatesAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .verifyNoDuplicatesAPI();
              break;
              
            case 'getOptimalChunkStartAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .getOptimalChunkStartAPI();
              break;
              
            case 'saveTherapistNote':
              console.log('[TABLE] Calling saveTherapistNote (redacted)');
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .saveTherapistNote(params);
              break;
              
            case 'getTherapistNotes':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .getTherapistNotes();
              break;
              
            case 'deleteTherapistNote':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .deleteTherapistNote(params);
              break;
              
            case 'updateTherapistLead':
              console.log('[TABLE] Calling updateTherapistLead (redacted)');
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .updateTherapistLead(params);
              break;
              
            case 'calculateDistancesForClient':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .calculateDistancesForClient(params.sourceClientId);
              break;
              
            case 'clearClientDistances':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .clearClientDistances();
              break;
              
            case 'identifyNewClientsAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .identifyNewClientsAPI();
              break;
              
            case 'initializeNewClientsDistancesAPI':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .initializeNewClientsDistancesAPI();
              break;
              
            case 'testSpreadsheetAccess':
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .testSpreadsheetAccess();
              break;
              
            default:
              console.error('[TABLE] Unknown action:', action);
              reject(new Error('Unknown action: ' + action));
              break;
          }
        } else {
          // Check if we're in a Google Apps Script environment
          if (typeof google !== 'undefined' && google.script) {
            console.log('[TABLE] Google Apps Script detected, but google.script.run not available yet. Retrying...');
            // Retry after a short delay
            setTimeout(() => {
              if (google.script.run) {
                console.log('[TABLE] google.script.run now available, retrying API call...');
                callBackendAPI(action, params).then(resolve).catch(reject);
              } else {
                console.warn('[TABLE] google.script.run still not available after retry');
                resolve({
                  success: false,
                  error: 'google.script.run not available (Google Apps Script environment not ready)'
                });
              }
            }, 500);
          } else {
            // Fallback for development or standalone testing
            console.warn('[TABLE] Not in Google Apps Script environment, using fallback');
            setTimeout(() => {
              resolve({
                success: false,
                error: 'Not running in Google Apps Script environment (development mode)'
              });
            }, 100);
          }
        }
      });
    }
    
    // Global data stores
    var therapistsData = [];
    var clientsData = [];
    var sessionsData = []; // Added to store distance/travel times
    var assignmentsData = [];
    var notesData = {}; // Will store notes for therapists
    var clientDistances = []; // Added to store client-to-client distances
    var currentDragSource = null; // Track the source cell of a drag operation
    
    // Schedule management
    var currentScheduleType = "current"; // "current" or "future"
    
    // Assignment creation tracking
    var assignmentCreationInProgress = false;
    
    // Backend connectivity status
    var backendConnected = false;
    
    // Initialization tracking
    var dataInitialized = false;
    var initializationInProgress = false;
    
    // Selected therapists for bulk copying
    var selectedTherapists = new Set(); // Set of therapist IDs
    
    // Current selection for assignment
    var currentSelection = {
      therapistId: null,
      day: null,
      timeBlock: null,
      cell: null
    };
    
    // Search term for highlighting
    var currentSearchTerm = "";
    
    // Time blocks we're using
    var timeBlocks = ["Morning", "Mid", "Afternoon"];
    
    // Day slots
    var daySlots = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
    
    // Data caching configuration
    var DATA_CACHE_KEY = 'therapist_schedule_data_cache';
    var DATA_CACHE_VERSION = '3.0'; // Force fresh data load
    var DATA_CACHE_EXPIRY_MINUTES = 30; // Cache expires after 30 minutes
    
    /**
     * Save all loaded data to sessionStorage for recovery
     */
    function saveDataToCache() {
      try {
        var cacheData = {
          version: DATA_CACHE_VERSION,
          timestamp: Date.now(),
          scheduleType: currentScheduleType,
          data: {
            therapists: therapistsData,
            clients: clientsData,
            sessions: sessionsData,
            assignments: assignmentsData,
            notes: notesData,
            clientDistances: clientDistances
          },
          counts: {
            therapists: therapistsData.length,
            clients: clientsData.length,
            sessions: sessionsData.length,
            assignments: assignmentsData.length,
            notes: Object.keys(notesData).length,
            clientDistances: clientDistances.length
          }
        };
        
        sessionStorage.setItem(DATA_CACHE_KEY, JSON.stringify(cacheData));
        console.log('[CACHE] ✅ Data saved to cache:', cacheData.counts);
        return true;
      } catch (error) {
        console.error('[CACHE] ❌ Failed to save data to cache:', error);
        return false;
      }
    }
    
    /**
     * Load data from sessionStorage cache
     * @returns {Object|null} Cached data or null if not available/expired
     */
    function loadDataFromCache() {
      try {
        var cacheStr = sessionStorage.getItem(DATA_CACHE_KEY);
        if (!cacheStr) {
          console.log('[CACHE] No cached data found');
          return null;
        }
        
        var cacheData = JSON.parse(cacheStr);
        
        // Check version compatibility
        if (cacheData.version !== DATA_CACHE_VERSION) {
          console.log('[CACHE] Cache version mismatch, clearing cache');
          sessionStorage.removeItem(DATA_CACHE_KEY);
          return null;
        }
        
        // Check if cache is expired
        var ageMinutes = (Date.now() - cacheData.timestamp) / (1000 * 60);
        if (ageMinutes > DATA_CACHE_EXPIRY_MINUTES) {
          console.log('[CACHE] Cache expired (age:', Math.round(ageMinutes), 'minutes), clearing');
          sessionStorage.removeItem(DATA_CACHE_KEY);
          return null;
        }
        
        console.log('[CACHE] ✅ Valid cache found (age:', Math.round(ageMinutes), 'minutes)');
        console.log('[CACHE] Cache contains:', cacheData.counts);
        
        return cacheData;
      } catch (error) {
        console.error('[CACHE] ❌ Failed to load cache:', error);
        sessionStorage.removeItem(DATA_CACHE_KEY);
        return null;
      }
    }
    
    /**
     * Restore data from cache
     * @param {Object} cacheData - The cached data object
     * @returns {boolean} True if restoration was successful
     */
    function restoreDataFromCache(cacheData) {
      try {
        if (!cacheData || !cacheData.data) {
          console.error('[CACHE] Invalid cache data structure');
          return false;
        }
        
        // Restore all data arrays
        therapistsData = cacheData.data.therapists || [];
        clientsData = cacheData.data.clients || [];
        sessionsData = cacheData.data.sessions || [];
        assignmentsData = cacheData.data.assignments || [];
        notesData = cacheData.data.notes || {};
        clientDistances = cacheData.data.clientDistances || [];
        
        // No field mapping needed for cached data
        
        // Restore schedule type if different
        if (cacheData.scheduleType && cacheData.scheduleType !== currentScheduleType) {
          console.log('[CACHE] Restoring schedule type:', cacheData.scheduleType);
          currentScheduleType = cacheData.scheduleType;
        }
        
        console.log('[CACHE] ✅ Data restored from cache:', {
          therapists: therapistsData.length,
          clients: clientsData.length,
          sessions: sessionsData.length,
          assignments: assignmentsData.length,
          notes: Object.keys(notesData).length,
          clientDistances: clientDistances.length
        });
        
        return true;
      } catch (error) {
        console.error('[CACHE] ❌ Failed to restore data from cache:', error);
        return false;
      }
    }
    
    /**
     * Clear the data cache
     */
    function clearDataCache() {
      try {
        sessionStorage.removeItem(DATA_CACHE_KEY);
        console.log('[CACHE] Cache cleared');
      } catch (error) {
        console.error('[CACHE] Failed to clear cache:', error);
      }
    }
    
    /**
     * Set up data stability monitoring with auto-recovery
     */
    function setupDataStabilityMonitor() {
      // Clear any existing monitor
      if (window.dataStabilityMonitor) {
        clearInterval(window.dataStabilityMonitor);
      }
      
      console.log('[MONITOR] 🔒 Setting up data stability monitoring with auto-recovery...');
      
      // Initialize known counts
      window.lastKnownAssignmentsCount = assignmentsData ? assignmentsData.length : 0;
      window.lastKnownTherapistsCount = therapistsData ? therapistsData.length : 0;
      window.lastKnownClientsCount = clientsData ? clientsData.length : 0;
      
      window.dataStabilityMonitor = setInterval(() => {
        var currentAssignmentsCount = assignmentsData ? assignmentsData.length : 0;
        var currentTherapistsCount = therapistsData ? therapistsData.length : 0;
        var currentClientsCount = clientsData ? clientsData.length : 0;
        
        // Check if data has disappeared
        if (currentAssignmentsCount === 0 && window.lastKnownAssignmentsCount > 0) {
          console.error('[MONITOR] 🚨 DATA STABILITY ALERT: Assignments disappeared!', {
            previous: window.lastKnownAssignmentsCount,
            current: currentAssignmentsCount,
            therapists: currentTherapistsCount,
            clients: currentClientsCount
          });
          
          // AUTO-RECOVERY: Try to restore from cache
          console.log('[MONITOR] 🔄 Attempting auto-recovery from cache...');
          var cachedData = loadDataFromCache();
          
          if (cachedData && cachedData.data.assignments && cachedData.data.assignments.length > 0) {
            if (restoreDataFromCache(cachedData)) {
              // Rebuild UI with recovered data
              buildScheduleTable();
              showStatusMessage('✅ Data automatically recovered from cache', 'success');
              console.log('[MONITOR] ✅ Data successfully recovered from cache');
              
              // Update known counts
              window.lastKnownAssignmentsCount = assignmentsData.length;
              window.lastKnownTherapistsCount = therapistsData.length;
              window.lastKnownClientsCount = clientsData.length;
            } else {
              showStatusMessage('❌ Data recovery failed - please refresh the page', 'error');
              console.error('[MONITOR] ❌ Failed to recover data from cache');
            }
          } else {
            showStatusMessage('⚠️ Data disappeared and no cache available - reloading from backend...', 'warning');
            console.log('[MONITOR] No cache available, attempting backend reload...');
            
            // Clear the loading lock to allow reload
            window.dataLoadingInProgress = false;
            
            // Attempt to reload from backend
            loadTableDataFromAPI().catch(error => {
              console.error('[MONITOR] Failed to reload from backend:', error);
              showStatusMessage('❌ Failed to reload data: ' + error.message, 'error');
            });
          }
        } else if (currentAssignmentsCount > 0 && window.lastKnownAssignmentsCount !== currentAssignmentsCount) {
          // Data changed but didn't disappear - update cache
          console.log('[MONITOR] 📝 Data changed, updating cache...');
          saveDataToCache();
        }
        
        // Update known counts
        window.lastKnownAssignmentsCount = currentAssignmentsCount;
        window.lastKnownTherapistsCount = currentTherapistsCount;
        window.lastKnownClientsCount = currentClientsCount;
      }, 2000); // Check every 2 seconds
    }

    // Helper function to get client name by ID
    function getClientName(clientId) {
      // Handle N/A case explicitly
      if (clientId === "N/A") {
        return "N/A";
      }
      
      var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
      return client ? client.name : "Unknown Client";
    }
    
    // Helper function to get therapist name by ID
    function getTherapistName(therapistId) {
      var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
      return therapist ? therapist.name : "Unknown Therapist";
    }
    
    // Helper function to get lead BCBA for a therapist
    function getLeadBCBA(therapistId) {
      var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
      return therapist && therapist.lead ? therapist.lead : "-";
    }
    
    // Helper function to get available lead BCBAs from therapist data
    function getAvailableLeadBCBAs() {
      if (!therapistsData || therapistsData.length === 0) {
        return [];
      }
      
      // Find therapists who have "BCBA" in their title field
      var bcbaTherapists = therapistsData.filter(function(therapist) {
        return therapist.title && therapist.title.toUpperCase().includes('BCBA');
      });
      
      // Extract unique names and sort them
      var bcbaNames = bcbaTherapists.map(function(therapist) {
        return therapist.name;
      });
      
      // Remove duplicates and sort
      var uniqueBCBAs = [...new Set(bcbaNames)].sort();
      
      console.log('[LEAD_BCBA] Found available BCBAs:', uniqueBCBAs);
      return uniqueBCBAs;
    }
    
    // =============================================================================
    // CLIENT-TO-CLIENT DISTANCE FUNCTIONS (Ported from map.html)
    // =============================================================================

    /**
     * Get distance and travel time between two clients
     * @param {string|number} clientAId - First client ID
     * @param {string|number} clientBId - Second client ID
     * @returns {Object|null} - Distance data or null if not found
     */
    function getClientToClientDistance(clientAId, clientBId) {
      if (!clientDistances || clientDistances.length === 0) {
        console.warn('[CLIENT_DISTANCE] No client distance data available');
        return null;
      }

      // Convert IDs to strings for consistent comparison
      var idA = String(clientAId);
      var idB = String(clientBId);

      // Check both directions: A->B and B->A
      var distanceRecord = clientDistances.find(function(d) {
        return (String(d.SourceClientID || d.sourceClientId) === idA && String(d.TargetClientID || d.targetClientId) === idB) ||
               (String(d.SourceClientID || d.sourceClientId) === idB && String(d.TargetClientID || d.targetClientId) === idA);
      });

      if (distanceRecord) {
        console.log('[CLIENT_DISTANCE] Found distance between clients', idA, 'and', idB, ':', 
                    distanceRecord.DistanceMiles || distanceRecord.distanceMiles, 'miles,', 
                    distanceRecord.TravelMinutes || distanceRecord.travelMinutes, 'minutes');
        return {
          distanceMiles: distanceRecord.DistanceMiles || distanceRecord.distanceMiles,
          travelMinutes: distanceRecord.TravelMinutes || distanceRecord.travelMinutes,
          distanceText: distanceRecord.DistanceText || distanceRecord.distanceText || ((distanceRecord.DistanceMiles || distanceRecord.distanceMiles) + ' mi'),
          durationText: distanceRecord.DurationText || distanceRecord.durationText || ((distanceRecord.TravelMinutes || distanceRecord.travelMinutes) + ' mins')
        };
      }

      console.warn('[CLIENT_DISTANCE] No distance data found between clients', idA, 'and', idB);
      return null;
    }

    /**
     * Find closest clients from a source client (mirrors findClosestClients pattern)
     * @param {string|number} sourceClientId - Source client ID
     * @param {number} n - Number of closest clients to return (default: 5)
     * @returns {Array} - Array of closest clients with distance data
     */
    function findClosestClientsFromClient(sourceClientId, n) {
      n = n || 5;
      
      console.log('[CLIENT_ROUTE] Finding closest ' + n + ' clients from client ' + sourceClientId);
      console.log('[CLIENT_ROUTE] clientDistances array available:', clientDistances ? clientDistances.length : 0);
      
      // Debug: Check what columns are available in clientDistances data
      if (clientDistances && clientDistances.length > 0) {
        console.log('[CLIENT_ROUTE] Sample clientDistances columns:', Object.keys(clientDistances[0]));
        console.log('[CLIENT_ROUTE] Sample clientDistances data:', clientDistances[0]);
      } else {
        console.warn('[CLIENT_ROUTE] No clientDistances data available');
        return [];
      }
      
      // Use clientDistances array for client-to-client routing
      if (clientDistances && clientDistances.length > 0) {
        // Filter clientDistances for this source client
        var relevantDistances = clientDistances.filter(function(d) {
          // Check both directions since client-to-client can be bidirectional
          return (String(d.SourceClientID || d.sourceClientId) === String(sourceClientId)) ||
                 (String(d.TargetClientID || d.targetClientId) === String(sourceClientId));
        });
        
        console.log('[CLIENT_ROUTE] Found ' + relevantDistances.length + ' relevant client distance records');
        
        if (relevantDistances.length > 0) {
          // Convert to target clients with distances - FILTER OUT BAD DATA
          var clientsWithDistances = [];
          var filteredOutCount = 0;
          
          relevantDistances.forEach(function(distanceRecord) {
            // QUALITY CHECK: Only use records with meaningful distances (>= 0.2 miles)
            var actualDistance = Number(distanceRecord.DistanceMiles || distanceRecord.distanceMiles) || 0;
            
            if (actualDistance < 0.2) {
              filteredOutCount++;
              console.log('[CLIENT_ROUTE] Filtered out distance: ' + actualDistance + ' miles (too small)');
              return; // Skip this record
            }
            
            // Determine which client is the target (not the source)
            var targetClientId;
            if (String(distanceRecord.SourceClientID || distanceRecord.sourceClientId) === String(sourceClientId)) {
              targetClientId = distanceRecord.TargetClientID || distanceRecord.targetClientId;
            } else {
              targetClientId = distanceRecord.SourceClientID || distanceRecord.sourceClientId;
            }
            
            // Find the target client object
            var targetClient = clientsData.find(function(c) { return String(c.id) === String(targetClientId); });
            
            if (targetClient) {
              // Use actual distance values (no fallback to 0.1)
              var actualTravelTime = Number(distanceRecord.TravelMinutes || distanceRecord.travelMinutes) || Math.round(actualDistance * 3);
              
              console.log('[CLIENT_ROUTE] Adding valid client: ' + targetClient.name + ' at ' + actualDistance.toFixed(1) + ' miles');
              
              clientsWithDistances.push(Object.assign({}, targetClient, {
                distance: actualDistance,
                travelTime: actualTravelTime,
                distanceText: actualDistance.toFixed(1) + ' miles',
                durationText: actualTravelTime.toFixed(0) + ' mins'
              }));
            } else {
              console.warn('[CLIENT_ROUTE] Target client not found: ' + targetClientId);
            }
          });
          
          console.log('[CLIENT_ROUTE] Filtered out ' + filteredOutCount + ' records with distance < 0.2 miles');
          console.log('[CLIENT_ROUTE] Valid clients found: ' + clientsWithDistances.length);
          
          if (clientsWithDistances.length === 0) {
            console.warn('[CLIENT_ROUTE] No clients with meaningful distances (>= 0.2 miles) found');
            return [];
          }
          
          // Remove duplicates (same client appearing multiple times)
          var uniqueClients = [];
          var seenClientIds = new Set();
          
          clientsWithDistances.forEach(function(client) {
            if (!seenClientIds.has(client.id)) {
              uniqueClients.push(client);
              seenClientIds.add(client.id);
            } else {
              console.log('[CLIENT_ROUTE] Removed duplicate client: ' + client.name);
            }
          });
          
          console.log('[CLIENT_ROUTE] Unique clients after deduplication: ' + uniqueClients.length);
          
          // Sort by distance (closest first)
          var sortedClients = uniqueClients.sort(function(a, b) {
            return a.distance - b.distance;
          });
          
          // Return top n closest clients
          var result = sortedClients.slice(0, n);
          console.log('[CLIENT_ROUTE] Returning ' + result.length + ' closest clients with distances:');
          result.forEach(function(client, index) {
            console.log('  ' + (index + 1) + '. ' + client.name + ' - ' + client.distanceText + ' (' + client.durationText + ')');
          });
          
          return result;
        }
      }
      
      console.warn('[CLIENT_ROUTE] No client-to-client distance data found in clientDistances array');
      return [];
    }

    /**
     * Get the next time slot for time slot transitions (Morning→Mid, Mid→Afternoon)
     * @param {string} currentTimeSlot - Current time slot (e.g., "Monday-Morning")
     * @returns {string|null} - Next time slot or null if no transition
     */
    function getNextTimeSlot(currentTimeSlot) {
      if (!currentTimeSlot || !currentTimeSlot.includes('-')) {
        return null;
      }
      
      var parts = currentTimeSlot.split('-');
      var day = parts[0];
      var time = parts[1];
      
      // Define time slot transitions
      var transitions = {
        'Morning': 'Mid',
        'Mid': 'Afternoon'
        // Afternoon has no next slot on same day
      };
      
      var nextTime = transitions[time];
      if (nextTime) {
        return day + '-' + nextTime;
      }
      
      return null; // No transition available
    }

    /**
     * Helper function to check if a client is assigned in a given time slot
     * @param {string|number} clientId - Client ID
     * @param {string} timeSlot - Time slot (e.g., "Monday-Mid")
     * @returns {string|null} - Assigned therapist ID or null if not assigned
     */
    function getTherapistForClient(clientId, timeSlot) {
      var assignment = assignmentsData.find(function(a) {
        return String(a.clientId) === String(clientId) && 
               a.timeSlot === timeSlot &&
               (a.scheduleType || "current") === currentScheduleType;
      });
      
      return assignment ? assignment.therapistId : null;
    }

    /**
     * Find assigned clients for a therapist in a specific time slot
     * @param {string|number} therapistId - Therapist ID
     * @param {string} timeSlot - Time slot (e.g., "Monday-Morning")
     * @returns {Array} - Array of assigned client objects
     */
    function findAssignedClientsForTherapist(therapistId, timeSlot) {
      var assignments = assignmentsData.filter(function(a) {
        return String(a.therapistId) === String(therapistId) && 
               a.timeSlot === timeSlot &&
               a.clientId !== "N/A" &&
               (a.scheduleType || "current") === currentScheduleType;
      });
      
      return assignments.map(function(assignment) {
        var client = clientsData.find(function(c) { return String(c.id) === String(assignment.clientId); });
        return client || { id: assignment.clientId, name: 'Unknown Client' };
      });
    }

    // Function to update therapist lead BCBA assignment
    async function updateTherapistLead(therapistId, newLead) {
      try {
        console.log('[LEAD_BCBA] Updating therapist', therapistId, 'lead to:', newLead);
        
        // Find the therapist in our local data
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        if (!therapist) {
          throw new Error('Therapist not found: ' + therapistId);
        }
        
        var oldLead = therapist.lead || 'Unassigned';
        
        // Show loading state
        showStatusMessage(`Updating ${therapist.name}'s lead BCBA to ${newLead}...`, 'info');
        
        // Call backend API to save the change
        var result = await callBackendAPI('updateTherapistLead', {
          therapistId: Number(therapistId),
          leadBCBA: newLead,
          therapistName: therapist.name
        });
        
        if (result.success) {
          // Update local data
          therapist.lead = newLead;
          console.log('[LEAD_BCBA] Successfully updated therapist lead locally');
          
          // Update the filter dropdown if it exists
          populateFilters();
          
          // Show success message
          showStatusMessage(`✅ Successfully updated ${therapist.name}'s lead BCBA from "${oldLead}" to "${newLead}"`, 'success');
          
        } else {
          throw new Error(result.error || 'Failed to update lead BCBA');
        }
        
      } catch (error) {
        console.error('[LEAD_BCBA] Error updating therapist lead:', error);
        
        // Revert the dropdown to previous value
        var dropdown = document.querySelector(`select[data-therapist-id="${therapistId}"]`);
        if (dropdown && therapist) {
          dropdown.value = therapist.lead || 'Unassigned';
        }
        
        showStatusMessage(`❌ Failed to update lead BCBA: ${error.message}`, 'error');
      }
    }
    
    /**
     * Generate client-to-client routing HTML for assigned cells popup
     * Shows optimal next clients for upcoming time slot transitions
     * @param {Object} assignment - Current assignment details
     * @param {string} currentTimeSlot - Current time slot (e.g., "Monday-Morning")
     * @returns {string} - HTML string for routing section
     */
    function getClientToClientRoutingHTML(assignment, currentTimeSlot) {
      if (!assignment || !assignment.clientId || assignment.clientId === "N/A") {
        return ''; // No routing for N/A assignments
      }
      
      // Determine next time slot
      var nextTimeSlot = getNextTimeSlot(currentTimeSlot);
      if (!nextTimeSlot) {
        return ''; // No next time slot to route to
      }
      
      console.log('[ROUTING] Generating client-to-client routing for client ' + assignment.clientId + 
                  ' from ' + currentTimeSlot + ' → ' + nextTimeSlot);
      
      // Find closest clients from current client location
      var closestClients = findClosestClientsFromClient(assignment.clientId, 5); // Top 5
      
      if (closestClients.length === 0) {
        return '<div class="client-routing-container" style="background-color: #f8f9fa; border: 2px solid #6c757d; border-radius: 8px; padding: 10px; margin: 10px 0;">' +
               '<h4 style="color: #495057; margin: 0 0 8px 0;">🚗 Optimal Routing to ' + nextTimeSlot + '</h4>' +
               '<p style="color: #666; font-style: italic; margin: 0;">No client-to-client distance data available</p>' +
               '</div>';
      }
      
      var html = '<div class="client-routing-container" style="background-color: #e8f5e8; border: 2px solid #4caf50; border-radius: 8px; padding: 10px; margin: 10px 0;">';
      html += '<h4 style="color: #2e7d32; margin: 0 0 8px 0;">🚗 Optimal Routing to ' + nextTimeSlot + '</h4>';
      html += '<div style="font-size: 12px; color: #1b5e20; margin-bottom: 8px;">From: <strong>' + (assignment.clientName || getClientName(assignment.clientId)) + '</strong></div>';
      
      html += '<div class="routing-options" style="margin-left: 10px;">';
      
      closestClients.forEach(function(option, optionIndex) {
        // Check if this client is already assigned in the next time slot
        var assignedTherapistId = getTherapistForClient(option.id, nextTimeSlot);
        var isAvailable = !assignedTherapistId;
        
        // Style based on availability
        var optionStyle = '';
        var statusIcon = '';
        var statusText = '';
        
        if (isAvailable) {
          optionStyle = 'background-color: #f1f8e9; border-left: 3px solid #8bc34a;';
          statusIcon = '✅';
          statusText = 'Available';
        } else {
          var otherTherapist = therapistsData.find(function(t) { return String(t.id) === String(assignedTherapistId); });
          var otherTherapistName = otherTherapist ? otherTherapist.name : 'Another therapist';
          optionStyle = 'background-color: #fce4ec; border-left: 3px solid #e91e63;';
          statusIcon = '🔒';
          statusText = 'Assigned to ' + otherTherapistName;
        }
        
        html += '<div style="' + optionStyle + ' padding: 4px 6px; margin: 2px 0; font-size: 0.9em;">';
        html += '<div style="display: flex; justify-content: space-between; align-items: center;">';
        html += '<span>' + statusIcon + ' ' + option.name + '</span>';
        html += '<span style="color: #666; font-size: 0.8em;">' + option.distanceText + '</span>';
        html += '</div>';
        html += '<div style="font-size: 0.8em; color: #666;">' + statusText + '</div>';
        html += '</div>';
      });
      
      html += '</div>'; // End routing-options
      html += '</div>'; // End client-routing-container
      return html;
    }

    /**
     * Load client distances data from backend
     */
    async function loadClientDistances() {
      try {
        console.log('[CLIENT_DISTANCES] Loading client distances data...');
        
        // ✅ NEW PIPELINE - Use callBackendAPI like the working assignments
        var result = await callBackendAPI('getMapData');
        
        // Check if backend returned null or invalid data
        if (!result || result === null) {
          console.error('[CLIENT_DISTANCES] Error loading client distances: Backend returned null data');
          clientDistances = [];
          return [];
        }
        
        // Extract clientDistances from the response (same pattern as loadAllData)
        if (result.clientDistances && Array.isArray(result.clientDistances)) {
          clientDistances = result.clientDistances;
          console.log('[CLIENT_DISTANCES] Loaded', clientDistances.length, 'client distance records');
          console.log('[CLIENT_DISTANCES] Sample client distance:', clientDistances.length > 0 ? clientDistances[0] : 'none');
        } else {
          console.warn('[CLIENT_DISTANCES] No clientDistances found in getMapData response');
          clientDistances = [];
        }
        
        return clientDistances;
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error loading client distances:', error);
        clientDistances = [];
        return [];
      }
    }

    /**
     * Convert backend assignments object to frontend array format
     * @param {Object} assignmentsObject - Backend assignments data
     * @returns {Array} - Array of assignment objects for frontend use
     */
    function convertAssignmentsToArray(assignmentsObject) {
      console.log('[CONVERT] Converting assignments from backend format to frontend array...');
      
      if (!assignmentsObject || typeof assignmentsObject !== 'object') {
        console.warn('[CONVERT] No assignments object provided or invalid format');
        return [];
      }
      
      console.log('[CONVERT] Backend structure - sample value:', assignmentsObject);
      
      var assignmentsArray = [];
      
      // Log the structure for debugging
      console.log('[CONVERT] Backend structure - first key:', Object.keys(assignmentsObject)[0]);
      console.log('[CONVERT] Backend structure - sample value:', assignmentsObject[Object.keys(assignmentsObject)[0]]);
      
      // Determine whether the top-level keys represent time slots (contain '-')
      // or therapist IDs (numeric/strings without '-').
      var firstKey = Object.keys(assignmentsObject)[0];
      var isTimeSlotFirst = firstKey && firstKey.includes('-');
      console.log('[CONVERT] Detected', isTimeSlotFirst ? 'timeSlot-first' : 'therapist-first', 'structure');
      
      // Parse legacy therapist-first structure only when detected
      if (!isTimeSlotFirst) {
      Object.keys(assignmentsObject).forEach(function(therapistKey) {
        var therapistData = assignmentsObject[therapistKey];
        
        // Skip if not a valid object
        if (!therapistData || typeof therapistData !== 'object') {
          return;
        }
        
        // Parse therapist key to get day and timeBlock
        var therapistParts = therapistKey.split('-');
        if (therapistParts.length !== 2) {
          console.warn('[CONVERT] Invalid therapist key format:', therapistKey);
          return;
        }
        
        var day = therapistParts[0];
        var timeBlock = therapistParts[1];
        var timeSlot = day + '-' + timeBlock;
        
        // Iterate through each timeSlot in the therapist data
        Object.keys(therapistData).forEach(function(timeSlotKey) {
          var assignmentData = therapistData[timeSlotKey];
          
          // Skip if not a valid assignment object
          if (!assignmentData || typeof assignmentData !== 'object') {
            return;
          }
          
          // Handle both N/A assignments and regular assignments
          if (timeSlotKey === 'N/A') {
            // This is an N/A assignment
            var assignment = {
              timeSlot: timeSlot,
              therapistId: assignmentData.therapistIds ? assignmentData.therapistIds[0] : null,
              clientId: 'N/A',
              assignmentType: assignmentData.assignmentType || 'regular',
              assignmentStatus: assignmentData.assignmentStatus || 'red',
              startDate: assignmentData.startDate || '',
              notes: assignmentData.notes || '',
              scheduleType: assignmentData.scheduleType || 'current',
              multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
              isMultiTherapist: assignmentData.isMultiTherapist || false,
              therapistIds: assignmentData.therapistIds || [],
              therapistCount: assignmentData.therapistCount || 1,
              isNA: true
            };
            assignmentsArray.push(assignment);
          } else {
            // This is a regular assignment - timeSlotKey is the therapistId
            var therapistId = parseInt(timeSlotKey);
            
            // Create the assignment object
            var assignment = {
              timeSlot: timeSlot,
              therapistId: therapistId,
              clientId: assignmentData.clientId || 'N/A',
              assignmentType: assignmentData.assignmentType || 'regular',
              assignmentStatus: assignmentData.assignmentStatus || 'red',
              startDate: assignmentData.startDate || '',
              notes: assignmentData.notes || '',
              scheduleType: assignmentData.scheduleType || 'current',
              multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
              isMultiTherapist: assignmentData.isMultiTherapist || false,
              therapistIds: assignmentData.therapistIds || [therapistId],
              therapistCount: assignmentData.therapistCount || 1,
              isNA: false
            };
            assignmentsArray.push(assignment);
          }
        });
      });
      } else {
        // Parse timeSlot-first structure
        Object.keys(assignmentsObject).forEach(function(timeSlot) {
          var timeSlotData = assignmentsObject[timeSlot];
          
          // Skip if not a valid object
          if (!timeSlotData || typeof timeSlotData !== 'object') {
            return;
          }
          
          Object.keys(timeSlotData).forEach(function(clientId) {
            var assignmentData = timeSlotData[clientId];
             
            // Skip if not a valid assignment object
            if (!assignmentData || typeof assignmentData !== 'object') {
              return;
            }
            
            // Handle both N/A assignments and regular assignments
            if (clientId === 'N/A') {
              // This is an N/A assignment
              var assignment = {
                  timeSlot: timeSlot,
                therapistId: assignmentData.therapistIds ? assignmentData.therapistIds[0] : null,
                clientId: 'N/A',
                  assignmentType: assignmentData.assignmentType || 'regular',
                  assignmentStatus: assignmentData.assignmentStatus || 'red',
                  startDate: assignmentData.startDate || '',
                  notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [],
                  therapistCount: assignmentData.therapistCount || 1,
                isNA: true
              };
              assignmentsArray.push(assignment);
                              } else {
              // This is a regular assignment - clientId is the key, therapistId is in assignmentData
              var therapistId = assignmentData.therapistId || assignmentData.therapistIds?.[0];
              
              if (!therapistId) {
                console.warn('[CONVERT] Skipping assignment without therapistId for client', clientId, 'in', timeSlot);
                return;
              }
              
              var assignment = {
                timeSlot: timeSlot,
                  therapistId: parseInt(therapistId),
                clientId: clientId,  // Use the key as clientId
                assignmentType: assignmentData.assignmentType || 'regular',
                assignmentStatus: assignmentData.assignmentStatus || 'red',
                startDate: assignmentData.startDate || '',
                notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [parseInt(therapistId)],
                therapistCount: assignmentData.therapistCount || 1,
                isNA: false
              };
              assignmentsArray.push(assignment);
            }
          });
        });
      }
      
      console.log('[CONVERT] Converted', assignmentsArray.length, 'assignment records');
      
      // Log first few assignments for debugging
      if (assignmentsArray.length > 0) {
        console.log('[CONVERT] Sample converted assignment:', assignmentsArray[0]);
      }
      
      return assignmentsArray;
    }

    /**
     * Load all data including client distances
     */
    async function loadAllData() {
      try {
        console.log('[DATA] Loading all data from backend...');
        
        // Call getMapData to get all data including client distances
        var result = await callBackendAPI('getMapData');
        
        if (result.success || result.therapists) {
          // Update all data stores
          if (result.therapists) {
            therapistsData = result.therapists;
            console.log('[DATA] Loaded', therapistsData.length, 'therapists');
          }
          
          if (result.clients) {
            clientsData = result.clients;
            console.log('[DATA] Loaded', clientsData.length, 'clients');
          }
          
          if (result.sessions) {
            sessionsData = result.sessions;
            console.log('[DATA] Loaded', sessionsData.length, 'sessions');
          }
          
          if (result.assignments) {
            // Convert assignments from object format to array format
            assignmentsData = convertAssignmentsToArray(result.assignments);
            console.log('[DATA] Loaded', assignmentsData.length, 'assignments');
          }
          
          if (result.clientDistances) {
            clientDistances = result.clientDistances;
            console.log('[DATA] Loaded', clientDistances.length, 'client distances');
            console.log('[DATA] Sample client distance:', clientDistances.length > 0 ? clientDistances[0] : 'none');
          } else {
            console.warn('[DATA] No clientDistances in getMapData response - client routing will be limited');
            clientDistances = [];
          }
          
          // Load notes separately since they might not be in getMapData
          await loadTherapistNotes();
          
          // Rebuild the table with new data
          buildScheduleTable();
          
          console.log('[DATA] All data loaded successfully');
          
        } else {
          throw new Error(result.error || 'Failed to load data from backend');
        }
        
      } catch (error) {
        console.error('[DATA] Error loading all data:', error);
        showStatusMessage('❌ Error loading data: ' + error.message, 'error');
      }
    }

    // Comprehensive diagnostic function
    async function runDiagnostics() {
      console.log('🔍 RUNNING COMPREHENSIVE DIAGNOSTICS...');
      
      const results = {
        environment: {},
        backend: {},
        data: {},
        schedules: {}
      };
      
      // Test 1: Environment Detection
      console.log('📋 Test 1: Environment Detection');
      results.environment.hasGoogle = typeof google !== 'undefined';
      results.environment.hasGoogleScript = typeof google !== 'undefined' && !!google.script;
      results.environment.hasGoogleScriptRun = typeof google !== 'undefined' && !!google.script && !!google.script.run;
      results.environment.userAgent = navigator.userAgent;
      results.environment.location = window.location.href;
      
      console.log('Environment results:', results.environment);
      
      // Test 2: Backend Connectivity
      console.log('📋 Test 2: Backend Connectivity');
      const backendTest = await testBackendConnectivity();
      results.backend = backendTest;
      
      // Test 3: Data Loading
      console.log('📋 Test 3: Data Loading');
      results.data.therapistsCount = therapistsData.length;
      results.data.clientsCount = clientsData.length;
      results.data.assignmentsCount = assignmentsData.length;
      results.data.sessionsCount = sessionsData.length;
      results.data.notesCount = Object.keys(notesData).length;
      
      // Test 4: Schedule Type Implementation
      console.log('📋 Test 4: Schedule Type Implementation');
      results.schedules.currentScheduleType = currentScheduleType;
      results.schedules.assignmentCreationInProgress = assignmentCreationInProgress;
      results.schedules.backendConnected = backendConnected;
      
      // Filter assignments by schedule type
      const currentAssignments = assignmentsData.filter(a => (a.scheduleType || 'current') === 'current');
      const futureAssignments = assignmentsData.filter(a => (a.scheduleType || 'current') === 'future');
      
      results.schedules.currentAssignmentsCount = currentAssignments.length;
      results.schedules.futureAssignmentsCount = futureAssignments.length;
      
      // Test 5: Assignment Creation Test
      console.log('📋 Test 5: Assignment Creation Test');
      if (results.backend.connected && therapistsData.length > 0 && clientsData.length > 0) {
        try {
          const testAssignment = {
            timeSlot: 'Monday-Morning',
            therapistId: therapistsData[0].id,
            clientId: clientsData[0].id,
            scheduleType: currentScheduleType,
            assignmentType: 'regular',
            assignmentStatus: 'red',
            startDate: '',
            notes: 'Diagnostic test assignment'
          };
          
          console.log('Testing assignment creation with:', testAssignment);
          const createResult = await callBackendAPI('updateAssignmentDetails', testAssignment);
          results.schedules.assignmentTestResult = createResult;
          
          // Clean up test assignment
          if (createResult.success) {
            await callBackendAPI('clearAssignment', {
              timeSlot: testAssignment.timeSlot,
              clientId: testAssignment.clientId,
              scheduleType: testAssignment.scheduleType
            });
          }
        } catch (error) {
          results.schedules.assignmentTestError = error.message;
        }
      } else {
        results.schedules.assignmentTestSkipped = 'Backend not connected or no test data available';
      }
      
      // Display comprehensive results
      console.log('🎯 DIAGNOSTIC RESULTS:', results);
      
      // Show user-friendly summary
      let summary = '🔍 DIAGNOSTIC SUMMARY:\n\n';
      
      if (results.environment.hasGoogleScriptRun) {
        summary += '✅ Google Apps Script environment detected\n';
      } else {
        summary += '❌ Google Apps Script environment NOT detected\n';
        summary += '   → Make sure you\'re accessing through the web app URL\n';
      }
      
      if (results.backend.connected) {
        summary += '✅ Backend connection working\n';
      } else {
        summary += '❌ Backend connection failed\n';
        summary += '   → ' + results.backend.error + '\n';
      }
      
      summary += `📊 Data loaded: ${results.data.therapistsCount} therapists, ${results.data.clientsCount} clients, ${results.data.assignmentsCount} assignments\n`;
      summary += `📅 Current schedule: ${results.schedules.currentScheduleType} (${results.schedules.currentAssignmentsCount} assignments)\n`;
      summary += `📅 Future schedule: ${results.schedules.futureAssignmentsCount} assignments\n`;
      
      if (results.schedules.assignmentTestResult) {
        if (results.schedules.assignmentTestResult.success) {
          summary += '✅ Assignment creation test PASSED\n';
        } else {
          summary += '❌ Assignment creation test FAILED\n';
          summary += '   → ' + results.schedules.assignmentTestResult.error + '\n';
        }
      }
      
      console.log(summary);
      showStatusMessage('Diagnostics complete - check console for detailed results', 'success');
      
      return results;
    }
    
    // Make diagnostic function available globally for console access
    window.runDiagnostics = runDiagnostics;
    
    /**
     * Force refresh data from backend (for manual recovery)
     * Can be called from console: forceRefreshData()
     */
    async function forceRefreshData() {
      console.log('🔄 FORCE REFRESH: Starting manual data refresh...');
      
      try {
        // Clear cache first
        clearDataCache();
        console.log('🗑️ Cache cleared');
        
        // Reset initialization flags
        dataInitialized = false;
        initializationInProgress = false;
        window.dataLoadingInProgress = false;
        
        // Clear existing data
        therapistsData = [];
        clientsData = [];
        sessionsData = [];
        assignmentsData = [];
        notesData = {};
        clientDistances = [];
        
        console.log('📊 Local data cleared');
        
        // Reload from backend
        await loadTableDataFromAPI();
        
        console.log('✅ FORCE REFRESH: Data successfully reloaded');
        showStatusMessage('✅ Data refreshed successfully from backend', 'success');
        
        return true;
      } catch (error) {
        console.error('❌ FORCE REFRESH: Failed to refresh data:', error);
        showStatusMessage('❌ Failed to refresh data: ' + error.message, 'error');
        return false;
      }
    }
    
    // Make force refresh available globally
    window.forceRefreshData = forceRefreshData;
    
    /**
     * Check assignment data integrity
     */
    function checkAssignmentDataIntegrity() {
      console.log('🔍 CHECKING ASSIGNMENT DATA INTEGRITY...');
      
      // Check if assignments exist
      console.log('Total assignments:', assignmentsData.length);
      
      if (assignmentsData.length === 0) {
        console.error('❌ No assignments found!');
        return false;
      }
      
      // Check first few assignments
      console.log('First 3 assignments:');
      assignmentsData.slice(0, 3).forEach((a, i) => {
        console.log(`Assignment ${i}:`, {
          therapistId: a.therapistId,
          type: typeof a.therapistId,
          clientId: a.clientId,
          timeSlot: a.timeSlot,
          scheduleType: a.scheduleType || 'current'
        });
      });
      
      // Check for field mapping issues
      var hasSwappedFields = false;
      assignmentsData.forEach(a => {
        if (a.therapistId && a.therapistId.includes('-')) {
          console.error('❌ Found swapped fields! therapistId contains timeSlot value:', a.therapistId);
          hasSwappedFields = true;
        }
      });
      
      // Test a specific lookup
      if (therapistsData.length > 0 && assignmentsData.length > 0) {
        var firstAssignment = assignmentsData[0];
        console.log('Testing getAssignment with first assignment data:');
        console.log('- therapistId:', firstAssignment.therapistId);
        console.log('- timeSlot:', firstAssignment.timeSlot);
        
        // Parse timeSlot
        if (firstAssignment.timeSlot && firstAssignment.timeSlot.includes('-')) {
          var parts = firstAssignment.timeSlot.split('-');
          var day = parts[0];
          var timeBlock = parts[1];
          console.log('- Parsed day:', day, 'timeBlock:', timeBlock);
          
          var result = getAssignment(firstAssignment.therapistId, day, timeBlock);
          console.log('- getAssignment result:', result);
        }
      }
      
      return !hasSwappedFields;
    }
    
    // Make available globally
    window.checkAssignmentDataIntegrity = checkAssignmentDataIntegrity;
    
    // Add assignment debugging function
    window.debugAssignments = function() {
      console.log('🔍 ASSIGNMENT DEBUGGING REPORT');
      console.log('Current schedule type:', currentScheduleType);
      console.log('Total assignments in memory:', assignmentsData.length);
      console.log('Sample assignments:', assignmentsData.slice(0, 3));
      
      // Check for assignments by schedule type
      var currentAssignments = assignmentsData.filter(a => (a.scheduleType || 'current') === 'current');
      var futureAssignments = assignmentsData.filter(a => (a.scheduleType || 'current') === 'future');
      
      console.log('Current schedule assignments:', currentAssignments.length);
      console.log('Future schedule assignments:', futureAssignments.length);
      
      // Check assignment structure
      if (assignmentsData.length > 0) {
        console.log('First assignment structure:', assignmentsData[0]);
        console.log('Assignment keys:', Object.keys(assignmentsData[0]));
      }
      
      // Test getAssignment function
      if (therapistsData.length > 0) {
        var testTherapist = therapistsData[0];
        var testAssignment = getAssignment(testTherapist.id, 'Monday', 'Morning');
        console.log('Test assignment for', testTherapist.name, 'Monday Morning:', testAssignment);
      }
      
      // Check for specific assignments
      console.log('Checking specific assignments...');
      var sampleAssignments = currentAssignments.slice(0, 5);
      sampleAssignments.forEach(function(a, index) {
        console.log(`Assignment ${index}:`, {
          therapistId: a.therapistId,
          clientId: a.clientId,
          timeSlot: a.timeSlot,
          scheduleType: a.scheduleType
        });
      });
      
      return {
        totalAssignments: assignmentsData.length,
        currentAssignments: currentAssignments.length,
        futureAssignments: futureAssignments.length,
        scheduleType: currentScheduleType
      };
    };
    
    // Add data stability testing
    window.testDataStability = function() {
      console.log('🔒 DATA STABILITY TEST');
      console.log('Current assignments count:', assignmentsData ? assignmentsData.length : 0);
      console.log('Current therapists count:', therapistsData ? therapistsData.length : 0);
      console.log('Current clients count:', clientsData ? clientsData.length : 0);
      console.log('Data stability monitor active:', !!window.dataStabilityMonitor);
      console.log('Last known counts:', {
        assignments: window.lastKnownAssignmentsCount || 0,
        therapists: window.lastKnownTherapistsCount || 0,
        clients: window.lastKnownClientsCount || 0
      });
      
      return {
        assignmentsCount: assignmentsData ? assignmentsData.length : 0,
        therapistsCount: therapistsData ? therapistsData.length : 0,
        clientsCount: clientsData ? clientsData.length : 0,
        monitorActive: !!window.dataStabilityMonitor
      };
    };
    
    // Add backend function testing
    window.testBackendFunctions = async function() {
      console.log('🧪 TESTING BACKEND FUNCTIONS');
      
      var results = {};
      
      // Test getMapData
      try {
        console.log('Testing getMapData...');
        var mapData = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getMapData();
        });
        results.getMapData = { success: true, data: mapData };
        console.log('✅ getMapData succeeded:', mapData ? 'has data' : 'null');
      } catch (error) {
        results.getMapData = { success: false, error: error.message };
        console.log('❌ getMapData failed:', error.message);
      }
      
      // Test getEssentialData
      try {
        console.log('Testing getEssentialData...');
        var essentialData = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getEssentialData();
        });
        results.getEssentialData = { success: true, data: essentialData };
        console.log('✅ getEssentialData succeeded:', essentialData ? 'has data' : 'null');
      } catch (error) {
        results.getEssentialData = { success: false, error: error.message };
        console.log('❌ getEssentialData failed:', error.message);
      }
      
      // Test makeDoPostRequest
      try {
        console.log('Testing makeDoPostRequest...');
        var doPostData = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .makeDoPostRequest('getMapData', {});
        });
        results.makeDoPostRequest = { success: true, data: doPostData };
        console.log('✅ makeDoPostRequest succeeded:', doPostData ? 'has data' : 'null');
      } catch (error) {
        results.makeDoPostRequest = { success: false, error: error.message };
        console.log('❌ makeDoPostRequest failed:', error.message);
      }
      
      console.log('🧪 BACKEND FUNCTION TEST RESULTS:', results);
      return results;
    };
    
    /**
     * Test client-to-client routing functionality
     * Call this from browser console to test: testClientRouting()
     */
    function testClientRouting() {
      console.log('=== TESTING CLIENT-TO-CLIENT ROUTING ===');
      
      console.log('1. Client distances available:', clientDistances ? clientDistances.length : 0);
      
      if (clientDistances && clientDistances.length > 0) {
        console.log('2. Sample client distance record:', clientDistances[0]);
        
        // Test findClosestClientsFromClient
        if (clientsData.length > 0) {
          var testClientId = clientsData[0].id;
          console.log('3. Testing findClosestClientsFromClient with client', testClientId);
          var closestClients = findClosestClientsFromClient(testClientId, 3);
          console.log('   - Found', closestClients.length, 'closest clients:');
          closestClients.forEach(function(client, index) {
            console.log('     ' + (index + 1) + '.', client.name, '-', client.distanceText);
          });
        }
        
        // Test getNextTimeSlot
        console.log('4. Testing getNextTimeSlot:');
        console.log('   - Monday-Morning →', getNextTimeSlot('Monday-Morning'));
        console.log('   - Monday-Mid →', getNextTimeSlot('Monday-Mid'));
        console.log('   - Monday-Afternoon →', getNextTimeSlot('Monday-Afternoon'));
        
        // Test assignment finding
        if (assignmentsData.length > 0) {
          console.log('5. Testing assignment finding:');
          var testAssignment = assignmentsData.find(function(a) { return a.clientId !== "N/A"; });
          if (testAssignment) {
            console.log('   - Sample assignment:', testAssignment);
            var routingHTML = getClientToClientRoutingHTML(testAssignment, testAssignment.timeSlot);
            console.log('   - Generated routing HTML length:', routingHTML.length);
          }
        }
        
        console.log('✅ Client routing test completed!');
        console.log('To test the UI:');
        console.log('1. Click on any assigned cell (green/purple) to see routing popup');
        console.log('2. Look for "Optimal Routing to [NextTimeSlot]" section');
        console.log('3. Check browser console for routing debug logs');
        
      } else {
        console.warn('❌ No client distances data available');
        console.log('To get client distances data:');
        console.log('1. Make sure the backend includes clientDistances in getMapData response');
        console.log('2. Or manually call: loadClientDistances()');
      }
      
      return {
        clientDistances: clientDistances ? clientDistances.length : 0,
        functionsAvailable: {
          findClosestClientsFromClient: typeof findClosestClientsFromClient,
          getNextTimeSlot: typeof getNextTimeSlot,
          getClientToClientRoutingHTML: typeof getClientToClientRoutingHTML
        }
      };
    }
    
    // Make test function available globally
    window.testClientRouting = testClientRouting;

    // =============================================
    // CLIENT DISTANCES CHUNKED PROCESSING FUNCTIONS
    // =============================================
    
    /**
     * Start chunked processing (with smart starting point detection)
     */
    async function startChunkedProcessing() {
      const chunkSize = parseInt(document.getElementById('chunkSize').value);
      
      console.log(`[CLIENT_DISTANCES] Starting CHUNKED processing with chunk size ${chunkSize}...`);
      
      try {
        // First, find the optimal starting point to avoid unnecessary work
        showStatusMessage('Finding optimal starting point...', 'info');
        
        const optimalResult = await callBackendAPI('getOptimalChunkStartAPI', {});
        
        let startIndex = 0;
        if (optimalResult.success && optimalResult.optimalStartIndex < optimalResult.totalClients) {
          startIndex = optimalResult.optimalStartIndex;
          console.log(`[CLIENT_DISTANCES] Using optimal start index: ${startIndex} (${optimalResult.completedClients}/${optimalResult.totalClients} clients already complete)`);
          
          showStatusMessage(`Smart start: Resuming at client ${startIndex} (${optimalResult.completedClients} clients already complete)`, 'success');
        } else {
          console.log(`[CLIENT_DISTANCES] Starting from beginning or all complete`);
          showStatusMessage('Starting from the beginning...', 'info');
        }
        
        // Initialize chunked state with optimal start point
        chunkedProcessingState = {
          inProgress: true,
          nextStartIndex: startIndex,
          chunkSize: chunkSize,
          totalClients: optimalResult.totalClients || 0
        };
        
        // Update UI
        document.getElementById('startChunkedButton').style.display = 'none';
        document.getElementById('continueChunkedButton').style.display = 'inline-block';
        document.getElementById('chunkedProgress').style.display = 'block';
        
        if (startIndex >= (optimalResult.totalClients || 0)) {
          showStatusMessage('🎉 All client distances are already complete!', 'success');
          
          // Reset UI since we're done
          document.getElementById('startChunkedButton').style.display = 'inline-block';
          document.getElementById('continueChunkedButton').style.display = 'none';
          chunkedProcessingState.inProgress = false;
          
          return;
        }
        
        // Process first chunk from optimal starting point
        await processNextChunk();
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error in smart start:', error);
        showStatusMessage(`Error finding optimal start: ${error.message}`, 'error');
        
        // Fallback to traditional start from beginning
        chunkedProcessingState = {
          inProgress: true,
          nextStartIndex: 0,
          chunkSize: chunkSize,
          totalClients: 0
        };
        
        // Update UI
        document.getElementById('startChunkedButton').style.display = 'none';
        document.getElementById('continueChunkedButton').style.display = 'inline-block';
        document.getElementById('chunkedProgress').style.display = 'block';
        
        // Process first chunk
        await processNextChunk();
      }
    }
    
    /**
     * Continue chunked processing with next chunk
     */
    async function continueChunkedProcessing() {
      if (!chunkedProcessingState.inProgress) {
        showStatusMessage('No chunked processing in progress', 'warning');
        return;
      }
      
      await processNextChunk();
    }
    
    /**
     * Process the next chunk in chunked processing
     */
    async function processNextChunk() {
      console.log(`[CLIENT_DISTANCES] Processing chunk starting at index ${chunkedProcessingState.nextStartIndex}...`);
      
      try {
        // Update button state
        const continueButton = document.getElementById('continueChunkedButton');
        const originalText = continueButton.textContent;
        continueButton.textContent = '⏳ Processing Chunk...';
        continueButton.disabled = true;
        
        const result = await callBackendAPI('initializeClientDistancesChunkedAPI', {
          chunkSize: chunkedProcessingState.chunkSize,
          startIndex: chunkedProcessingState.nextStartIndex
        });
        
        console.log('[CLIENT_DISTANCES] Chunk processing result:', result);
        
        // Reset button
        continueButton.textContent = originalText;
        continueButton.disabled = false;
        
        if (result.success) {
          // Update state
          chunkedProcessingState.totalClients = result.progress.totalClients;
          
          if (result.allComplete) {
            // All chunks complete!
            chunkedProcessingState.inProgress = false;
            
            document.getElementById('startChunkedButton').style.display = 'inline-block';
            document.getElementById('continueChunkedButton').style.display = 'none';
            
            const message = `🎉 All chunks completed successfully!<br>` +
                           `📊 Total clients processed: ${result.progress.totalClients}<br>` +
                           `⏱️ Last chunk duration: ${result.currentChunk.durationSeconds}s`;
            
            showStatusMessage(message, 'success');
            
            // Update progress to 100%
            updateChunkedProgressUI(result.progress.totalClients, result.progress.totalClients);
            
          } else {
            // More chunks to process
            chunkedProcessingState.nextStartIndex = result.progress.nextStartIndex;
            
            const message = `✅ Chunk completed!<br>` +
                           `📊 Processed clients ${result.currentChunk.startIndex}-${result.currentChunk.endIndex-1}<br>` +
                           `🔢 New calculations: ${result.currentChunk.calculations}<br>` +
                           `⏱️ Duration: ${result.currentChunk.durationSeconds}s<br>` +
                           `▶️ Next chunk starts at client ${result.progress.nextStartIndex}`;
            
            showStatusMessage(message, 'info');
            
            // Update progress UI
            updateChunkedProgressUI(result.progress.clientsProcessed, result.progress.totalClients);
          }
          
          // Refresh stats (includes chunked progress fix)
          await refreshClientDistanceStats();
          
        } else {
          showStatusMessage(`❌ Chunk processing failed: ${result.error}`, 'error');
          
          // Reset chunked state
          chunkedProcessingState.inProgress = false;
          document.getElementById('startChunkedButton').style.display = 'inline-block';
          document.getElementById('continueChunkedButton').style.display = 'none';
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error in chunk processing:', error);
        
        // Reset button
        const continueButton = document.getElementById('continueChunkedButton');
        continueButton.textContent = '▶️ Continue Next Chunk';
        continueButton.disabled = false;
        
        showStatusMessage(`❌ Chunk processing error: ${error.message}`, 'error');
        
        // Reset chunked state
        chunkedProcessingState.inProgress = false;
        document.getElementById('startChunkedButton').style.display = 'inline-block';
        document.getElementById('continueChunkedButton').style.display = 'none';
      }
    }
    
    /**
     * Update chunked processing progress UI
     */
    function updateChunkedProgressUI(clientsProcessed, totalClients) {
      const percentage = Math.round((clientsProcessed / totalClients) * 100);
      
      document.getElementById('chunkedProgressText').textContent = 
        `${clientsProcessed} / ${totalClients} clients processed (${percentage}%)`;
      
      document.getElementById('chunkedProgressBar').style.width = `${percentage}%`;
    }
    
    /**
     * ✅ VERIFY: Check for duplicate calculations
     */
    async function verifyNoDuplicates() {
      console.log('[CLIENT_DISTANCES] Verifying no duplicates...');
      
      try {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '⏳ Checking...';
        button.disabled = true;
        
        const result = await callBackendAPI('verifyNoDuplicatesAPI', {});
        
        console.log('[CLIENT_DISTANCES] Duplicate verification result:', result);
        
        // Reset button
        button.textContent = originalText;
        button.disabled = false;
        
        if (result.success) {
          if (result.hasDuplicates) {
            const message = `⚠️ Found ${result.duplicateCount} duplicates!<br>` +
                           `📊 Total calculations: ${result.totalCalculations}<br>` +
                           `🔍 Unique pairs: ${result.uniquePairs}<br>` +
                           `❌ Duplicates: ${result.duplicateCount}`;
            showStatusMessage(message, 'error');
          } else {
            const message = `✅ No duplicates found!<br>` +
                           `📊 Total calculations: ${result.totalCalculations}<br>` +
                           `🔍 All ${result.uniquePairs} pairs are unique<br>` +
                           `✨ Data integrity confirmed`;
            showStatusMessage(message, 'success');
          }
        } else {
          showStatusMessage(`❌ Verification failed: ${result.error}`, 'error');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error verifying duplicates:', error);
        
        // Reset button
        const button = event.target;
        button.textContent = '🔍 Verify No Duplicates';
        button.disabled = false;
        
        showStatusMessage(`❌ Verification error: ${error.message}`, 'error');
      }
    }
    
    /**
     * ✅ OPTIMIZE: Find optimal starting point for chunked processing
     */
    async function findOptimalStart() {
      console.log('[CLIENT_DISTANCES] Finding optimal starting point...');
      
      try {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '⏳ Analyzing...';
        button.disabled = true;
        
        const result = await callBackendAPI('getOptimalChunkStartAPI', {});
        
        console.log('[CLIENT_DISTANCES] Optimal start result:', result);
        
        // Reset button
        button.textContent = originalText;
        button.disabled = false;
        
        if (result.success) {
          // Update chunked processing state with optimal start
          chunkedProcessingState.nextStartIndex = result.optimalStartIndex;
          
          const message = `🎯 Optimal starting point found!<br>` +
                         `📊 Completed clients: ${result.completedClients} / ${result.totalClients} (${result.clientProgress}%)<br>` +
                         `🚀 Next chunk should start at: Client index ${result.optimalStartIndex}<br>` +
                         `💾 ${result.message}`;
          
          showStatusMessage(message, 'success');
          
          // Update the chunked progress to show the correct starting point
          if (result.optimalStartIndex < result.totalClients) {
            document.getElementById('startChunkedButton').style.display = 'none';
            document.getElementById('continueChunkedButton').style.display = 'inline-block';
            document.getElementById('chunkedProgress').style.display = 'block';
            
            // Update progress bar with client progress (not calculation progress)
            const clientPercentage = Math.round((result.completedClients / result.totalClients) * 100);
            document.getElementById('chunkedProgressText').textContent = 
              `${result.completedClients} / ${result.totalClients} clients complete (${clientPercentage}%) - Ready to resume`;
            document.getElementById('chunkedProgressBar').style.width = `${clientPercentage}%`;
          }
          
        } else {
          showStatusMessage(`❌ Analysis failed: ${result.error}`, 'error');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error finding optimal start:', error);
        
        // Reset button
        const button = event.target;
        button.textContent = '🎯 Find Optimal Start';
        button.disabled = false;
        
        showStatusMessage(`❌ Analysis error: ${error.message}`, 'error');
      }
    }
    
    /**
     * ✅ OVERRIDE: Enhanced refreshClientDistanceStats with chunked progress fix
     */
    const originalRefreshClientDistanceStats = window.refreshClientDistanceStats;
    async function refreshClientDistanceStats() {
      console.log('[CLIENT_DISTANCES] Refreshing stats...');
      
      try {
        const result = await callBackendAPI('getClientDistanceStats', {});
        console.log('[CLIENT_DISTANCES] Stats result:', result);
        
        if (result.success) {
          // Update UI elements
          document.getElementById('totalClientsCount').textContent = result.clientCount;
          document.getElementById('expectedCalculationsCount').textContent = result.expectedCalculations.toLocaleString();
          document.getElementById('currentCalculationsCount').textContent = result.currentCalculations.toLocaleString();
          document.getElementById('completionPercentage').textContent = result.completionPercentage + '%';
          document.getElementById('lastUpdated').textContent = result.lastUpdated;
          
          // Update completion status
          const completionElement = document.getElementById('completionPercentage');
          if (result.isComplete) {
            completionElement.style.color = '#4CAF50';
            completionElement.style.fontWeight = 'bold';
          } else {
            completionElement.style.color = '#FF9800';
          }
          
          // ✅ FIX: Update chunked progress bar with ACTUAL progress from backend
          updateChunkedProgressFromBackend(result);
          
        } else {
          showStatusMessage('Failed to load client distance stats: ' + result.error, 'error');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error refreshing stats:', error);
        showStatusMessage('Error loading client distance stats: ' + error.message, 'error');
      }
    }
    
    /**
     * ✅ FIX: Update chunked progress UI based on actual backend data (fixes page refresh issue)
     */
    function updateChunkedProgressFromBackend(statsResult) {
      const totalClients = statsResult.clientCount;
      const currentCalculations = statsResult.currentCalculations;
      const expectedCalculations = statsResult.expectedCalculations;
      
      console.log('[CLIENT_DISTANCES] Updating chunked progress from backend data:', {
        totalClients,
        currentCalculations,
        expectedCalculations,
        percentage: Math.round((currentCalculations / expectedCalculations) * 100)
      });
      
      // Update the chunked processing state with real data
      chunkedProcessingState.totalClients = totalClients;
      
      // Update chunked progress UI with actual data
      if (currentCalculations > 0) {
        // Show the progress section since we have data
        document.getElementById('chunkedProgress').style.display = 'block';
        
        // Update progress text and bar with REAL data from backend
        const actualPercentage = Math.round((currentCalculations / expectedCalculations) * 100);
        
        document.getElementById('chunkedProgressText').textContent = 
          `${currentCalculations.toLocaleString()} / ${expectedCalculations.toLocaleString()} calculations complete (${actualPercentage}%)`;
        
        document.getElementById('chunkedProgressBar').style.width = `${actualPercentage}%`;
        
        // Update button states based on actual completion status
        if (statsResult.isComplete) {
          // All complete - show start button, hide continue
          document.getElementById('startChunkedButton').style.display = 'inline-block';
          document.getElementById('continueChunkedButton').style.display = 'none';
          chunkedProcessingState.inProgress = false;
          
          // Update text to show completion
          document.getElementById('chunkedProgressText').textContent = 
            `✅ All ${expectedCalculations.toLocaleString()} calculations complete (100%)`;
          document.getElementById('chunkedProgressBar').style.width = '100%';
          
        } else {
          // Partially complete - show continue button if we have significant progress
          if (currentCalculations > 100) { // Arbitrary threshold for "significant progress"
            document.getElementById('startChunkedButton').style.display = 'none';
            document.getElementById('continueChunkedButton').style.display = 'inline-block';
            
            // Estimate next start index based on current progress
            // Each client should have (totalClients - 1) outbound calculations
            const expectedPerClient = totalClients - 1;
            const approximateProcessedClients = Math.floor(currentCalculations / expectedPerClient);
            const estimatedNextStart = Math.min(approximateProcessedClients, totalClients);
            
            chunkedProcessingState.nextStartIndex = estimatedNextStart;
            chunkedProcessingState.inProgress = false; // Reset since we refreshed page
            
            console.log('[CLIENT_DISTANCES] Estimated next start index:', estimatedNextStart);
          } else {
            // Very little progress - show start button
            document.getElementById('startChunkedButton').style.display = 'inline-block';
            document.getElementById('continueChunkedButton').style.display = 'none';
          }
        }
        
      } else {
        // No calculations yet - hide progress section
        document.getElementById('chunkedProgress').style.display = 'none';
        document.getElementById('startChunkedButton').style.display = 'inline-block';
        document.getElementById('continueChunkedButton').style.display = 'none';
        chunkedProcessingState.inProgress = false;
      }
    }

    // =============================================
    // CLIENT DISTANCES MANAGEMENT FUNCTIONALITY
    // =============================================
    
    /**
     * Show client distances management dialog
     */
    async function showClientDistancesDialog() {
      console.log('[CLIENT_DISTANCES] Opening management dialog...');
      
      // Ensure data is loaded
      if (clientsData.length === 0) {
        console.log('[DIALOG] Clients data empty - loading now...');
        await loadAllData();
      }
      
      // Show the popup
      document.getElementById('clientDistancesPopup').style.display = 'flex';
      
      // Load current statistics
      await refreshClientDistanceStats();
      
      // Auto-detect new clients when dialog opens
      await refreshNewClientsDetection();
      
      // Populate dropdowns
      populateTestClientDropdown();
      populateManualClientDropdown();
    }
    
    /**
     * Refresh client distance statistics
     */
    async function refreshClientDistanceStats() {
      console.log('[CLIENT_DISTANCES] Refreshing statistics...');
      
      try {
        document.getElementById('clientDistancesMessage').textContent = 'Loading statistics...';
        
        const result = await callBackendAPI('getClientDistanceStats', {});
        
        console.log('[CLIENT_DISTANCES] Stats result:', result);
        
        if (result.success) {
          // Update statistics display
          document.getElementById('totalClientsCount').textContent = result.clientCount;
          document.getElementById('expectedCalculationsCount').textContent = result.expectedCalculations;
          document.getElementById('currentCalculationsCount').textContent = result.currentCalculations;
          document.getElementById('completionPercentage').textContent = result.completionPercentage + '%';
          
          // Update status message
          if (result.isComplete) {
            document.getElementById('clientDistancesMessage').innerHTML = 
              '✅ <strong>Client distances are fully calculated!</strong><br>' +
              `Last updated: ${result.lastUpdated}`;
            document.getElementById('initializeDistancesButton').textContent = 'Recalculate All Distances';
          } else if (result.currentCalculations > 0) {
            document.getElementById('clientDistancesMessage').innerHTML = 
              '⚠️ <strong>Client distances are partially calculated.</strong><br>' +
              `${result.currentCalculations} of ${result.expectedCalculations} calculations completed (${result.completionPercentage}%)`;
            document.getElementById('initializeDistancesButton').textContent = 'Complete Missing Calculations';
          } else {
            document.getElementById('clientDistancesMessage').innerHTML = 
              '❌ <strong>No client distances calculated yet.</strong><br>' +
              'Click "Initialize All Client Distances" to start calculating distances between all clients.';
            document.getElementById('initializeDistancesButton').textContent = 'Initialize All Client Distances';
          }
          
          // Show sheet status
          if (!result.sheetExists) {
            document.getElementById('clientDistancesMessage').innerHTML += 
              '<br><em>Note: ClientDistances sheet will be created automatically.</em>';
          }
          
        } else {
          throw new Error(result.error || 'Failed to get statistics');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error refreshing stats:', error);
        document.getElementById('clientDistancesMessage').innerHTML = 
          '❌ <strong>Error loading statistics:</strong><br>' + error.message;
      }
    }
    
    /**
     * Initialize all client-to-client distances
     */
    async function initializeClientDistances() {
      console.log('[CLIENT_DISTANCES] Starting initialization...');
      
      // Get current stats for confirmation
      try {
        const stats = await callBackendAPI('getClientDistanceStats', {});
        
        if (!stats.success) {
          showStatusMessage('❌ Failed to get current statistics', 'error');
          return;
        }
        
        // Confirmation dialog
        const clientCount = stats.clientCount;
        const expectedCalculations = stats.expectedCalculations;
        const estimatedMinutes = Math.round(expectedCalculations * 0.3 / 60); // Rough estimate
        
        let confirmMessage = `Initialize distances for ${clientCount} clients?\n\n`;
        confirmMessage += `• ${expectedCalculations} distance calculations required\n`;
        confirmMessage += `• Estimated time: ${estimatedMinutes} minutes\n`;
        confirmMessage += `• Google Maps API calls: ${expectedCalculations}\n\n`;
        
        if (stats.currentCalculations > 0) {
          confirmMessage += `This will replace ${stats.currentCalculations} existing calculations.\n\n`;
        }
        
        confirmMessage += 'Continue?';
        
        if (!confirm(confirmMessage)) {
          return;
        }
        
        // Close main dialog and show progress
        document.getElementById('clientDistancesPopup').style.display = 'none';
        document.getElementById('clientDistancesProgressPopup').style.display = 'flex';
        
        // Reset progress UI
        document.getElementById('clientDistancesProgressMessage').textContent = 'Starting distance calculations...';
        document.getElementById('clientDistancesProgressFill').style.width = '0%';
        document.getElementById('clientDistancesProgressText').textContent = 'Preparing...';
        
        // Update progress
        updateClientDistancesProgress(10, 'Calling backend API...');
        
        console.log('[CLIENT_DISTANCES] Calling backend to initialize distances...');
        
        // Call backend API
        const result = await callBackendAPI('initializeClientDistancesAPI', {});
        
        console.log('[CLIENT_DISTANCES] Initialization result:', result);
        
        // Update progress to completion
        updateClientDistancesProgress(100, 'Calculations complete!');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Close progress and show results
        document.getElementById('clientDistancesProgressPopup').style.display = 'none';
        showClientDistancesResults(result);
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error in initialization:', error);
        
        // Show error in progress dialog
        document.getElementById('clientDistancesProgressMessage').textContent = 'Error occurred during initialization';
        document.getElementById('clientDistancesProgressText').textContent = `Error: ${error.message}`;
        document.getElementById('clientDistancesProgressFill').style.backgroundColor = '#f44336';
        
        // Allow user to close after error
        setTimeout(() => {
          document.getElementById('clientDistancesProgressPopup').style.display = 'none';
          showClientDistancesResults({
            success: false,
            error: error.message,
            clientCount: 0,
            actualCalculations: 0,
            durationSeconds: 0
          });
        }, 3000);
      }
    }
    
    /**
     * Initialize client distances (FULL processing - all clients)
     */
    async function initializeClientDistances() {
      console.log('[CLIENT_DISTANCES] Starting FULL client distance initialization...');
      
      try {
        // Show progress popup
        document.getElementById('clientDistancesProgressPopup').style.display = 'flex';
        document.getElementById('clientDistancesProgressMessage').textContent = 'Initializing distance calculations...';
        updateClientDistancesProgress(10, 'Starting full distance calculations...');
        
        // Call backend API
        const result = await callBackendAPI('initializeClientDistancesAPI', {});
        
        console.log('[CLIENT_DISTANCES] Initialization result:', result);
        
        // Update progress to completion
        updateClientDistancesProgress(100, 'Calculations complete!');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Close progress and show results
        document.getElementById('clientDistancesProgressPopup').style.display = 'none';
        showClientDistancesResults(result);
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error in initialization:', error);
        
        // Show error in progress dialog
        document.getElementById('clientDistancesProgressMessage').textContent = 'Error occurred during initialization';
        document.getElementById('clientDistancesProgressText').textContent = `Error: ${error.message}`;
        document.getElementById('clientDistancesProgressFill').style.backgroundColor = '#f44336';
        
        // Allow user to close after error
        setTimeout(() => {
          document.getElementById('clientDistancesProgressPopup').style.display = 'none';
          showClientDistancesResults({
            success: false,
            error: error.message,
            clientCount: 0,
            actualCalculations: 0,
            durationSeconds: 0
          });
        }, 3000);
      }
    }

    /**
     * ✨ MISSING FUNCTION: Initialize LIMITED client distances (Test with smaller number)
     * This is the function that the "🚀 Run Limited Test" button calls
     */
    async function initializeLimitedClientDistances() {
      console.log('[CLIENT_DISTANCES] Starting LIMITED client distance initialization...');
      
      try {
        // Get the selected number of clients
        const maxClients = parseInt(document.getElementById('limitedClientCount').value) || 20;
        console.log(`[CLIENT_DISTANCES] Limited test with ${maxClients} clients`);
        
        // Show progress popup
        document.getElementById('clientDistancesProgressPopup').style.display = 'flex';
        document.getElementById('clientDistancesProgressMessage').textContent = `Initializing limited test with ${maxClients} clients...`;
        updateClientDistancesProgress(10, `Starting limited test (${maxClients} clients)...`);
        
        // Call backend API for limited processing
        const result = await callBackendAPI('initializeClientDistancesLimitedAPI', { 
          maxClients: maxClients 
        });
        
        console.log('[CLIENT_DISTANCES] Limited initialization result:', result);
        
        if (result.success) {
          // Update progress to completion
          updateClientDistancesProgress(100, `Limited test complete! Processed ${result.clientCount} clients`);
          
          // Small delay to show completion
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Close progress and show results
          document.getElementById('clientDistancesProgressPopup').style.display = 'none';
          showClientDistancesResults(result);
          
          // Refresh stats to show updated numbers
          await refreshClientDistanceStats();
          
        } else {
          throw new Error(result.error || 'Limited test failed');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error in limited initialization:', error);
        
        // Show error in progress dialog
        document.getElementById('clientDistancesProgressMessage').textContent = 'Error occurred during limited test';
        document.getElementById('clientDistancesProgressText').textContent = `Error: ${error.message}`;
        document.getElementById('clientDistancesProgressFill').style.backgroundColor = '#f44336';
        
        // Allow user to close after error
        setTimeout(() => {
          document.getElementById('clientDistancesProgressPopup').style.display = 'none';
          showClientDistancesResults({
            success: false,
            error: error.message,
            clientCount: 0,
            actualCalculations: 0,
            durationSeconds: 0
          });
        }, 3000);
      }
    }
    
    /**
     * Update client distances progress UI
     */
    function updateClientDistancesProgress(percentage, message) {
      document.getElementById('clientDistancesProgressFill').style.width = percentage + '%';
      document.getElementById('clientDistancesProgressText').textContent = message;
      
      if (percentage >= 50) {
        document.getElementById('clientDistancesProgressMessage').textContent = 'Calculating distances...';
      }
    }
    
    /**
     * Show client distances calculation results
     */
    function showClientDistancesResults(result) {
      console.log('[CLIENT_DISTANCES] Showing results:', result);
      
      // Update result counts
      document.getElementById('resultClientsProcessed').textContent = result.clientCount || '-';
      document.getElementById('resultCalculationsCompleted').textContent = result.actualCalculations || '0';
      document.getElementById('resultProcessingTime').textContent = result.durationSeconds ? `${result.durationSeconds} seconds` : '-';
      document.getElementById('resultApiCalls').textContent = result.actualCalculations || '0';
      
      // Show result message
      const messageDiv = document.getElementById('clientDistancesResultMessage');
      
      if (result.success) {
        messageDiv.innerHTML = `
          <h4 style="color: #4CAF50; margin: 0 0 10px 0;">✅ Success!</h4>
          <p><strong>${result.message}</strong></p>
          <p>All client-to-client distances have been calculated and stored in the ClientDistances sheet.</p>
          <p><em>You can now use proximity-based scheduling features.</em></p>
        `;
        messageDiv.style.backgroundColor = '#e8f5e9';
        messageDiv.style.borderLeft = '4px solid #4CAF50';
      } else {
        messageDiv.innerHTML = `
          <h4 style="color: #f44336; margin: 0 0 10px 0;">❌ Error</h4>
          <p><strong>Distance calculation failed:</strong></p>
          <p>${result.error || 'Unknown error occurred'}</p>
          <p><em>Please check the console for detailed error information.</em></p>
        `;
        messageDiv.style.backgroundColor = '#ffebee';
        messageDiv.style.borderLeft = '4px solid #f44336';
      }
      
      // Show results popup
      document.getElementById('clientDistancesResultsPopup').style.display = 'flex';
    }
    
    /**
     * Populate test client dropdown
     */
    function populateTestClientDropdown() {
      console.log('[POPULATE] Populating test dropdown... Clients available:', clientsData.length);
      const select = document.getElementById('testClientSelect');
      select.innerHTML = '<option value="">Select a client to test...</option>';
      
      if (clientsData && clientsData.length > 0) {
        clientsData.forEach(client => {
          const option = document.createElement('option');
          option.value = client.id;
          option.textContent = client.name;
          select.appendChild(option);
        });
        console.log('[POPULATE] Added', clientsData.length, 'clients to test dropdown');
      } else {
        console.warn('[POPULATE] No clients data available for test dropdown');
      }
    }
    
    /**
     * Populate manual client dropdown
     */
    function populateManualClientDropdown() {
      console.log('[POPULATE] Populating manual dropdown... Clients available:', clientsData.length);
      const select = document.getElementById('manualSourceClient');
      select.innerHTML = '<option value="">Select source client...</option>';
      
      if (clientsData && clientsData.length > 0) {
        // Sort by name
        const sortedClients = [...clientsData].sort((a, b) => a.name.localeCompare(b.name));
        sortedClients.forEach(client => {
          const option = document.createElement('option');
          option.value = client.id;
          option.textContent = client.name;
          select.appendChild(option);
        });
        console.log('[POPULATE] Added', sortedClients.length, 'sorted clients to manual dropdown');
      } else {
        console.warn('[POPULATE] No clients data available for manual dropdown');
      }
    }
    
    /**
     * Test proximity ranking for selected client
     */
    async function testClientProximity() {
      const clientId = document.getElementById('testClientSelect').value;
      
      if (!clientId) {
        showStatusMessage('Please select a client to test', 'error');
        return;
      }
      
      try {
        console.log('[CLIENT_DISTANCES] Testing proximity for client:', clientId);
        
        const result = await callBackendAPI('testProximityRanking', { clientId: clientId });
        
        console.log('[CLIENT_DISTANCES] Proximity test result:', result);
        
        if (result.success) {
          // Show results
          const resultsDiv = document.getElementById('proximityResultsList');
          resultsDiv.innerHTML = '';
          
          if (result.proximityResults.length === 0) {
            resultsDiv.innerHTML = '<em>No clients found within 15 minutes of this client.</em>';
          } else {
            result.proximityResults.forEach(client => {
              const item = document.createElement('div');
              item.style.padding = '8px';
              item.style.borderBottom = '1px solid #eee';
              item.innerHTML = `
                <strong>${client.clientName}</strong><br>
                <small>${client.durationInMinutes} minutes (${client.distanceText})</small>
              `;
              resultsDiv.appendChild(item);
            });
          }
          
          document.getElementById('proximityTestResults').style.display = 'block';
          showStatusMessage(`✅ Found ${result.resultCount} nearby clients`, 'success');
          
        } else {
          throw new Error(result.error || 'Proximity test failed');
        }
        
      } catch (error) {
        console.error('[CLIENT_DISTANCES] Error testing proximity:', error);
        showStatusMessage('❌ Failed to test proximity: ' + error.message, 'error');
      }
    }
    
    /**
     * Close client distances management dialog
     */
    function closeClientDistancesDialog() {
      document.getElementById('clientDistancesPopup').style.display = 'none';
    }
    
    /**
     * Close client distances results dialog
     */
    function closeClientDistancesResults() {
      document.getElementById('clientDistancesResultsPopup').style.display = 'none';
    }
    
    // Event listeners for client distances dialogs
    document.addEventListener('DOMContentLoaded', function() {
      // Close button event listeners
      const closeClientDistances = document.getElementById('closeClientDistances');
      const closeClientDistancesResults = document.getElementById('closeClientDistancesResults');
      
      if (closeClientDistances) {
        closeClientDistances.addEventListener('click', closeClientDistancesDialog);
      }
      
      if (closeClientDistancesResults) {
        closeClientDistancesResults.addEventListener('click', closeClientDistancesResults);
      }
    });
    
    // Make client distances functions available globally for console access
    window.showClientDistancesDialog = showClientDistancesDialog;
    window.initializeClientDistances = initializeClientDistances;
    window.testClientProximity = testClientProximity;

    // Test backend connectivity
    async function testBackendConnectivity() {
      console.log('[CONNECTIVITY] Starting backend test...');
      try {
        const basicResponse = await callBackendAPI('testGrokConnectivity');
        console.log('[CONNECTIVITY] Basic response:', basicResponse);
        if (!basicResponse || !basicResponse.success) {
          return {success: false, error: basicResponse ? basicResponse.error : 'Null basic response'};
        }
        const sheetResponse = await callBackendAPI('testSpreadsheetAccess');
        console.log('[CONNECTIVITY] Sheet access response:', sheetResponse);
        if (!sheetResponse || !sheetResponse.success) {
          return {success: false, error: sheetResponse ? sheetResponse.error : 'Null sheet response'};
        }
        console.log('[CONNECTIVITY] All tests successful');
        return {success: true};
      } catch (error) {
        console.error('[CONNECTIVITY] Test error:', error);
        return {success: false, error: error.message};
      }
    }

    // Schedule switching function
    function switchSchedule(scheduleType) {
      console.log('[SCHEDULE] Switching to', scheduleType, 'schedule');
      
      // Update global variable
      currentScheduleType = scheduleType;
      
      // Update tab appearance
      document.getElementById('currentScheduleTab').classList.toggle('active', scheduleType === 'current');
      document.getElementById('futureScheduleTab').classList.toggle('active', scheduleType === 'future');
      
      // Update copy button text
      var copyButton = document.getElementById('copyScheduleText');
      if (copyButton) {
        copyButton.textContent = scheduleType === 'current' ? 'Copy to Future' : 'Copy to Current';
      }
      
      // Update copy menu text
      var copyEntireText = document.getElementById('copyEntireText');
      if (copyEntireText) {
        copyEntireText.textContent = scheduleType === 'current' ? 
          'Copy Entire Current Schedule to Future' : 
          'Copy Entire Future Schedule to Current';
      }
      
      var copySelectedText = document.getElementById('copySelectedText');
      if (copySelectedText) {
        copySelectedText.textContent = scheduleType === 'current' ? 
          'Copy Selected Therapists to Future' : 
          'Copy Selected Therapists to Current';
      }
      
      // Clear any selections when switching schedules
      selectedTherapists.clear();
      updateSelectionCounter();
      
      // Rebuild the table to show the new schedule
      buildScheduleTable();
      
      // Show status message
      var scheduleLabel = scheduleType === 'current' ? 'Current' : 'Future';
      showStatusMessage('📅 Switched to ' + scheduleLabel + ' Schedule', 'success');
      
      console.log('[SCHEDULE] Successfully switched to', scheduleType, 'schedule');
    }

    // Helper function to get assignment for a therapist on a day/time slot
    function getAssignment(therapistId, day, timeBlock) {
      var slotKey = day + "-" + timeBlock;
      
      // Removed excessive debugging
      
      // Filter assignments by current schedule type
      var scheduleAssignments = assignmentsData.filter(function(a) {
        return (a.scheduleType || "current") === currentScheduleType;
      });
      
      // Removed debugging
      
      // Check for N/A assignment first
      var naAssignment = scheduleAssignments.find(function(a) {
        // FIXED: Use correct field mapping - no field swapping needed
        var matches = a.timeSlot === slotKey && 
                     Number(a.therapistId) === Number(therapistId) && 
                     a.clientId === "N/A";
        
        // Additional fallback check using isNA flag for robustness
        if (!matches && a.isNA) {
          matches = a.timeSlot === slotKey && 
                   Number(a.therapistId) === Number(therapistId);
        }
        
        return matches;
      });
      
      if (naAssignment) {
        console.log('[DEBUG] Found N/A assignment for', therapistId, slotKey, ':', naAssignment);
        return { 
          clientId: "N/A",
          clientName: "N/A",
          class: "na", 
          isNA: true 
        };
      }
      
      // Check for regular client assignment (single or multi-therapist)
      var clientAssignment = scheduleAssignments.find(function(a) {
        var therapistMatch = String(a.therapistId) === String(therapistId) || 
                            (a.therapistIds && a.therapistIds.includes(String(therapistId)));
        var timeSlotMatch = a.timeSlot === slotKey;
        var notNA = a.clientId !== "N/A";
        
        // Debug log for troubleshooting
        if (window.assignmentDebugCount % 10 === 0 && !window.debuggedMatching) {
          console.log('[MATCH_DEBUG] Checking assignment:', {
            assignment: a,
            therapistId: a.therapistId,
            expectedTherapistId: therapistId,
            therapistMatch: therapistMatch,
            timeSlot: a.timeSlot,
            expectedTimeSlot: slotKey,
            timeSlotMatch: timeSlotMatch,
            notNA: notNA,
            willMatch: timeSlotMatch && therapistMatch && notNA
          });
          window.debuggedMatching = true;
        }
        
        return timeSlotMatch && therapistMatch && notNA;
      });
      
      if (clientAssignment) {
        var result = {
          clientId: clientAssignment.clientId,
          clientName: getClientName(clientAssignment.clientId),
          class: "assigned",
          assignmentType: clientAssignment.assignmentType,
          assignmentStatus: clientAssignment.assignmentStatus,
          startDate: clientAssignment.startDate,
          notes: clientAssignment.notes
        };
        
        // Enhanced multi-therapist detection: Check if this assignment is multi-therapist
        // Method 1: Check the assignment record itself
        var isMultiFromRecord = clientAssignment.isMultiTherapist;
        
        // Method 2: Check if there are other assignments with same client/timeSlot (fallback detection)
        var sameClientTimeSlot = scheduleAssignments.filter(function(a) {
          return a.timeSlot === slotKey && 
                 Number(a.clientId) === Number(clientAssignment.clientId) && 
                 a.clientId !== "N/A";
        });
        var isMultiFromCount = sameClientTimeSlot.length > 1;
        
        // Use either method to determine multi-therapist status
        var isMultiTherapist = isMultiFromRecord || isMultiFromCount;
        
        if (isMultiTherapist) {
          result.isMultiTherapist = true;
          
          // Get all therapist IDs from the assignment record or from multiple records
          if (clientAssignment.therapistIds && clientAssignment.therapistIds.length > 0) {
            result.therapistIds = clientAssignment.therapistIds;
            result.therapistCount = clientAssignment.therapistCount || clientAssignment.therapistIds.length;
          } else {
            // Fallback: collect therapist IDs from all matching assignments
            result.therapistIds = sameClientTimeSlot.map(function(a) { return String(a.therapistId); });
            result.therapistCount = result.therapistIds.length;
          }
          
          result.allTherapistNames = result.therapistIds.map(function(id) {
            return getTherapistName(id);
          });
          
          result.therapistDistances = result.therapistIds.map(function(tId) {
            var session = sessionsData.find(function(s) {
              return Number(s.therapistId) === Number(tId) && 
                     Number(s.clientId) === Number(clientAssignment.clientId);
            });
            
            return {
              therapistId: tId,
              therapistName: getTherapistName(tId),
              distance: session ? session.distance_miles : null,
              travelTime: session ? session.travelTime_minutes : null,
              distanceText: session ? formatDistance(session.distance_miles) + " mi" : "Unknown",
              durationText: session ? session.travelTime_minutes + " mins" : "Unknown"
            };
          });
          
          console.log('[DEBUG] Multi-therapist assignment detected for', therapistId, ':', {
            client: result.clientName,
            timeSlot: slotKey,
            therapistCount: result.therapistCount,
            therapistIds: result.therapistIds,
            fromRecord: isMultiFromRecord,
            fromCount: isMultiFromCount
          });
        }
        
        return result;
      }
      
      return { clientName: "", class: "open" };
    }
    
    // Function to switch between schedule types
    function switchSchedule(scheduleType) {
      console.log("[SCHEDULE] Switching to " + scheduleType + " schedule");
      
      // Update current schedule type
      currentScheduleType = scheduleType;
      
      // Update tab appearance
      document.querySelectorAll('.schedule-tab').forEach(function(tab) {
        tab.classList.remove('active');
      });
      
      if (scheduleType === "current") {
        document.getElementById('currentScheduleTab').classList.add('active');
      } else {
        document.getElementById('futureScheduleTab').classList.add('active', 'future');
      }
      
      // Update copy button text based on current schedule and selection
      updateCopyButtonState();
      
      // Rebuild the table for the new schedule
      buildScheduleTable();
      
      // Show which schedule is active
      var scheduleLabel = scheduleType === "current" ? "Current" : "Future";
      showStatusMessage("Switched to " + scheduleLabel + " Schedule", "success");
      
      // Close any open popups
      closePopup();
      hideCopyScheduleMenu();
    }
    
    
    // Function to highlight search matches in text
    function highlightText(text, searchTerm) {
      if (!searchTerm) return text;
      
      var regex = new RegExp("(" + escapeRegExp(searchTerm) + ")", 'gi');
      return text.replace(regex, '<span class="highlight">$1</span>');
    }
    
    // Helper function to escape regex special characters
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    // Handle cell clicks to open the assignment popup
    function handleCellClick(event) {
      var cell;
      
      // Check if this is a real event or if the cell was passed directly
      if (event && event.currentTarget) {
        // Normal event case
        cell = event.currentTarget;
      } else if (event && event.tagName === 'TD') {
        // Cell element was passed directly (weird bug case)
        cell = event;
      } else {
        console.error('[CELL_CLICK] Invalid event or cell:', event);
        return;
      }
      
      var therapistId = cell.dataset.therapistId;
      var day = cell.dataset.day;
      var timeBlock = cell.dataset.timeBlock;
      var timeSlot = day + "-" + timeBlock;
      
      console.log('[CELL_CLICK] Cell clicked:', { therapistId, day, timeBlock, timeSlot, cssClasses: cell.className });
      
      // Check if this is an N/A cell
      var isNA = cell.classList.contains('na');
      
      if (isNA) {
        // Handle N/A cell click - toggle N/A status
        var therapistName = getTherapistName(therapistId);
        if (confirm("Remove N/A status for " + therapistName + " on " + day + " " + timeBlock + "?")) {
          toggleNAStatus(Number(therapistId), day, timeBlock);
        }
        return;
      }
      
      // FIXED: Check actual assignment data instead of CSS classes
      var assignment = getAssignment(therapistId, day, timeBlock);
      console.log('[CELL_CLICK] Assignment data found:', assignment);
      
      // Route based on actual assignment data, not DOM classes
      if (assignment && assignment.class === "assigned") {
        if (assignment.isMultiTherapist) {
          // Multi-therapist assignment - open edit popup
          openMultiTherapistEditPopup(cell, timeSlot);
          return;
        } else {
          // Single therapist assignment - show routing popup
          showAssignedCellRoutingPopup(therapistId, day, timeBlock, timeSlot);
          return;
        }
      }
      
      // Store current selection for regular cells (RESTORED - needed by other functions)
      currentSelection = {
        therapistId: therapistId,
        day: day,
        timeBlock: timeBlock,
        cell: cell,
        timeSlot: timeSlot,
        allClients: null, // Will store the full client list for filtering
        selectedTherapistIds: [therapistId] // Start with current therapist selected
      };
        
      // Regular cell click - show client assignment popup
      var therapistName = getTherapistName(therapistId);
      document.getElementById("popupTitle").textContent = 
        "Select Client for " + therapistName + " on " + day + " " + timeBlock;
      
      // Populate client list
      populateClientList(therapistId);
      
      // Set up multi-therapist section
      setupMultiTherapistSection(therapistId, timeSlot);
      
      // Show or hide the clear button based on actual assignment data
      var hasAssignment = assignment && (assignment.class === "assigned" || assignment.class === "na");
      document.getElementById("clearAssignment").style.display = hasAssignment ? "block" : "none";
      
      // Show the popup
      document.getElementById("assignmentPopup").style.display = "flex";
    }
    
    // Populate the client list for selection
    function populateClientList(therapistId) {
      var clientList = document.getElementById("clientList");
      clientList.innerHTML = "";
      
      // Get travel sessions for this therapist
      var sortedSessions = sessionsData
        .filter(function(s) { return Number(s.therapistId) === Number(therapistId); })
        .sort(function(a, b) { return a.travelTime_minutes - b.travelTime_minutes; });
      
      // Create a unique list of clients with their distances
      var clientsWithDistance = [];
      var addedClientIds = new Set();
      
      sortedSessions.forEach(function(session) {
        if (!addedClientIds.has(session.clientId)) {
          var client = clientsData.find(function(c) { return Number(c.id) === Number(session.clientId); });
          if (client) {
            clientsWithDistance.push(Object.assign({}, client, {
              travelTime: session.travelTime_minutes,
              distance: session.distance_miles,
              distanceText: session.distance_text || formatDistance(session.distance_miles) + " mi",
              durationText: session.duration_text || session.travelTime_minutes + " mins"
            }));
            addedClientIds.add(session.clientId);
          }
        }
      });
      
      // Add remaining clients that don't have sessions
      clientsData.forEach(function(client) {
        if (!addedClientIds.has(client.id)) {
          clientsWithDistance.push(Object.assign({}, client, {
            travelTime: null,
            distance: null,
            distanceText: "Unknown",
            durationText: "Unknown"
          }));
        }
      });
      
      // Store the full client list for filtering
      currentSelection.allClients = clientsWithDistance;
      
      // Create client option elements
      createClientElements(clientsWithDistance);
      
      // Reset and focus the search input
      var popupSearchInput = document.getElementById("popupSearchInput");
      popupSearchInput.value = "";
      document.getElementById("clearPopupSearch").style.display = "none";
      
      // Focus the search input after a short delay (allows popup to render first)
      setTimeout(function() { popupSearchInput.focus(); }, 50);
    }
    
    // Helper function to format distance with 1 decimal place
    function formatDistance(distance) {
      if (distance === null || distance === undefined) return "Unknown";
      return parseFloat(distance).toFixed(1);
    }
    
    // Function to create client elements with improved distance formatting
    function createClientElements(clients) {
      var clientList = document.getElementById("clientList");
      clientList.innerHTML = "";
      
      if (clients.length === 0) {
        var noClients = document.createElement("div");
        noClients.className = "no-clients-message";
        noClients.textContent = "No clients match your search";
        clientList.appendChild(noClients);
        return;
      }
      
      clients.forEach(function(client) {
        var option = document.createElement("div");
        option.className = "client-option";
        option.dataset.clientId = client.id;
        
        var nameSpan = document.createElement("span");
        nameSpan.className = "client-name";
        nameSpan.textContent = client.name;
        
        var distanceSpan = document.createElement("span");
        distanceSpan.className = "client-distance";
        
        // Format the distance display text
        var distanceDisplay = "Unknown";
        if (client.distance !== null && client.distance !== undefined) {
          var formattedDistance = formatDistance(client.distance);
          var durationText = client.durationText || "Unknown time";
          distanceDisplay = formattedDistance + " mi, " + (client.travelTime || "?") + " mins";
        } else if (client.distanceText && client.distanceText !== "Unknown") {
          // Use the pre-formatted text if it exists and isn't "Unknown"
          distanceDisplay = client.distanceText + ", " + (client.durationText || "Unknown");
        }
        
        distanceSpan.textContent = distanceDisplay;
        
        option.appendChild(nameSpan);
        option.appendChild(distanceSpan);
        
        // Enhanced click handler for multi-therapist support
        option.addEventListener("click", function() { 
          handleClientSelection(client.id);
        });
        
        clientList.appendChild(option);
      });
    }
    
    /**
     * Show routing popup for assigned cells
     * @param {string|number} therapistId - Therapist ID
     * @param {string} day - Day (e.g., "Monday")
     * @param {string} timeBlock - Time block (e.g., "Morning")
     * @param {string} timeSlot - Time slot (e.g., "Monday-Morning")
     */
    function showAssignedCellRoutingPopup(therapistId, day, timeBlock, timeSlot) {
      console.log('[ROUTING_POPUP] Showing routing popup for assigned cell:', { therapistId, day, timeBlock, timeSlot });
      
      // Get the assignment details
      var assignment = assignmentsData.find(function(a) {
        return Number(a.therapistId) === Number(therapistId) && 
               a.timeSlot === timeSlot &&
               a.clientId !== "N/A" &&
               (a.scheduleType || "current") === currentScheduleType;
      });
      
      if (!assignment) {
        console.warn('[ROUTING_POPUP] No assignment found for this cell');
        return;
      }
      
      // Get client and therapist names
      var client = clientsData.find(function(c) { return Number(c.id) === Number(assignment.clientId); });
      var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
      var clientName = client ? client.name : 'Unknown Client';
      var therapistName = therapist ? therapist.name : 'Unknown Therapist';
      
      // Generate routing HTML
      var routingHTML = getClientToClientRoutingHTML(Object.assign({}, assignment, { clientName: clientName }), timeSlot);
      
      // Create popup content
      var popupHTML = '<div class="routing-popup-content" style="max-width: 500px; padding: 20px;">';
      popupHTML += '<div class="popup-header">';
      popupHTML += '<h3 style="margin: 0; color: #2e7d32;">📍 Current Assignment</h3>';
      popupHTML += '<button class="close-popup" onclick="closeRoutingPopup()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>';
      popupHTML += '</div>';
      
      // Assignment details
      popupHTML += '<div style="background-color: #f8f9fa; padding: 15px; border-radius: 6px; margin: 15px 0;">';
      popupHTML += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">';
      popupHTML += '<div><strong>Therapist:</strong> ' + therapistName + '</div>';
      popupHTML += '<div><strong>Client:</strong> ' + clientName + '</div>';
      popupHTML += '<div><strong>Day:</strong> ' + day + '</div>';
      popupHTML += '<div><strong>Time:</strong> ' + timeBlock + '</div>';
      
      // Assignment metadata
      if (assignment.assignmentType) {
        var typeText = assignment.assignmentType === 'playPals' ? 'Play Pals' : 'Regular';
        popupHTML += '<div><strong>Type:</strong> ' + typeText + '</div>';
      }
      
      if (assignment.assignmentStatus) {
        var statusIcon = assignment.assignmentStatus === 'red' ? '🔴' : 
                        assignment.assignmentStatus === 'orange' ? '🟠' : '🟢';
        popupHTML += '<div><strong>Status:</strong> ' + statusIcon + '</div>';
      }
      
      popupHTML += '</div>';
      popupHTML += '</div>';
      
      // Add routing section if available
      if (routingHTML) {
        popupHTML += routingHTML;
      } else {
        popupHTML += '<div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px; margin: 15px 0; color: #856404;">';
        popupHTML += '<h4 style="margin: 0 0 8px 0;">🚗 No Routing Available</h4>';
        popupHTML += '<p style="margin: 0;">Either this is the last time slot of the day, or client distance data is not available.</p>';
        popupHTML += '</div>';
      }
      
      // Action buttons
      popupHTML += '<div style="display: flex; gap: 10px; margin-top: 20px; justify-content: flex-end;">';
      popupHTML += '<button onclick="editAssignmentFromRouting(\'' + therapistId + '\', \'' + day + '\', \'' + timeBlock + '\')" ';
      popupHTML += 'style="padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">✏️ Edit Assignment</button>';
      popupHTML += '<button onclick="closeRoutingPopup()" ';
      popupHTML += 'style="padding: 8px 16px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>';
      popupHTML += '</div>';
      
      popupHTML += '</div>';
      
      // Create and show popup
      var existingPopup = document.getElementById('routingPopup');
      if (existingPopup) {
        existingPopup.remove();
      }
      
      var popup = document.createElement('div');
      popup.id = 'routingPopup';
      popup.className = 'popup-overlay';
      popup.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;';
      popup.innerHTML = '<div class="popup-content" style="background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-height: 90vh; overflow-y: auto;">' + popupHTML + '</div>';
      
      document.body.appendChild(popup);
    }
    
    /**
     * Close the routing popup
     */
    function closeRoutingPopup() {
      var popup = document.getElementById('routingPopup');
      if (popup) {
        popup.remove();
      }
    }
    
    /**
     * Edit assignment from routing popup
     */
    function editAssignmentFromRouting(therapistId, day, timeBlock) {
      // Close routing popup
      closeRoutingPopup();
      
      // Trigger the regular assignment popup by simulating a cell click on an open cell
      var timeSlot = day + "-" + timeBlock;
      
      currentSelection = {
        therapistId: therapistId,
        day: day,
        timeBlock: timeBlock,
        timeSlot: timeSlot,
        allClients: null,
        selectedTherapistIds: [therapistId]
      };
      
      // Show regular assignment popup
      var therapistName = getTherapistName(therapistId);
      document.getElementById("popupTitle").textContent = 
        "Edit Assignment for " + therapistName + " on " + day + " " + timeBlock;
      
      // Populate client list
      populateClientList(therapistId);
      
      // Set up multi-therapist section
      setupMultiTherapistSection(therapistId, timeSlot);
      
      // Show the clear button since this is an edit
      document.getElementById("clearAssignment").style.display = "block";
      
      // Show the popup
      document.getElementById("assignmentPopup").style.display = "flex";
    }

    /**
     * Handle client selection for both single and multi-therapist assignments
     */
    function handleClientSelection(clientId) {
      console.log('[CLIENT] Client selected:', clientId);
      
      // Update therapist distances if multi-therapist mode is enabled
      var enableMultiTherapist = document.getElementById('enableMultiTherapist');
      if (enableMultiTherapist && enableMultiTherapist.checked) {
        updateTherapistDistances(clientId);
      }
      
      // Store selected client
      currentSelection.selectedClientId = clientId;
      
      // Highlight selected client
      document.querySelectorAll('.client-option').forEach(function(option) {
        option.classList.remove('selected');
      });
      event.target.closest('.client-option').classList.add('selected');
      
      // Show the assign button
      document.getElementById("assignClientButton").style.display = "block";
      
      // Store selected client ID for when assign button is clicked
      currentSelection.selectedClientId = clientId;
      console.log("[CLIENT] Client selected:", clientId, "- waiting for assign button click");
    }

    // Clear an assignment
    async function clearAssignment(therapistId, timeSlot) {
      console.log("[TABLE] Clearing assignment for therapist " + therapistId + " at " + timeSlot + " in " + currentScheduleType + " schedule");
      
      try {
      // Find the assignment to clear in the current schedule
        var assignmentIndex = assignmentsData.findIndex(function(a) {
          return Number(a.therapistId) === Number(therapistId) && 
                 a.timeSlot === timeSlot &&
                 (a.scheduleType || "current") === currentScheduleType;
        });
      
        if (assignmentIndex === -1) {
          showStatusMessage("No assignment found to clear in " + currentScheduleType + " schedule", "error");
        return;
      }
      
        var assignment = assignmentsData[assignmentIndex];
        var clientId = assignment.clientId;
        
        // Get client and therapist names for display
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var clientName = client ? client.name : 'Unknown Client';
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
        // Show loading state
        var scheduleLabel = currentScheduleType === "current" ? "" : " from Future Schedule";
        showStatusMessage('Clearing assignment for ' + clientName + scheduleLabel + '...', 'success');
        
        // Call the backend API to delete the assignment (like map component)
        console.log('[TABLE] Calling backend API to clear assignment...');
        var result = await callBackendAPI('clearAssignment', {
          clientId: clientId,
          timeSlot: timeSlot,
          scheduleType: currentScheduleType
        });
        
        console.log('[TABLE] Backend API response:', result);
        
        if (result.success) {
          console.log('[TABLE] Assignment cleared: ' + result.deleted + ' records');
          
          // Remove the assignment from local data only after successful backend call
          assignmentsData.splice(assignmentIndex, 1);
          console.log("[TABLE] Removed assignment from local data successfully for " + currentScheduleType + " schedule");
          
          // Update the UI
        buildScheduleTable();
        
          // Show success message
          var scheduleText = currentScheduleType === "current" ? "" : " from Future Schedule";
          showStatusMessage("✅ Successfully cleared assignment for " + clientName + " from " + therapistName + scheduleText, "success");
          
        } else {
          throw new Error(result.error || 'Assignment clearing failed');
        }
        
      } catch (error) {
        console.error("[TABLE] Error in clearAssignment:", error);
        showStatusMessage("❌ Failed to clear assignment: " + error.message, "error");
      }
    }
    
    // N/A Management Functions
    
    /**
     * Set N/A status for a therapist at a specific time slot
     * @param {number} therapistId - The therapist ID
     * @param {string} day - The day (e.g., "Monday")
     * @param {string} timeBlock - The time block (e.g., "Morning")
     */
    async function setNAStatus(therapistId, day, timeBlock) {
      var timeSlot = day + "-" + timeBlock;
      
      try {
        // Get therapist name for display
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
        // Filter assignments by current schedule type
        var scheduleAssignments = assignmentsData.filter(function(a) {
          return (a.scheduleType || "current") === currentScheduleType;
        });
        
        // Check if already N/A in current schedule
        var existingNA = scheduleAssignments.find(function(a) {
          return a.timeSlot === timeSlot && 
          Number(a.therapistId) === Number(therapistId) && 
                 a.clientId === "N/A";
        });
        
        if (existingNA) {
          var scheduleLabel = currentScheduleType === "current" ? "" : " in Future Schedule";
          showStatusMessage("Time slot is already marked as N/A" + scheduleLabel, "error");
          return;
        }
        
        // Check if there's an existing client assignment in current schedule
        var existingAssignment = scheduleAssignments.find(function(a) {
          return a.timeSlot === timeSlot && 
          Number(a.therapistId) === Number(therapistId) && 
                 a.clientId !== "N/A";
        });
        
        if (existingAssignment) {
          // Get client name for confirmation
          var client = clientsData.find(function(c) { return Number(c.id) === Number(existingAssignment.clientId); });
          var clientName = client ? client.name : 'Unknown Client';
          
          var scheduleLabel = currentScheduleType === "current" ? "" : " in Future Schedule";
          if (!confirm("This will remove " + clientName + " from " + therapistName + " on " + day + " " + timeBlock + scheduleLabel + ". Continue?")) {
            return;
          }
        }
        
        // Show loading state
        var scheduleLabel = currentScheduleType === "current" ? "" : " in Future Schedule";
        showStatusMessage('Setting N/A status for ' + therapistName + scheduleLabel + '...', 'success');
        
        // Call the backend API to set N/A status
        console.log('[TABLE] Calling backend API to set N/A status...');
        var result = await callBackendAPI('setNAStatus', {
          therapistId: therapistId,
          day: day,
          timeBlock: timeBlock,
          scheduleType: currentScheduleType
        });
        
        console.log('[TABLE] Backend API response:', result);
        
        if (result.success) {
          console.log('[TABLE] N/A status set: ' + result.action);
          
          // Remove any existing client assignment from local data
          if (existingAssignment) {
            assignmentsData = assignmentsData.filter(function(a) {
              return !(a.timeSlot === timeSlot && 
                       Number(a.therapistId) === Number(therapistId) && 
                       a.clientId !== "N/A" &&
                       (a.scheduleType || "current") === currentScheduleType);
            });
          }
          
          // Add N/A assignment to local data only after successful backend call
          var naAssignment = {
          therapistId: Number(therapistId),
          clientId: "N/A",
          timeSlot: timeSlot,
            scheduleType: currentScheduleType,
            isNA: true,
            assignmentType: 'regular',
            assignmentStatus: 'red',
            startDate: '',
            notes: ''
        };
        
        assignmentsData.push(naAssignment);
          console.log('[TABLE] Added N/A assignment to local data for ' + currentScheduleType + ' schedule');
          console.log('[TABLE] N/A assignment data created:', naAssignment);
      
      // Update UI
        buildScheduleTable();
        
          // Show success message
          var scheduleText = currentScheduleType === "current" ? "" : " in Future Schedule";
          showStatusMessage("✅ Successfully marked " + therapistName + " as N/A for " + day + " " + timeBlock + scheduleText, 'success');
          
        } else {
          throw new Error(result.error || 'Setting N/A status failed');
        }
        
      } catch (error) {
        console.error("[TABLE] Error in setNAStatus:", error);
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        showStatusMessage("❌ Failed to set N/A status for " + therapistName + ": " + error.message, 'error');
      }
    }
    
    /**
     * Remove N/A status for a therapist at a specific time slot
     * @param {number} therapistId - The therapist ID
     * @param {string} day - The day (e.g., "Monday")
     * @param {string} timeBlock - The time block (e.g., "Morning")
     */
    async function removeNAStatus(therapistId, day, timeBlock) {
      var timeSlot = day + "-" + timeBlock;
      
      try {
        // Get therapist name for display
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
        // Find the N/A assignment to remove in current schedule
        var naAssignmentIndex = assignmentsData.findIndex(function(a) {
          var matches = a.timeSlot === timeSlot && 
                       Number(a.therapistId) === Number(therapistId) && 
                       (a.scheduleType || "current") === currentScheduleType;
          
          // Check both clientId and isNA flag for robustness
          return matches && (a.clientId === "N/A" || a.isNA);
        });
        
        if (naAssignmentIndex === -1) {
          var scheduleLabel = currentScheduleType === "current" ? "" : " in Future Schedule";
          showStatusMessage("No N/A status found to remove" + scheduleLabel, "error");
          return;
        }
        
        // Show loading state
        var scheduleLabel = currentScheduleType === "current" ? "" : " in Future Schedule";
        showStatusMessage('Removing N/A status for ' + therapistName + scheduleLabel + '...', 'success');
        
        // Call the backend API to remove N/A status
        console.log('[TABLE] Calling backend API to remove N/A status...');
        var result = await callBackendAPI('removeNAStatus', {
          therapistId: therapistId,
          day: day,
          timeBlock: timeBlock,
          scheduleType: currentScheduleType
        });
        
        console.log('[TABLE] Backend API response:', result);
        
        if (result.success) {
          console.log('[TABLE] N/A status removed: ' + result.deleted + ' records');
          
          // Remove N/A assignment from local data only after successful backend call
          assignmentsData.splice(naAssignmentIndex, 1);
          console.log("[TABLE] Removed N/A assignment from local data successfully for " + currentScheduleType + " schedule");
        
        // Update UI
        buildScheduleTable();
        
          // Show success message
          var scheduleText = currentScheduleType === "current" ? "" : " in Future Schedule";
          showStatusMessage("✅ Successfully removed N/A status for " + therapistName + " on " + day + " " + timeBlock + scheduleText, "success");
          
        } else {
          throw new Error(result.error || 'Removing N/A status failed');
        }
        
      } catch (error) {
        console.error("[TABLE] Error in removeNAStatus:", error);
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        showStatusMessage("❌ Failed to remove N/A status for " + therapistName + ": " + error.message, "error");
      }
    }
    
    /**
     * Toggle N/A status for a therapist at a specific time slot
     * @param {number} therapistId - The therapist ID
     * @param {string} day - The day (e.g., "Monday")
     * @param {string} timeBlock - The time block (e.g., "Morning")
     */
    async function toggleNAStatus(therapistId, day, timeBlock) {
      var timeSlot = day + "-" + timeBlock;
      
      // Check if currently N/A
      var existingNA = assignmentsData.find(function(a) {
        var matches = a.timeSlot === timeSlot && 
                     Number(a.therapistId) === Number(therapistId) && 
                     (a.scheduleType || "current") === currentScheduleType;
        
        // Check both clientId and isNA flag for robustness
        return matches && (a.clientId === "N/A" || a.isNA);
      });
      
      if (existingNA) {
        await removeNAStatus(therapistId, day, timeBlock);
      } else {
        await setNAStatus(therapistId, day, timeBlock);
      }
    }
    
    /**
     * Create session data for N/A assignments
     * @param {number} therapistId - The therapist ID
     * @param {string} timeSlot - The time slot (e.g., "Monday-Morning")
     */
    function createNASessionData(therapistId, timeSlot) {
      try {
        // Find therapist object
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        
        if (!therapist) {
          console.error("Cannot create N/A session: Therapist not found", therapistId);
          return null;
        }
        
        // Extract day and time period from timeSlot format (e.g., "Monday-Morning")
        var [day, timePeriod] = timeSlot.split('-');
        
        if (!day || !timePeriod) {
          console.error("Cannot create N/A session: Invalid timeSlot format", timeSlot);
          return null;
        }
        
        // Create N/A session data
        var sessionData = {
          therapistId: Number(therapistId),
          clientId: "N/A",
          therapist_name: therapist.name,
          client_name: "N/A",
          day: day,
          time: timePeriod,
          timeSlot: timeSlot,
          isNA: true,
          // N/A assignments don't have distance/travel data
          distance_miles: 0,
          travelTime_minutes: 0
        };
        
        console.log("Created N/A session data:", sessionData);
        return sessionData;
        
      } catch (error) {
        console.error("Error creating N/A session data:", error);
        return null;
      }
    }
    
    // Close the assignment popup
    function closePopup() {
      document.getElementById("assignmentPopup").style.display = "none";
      
      // Reset assignment controls to defaults
      document.getElementById("assignmentType").value = "regular";
      document.getElementById("assignmentStatus").value = "red";
      document.getElementById("startDate").value = "";
      document.getElementById("assignmentNotes").value = "";
      document.getElementById("startDateSection").style.display = "none";
      document.getElementById("assignmentTypeInfo").style.display = "none";
      document.getElementById("startDateWarning").style.display = "none";
      
      // Clear search and selection
      var popupSearchInput = document.getElementById("popupSearchInput");
      if (popupSearchInput) {
        popupSearchInput.value = "";
        document.getElementById("clearPopupSearch").style.display = "none";
      }
      
      // Clear any selected options
      var selectedOption = document.querySelector('.client-option.selected');
      if (selectedOption) {
        selectedOption.classList.remove('selected');
      }
      
      // Reset current selection
      currentSelection = {
        therapistId: null,
        day: null,
        timeBlock: null,
        cell: null,
        allClients: null
      };
    }
    
    // Show a status message
    function showStatusMessage(message, type) {
      var statusElement = document.getElementById("statusMessage");
      statusElement.textContent = message;
      statusElement.className = "status-message " + type;
      statusElement.style.display = "block";
      
      // Hide after 3 seconds
      setTimeout(function() {
        statusElement.style.display = "none";
      }, 3000);
    }
    
    // Helper function to populate filter dropdowns
    function populateFilters() {
      console.log('[FILTERS] Populating filter dropdowns...');
      console.log('[FILTERS] therapistsData available:', therapistsData.length);
      
      // Populate therapist filter
      var therapistFilter = document.getElementById("therapistFilter");
      therapistFilter.innerHTML = '<option value="">All Therapists</option>';
      
      if (therapistsData && therapistsData.length > 0) {
        console.log('[FILTERS] Adding therapist options...');
        therapistsData.forEach(function(therapist) {
          var option = document.createElement("option");
          option.value = therapist.id;
          option.textContent = therapist.name;
          therapistFilter.appendChild(option);
        });
        console.log('[FILTERS] Added', therapistsData.length, 'therapist options');
      }
      
      // Populate lead BCBA filter
      var leadFilter = document.getElementById("leadFilter");
      leadFilter.innerHTML = '<option value="">All Leads</option>';
      
      if (therapistsData && therapistsData.length > 0) {
        var leads = [...new Set(therapistsData.map(function(t) { return t.lead; }).filter(Boolean))];
        console.log('[FILTERS] Found leads:', leads);
        leads.sort().forEach(function(lead) {
          var option = document.createElement("option");
          option.value = lead;
          option.textContent = lead;
          leadFilter.appendChild(option);
        });
        console.log('[FILTERS] Added', leads.length, 'lead options');
      }
      
      console.log('[FILTERS] Filter population complete');
    }
    
    // Function to inform parent that we're ready to receive data
    function sendReadyMessage() {
      console.log("[INIT] sendReadyMessage called, checking initialization state...");
      
      // Prevent multiple initialization attempts
      if (dataInitialized) {
        console.log("[INIT] ✅ Data already initialized, skipping...");
        return;
      }
      
      if (initializationInProgress) {
        console.log("[INIT] ⚠️ Initialization already in progress, skipping...");
        return;
      }
      
      // Mark initialization as in progress
      initializationInProgress = true;
      console.log("Schedule table component is ready, loading data directly...");
      
      // Re-enable data loading to fix the null data issue
      loadTableDataFromAPI()
        .then(() => {
          console.log('[TABLE] Table initialization completed successfully!');
          dataInitialized = true;
          initializationInProgress = false;
        })
        .catch(error => {
          console.error('[TABLE] Failed to load table data:', error);
          showStatusMessage('❌ Failed to load initial data: ' + error.message, 'error');
          initializationInProgress = false;
          // Don't set dataInitialized to true on error, allow retry
        });
    }
    
    /**
     * HOTFIX: Fix swapped therapistId/timeSlot fields from backend
     * Backend returns: {therapistId: 'Friday-Morning', timeSlot: '10', clientId: '7'}
     * Should be: {therapistId: '10', timeSlot: 'Friday-Morning', clientId: '7'}
     */
    function fixAssignmentFieldMapping(assignmentsArray) {
      // The backend structure has been identified as:
      // { "10": { "Friday-Morning": { "7": {...} } } }
      // Where "10" is therapistId, "Friday-Morning" is timeSlot, "7" is clientId
      
      // But if assignments are already converted to array format and missing therapistId,
      // we can't fix them here. Return as-is.
      return assignmentsArray;
    }
    
    /**
     * Load data directly from API (like map component)
     */
    async function loadTableDataFromAPI() {
      console.log('[TABLE] Starting loadTableDataFromAPI...');
      
      // STABILITY FIX: Prevent multiple simultaneous data loads
      if (window.dataLoadingInProgress) {
        console.log('[TABLE] ⚠️ Data loading already in progress, skipping...');
        return;
      }
      
      window.dataLoadingInProgress = true;
      console.log('[TABLE] 🔒 Data loading lock acquired');
      
      try {
        // CACHE CHECK: Try to load from cache first
        var cachedData = loadDataFromCache();
        if (cachedData && cachedData.data.assignments && cachedData.data.assignments.length > 0) {
          console.log('[TABLE] 📦 Found valid cached data, restoring...');
          
          if (restoreDataFromCache(cachedData)) {
            // Update UI with cached data
            populateFilters();
            buildScheduleTable();
            
            // Show success message
            showStatusMessage(`✅ Data restored from cache: ${cachedData.counts.therapists} therapists, ${cachedData.counts.clients} clients, ${cachedData.counts.assignments} assignments`, 'success');
            
            // Set up data stability monitoring
            setupDataStabilityMonitor();
            
            console.log('[TABLE] ✅ Successfully loaded data from cache, skipping API call');
            return;
          } else {
            console.log('[TABLE] ⚠️ Cache restoration failed, proceeding with API call');
          }
        } else {
          console.log('[TABLE] 📭 No valid cache found, proceeding with API call');
        }
        // Test backend connectivity first
        console.log('[TABLE] Testing backend connectivity...');
        const connectivity = await testBackendConnectivity();
        
        if (!connectivity.success) {
          console.error('[TABLE] Backend connectivity failed:', connectivity.error);
          showStatusMessage('❌ Backend connectivity failed: ' + connectivity.error + '. Please check permissions: Open the app in incognito mode to reauthorize spreadsheet access.', 'error');
          
          // Don't throw error, just show warning and continue with empty data
          assignmentsData = [];
          therapistsData = [];
          clientsData = [];
          sessionsData = [];
          notesData = {};
          
          buildScheduleTable();
          return;
        }
        
        console.log('[TABLE] ✅ Backend connectivity confirmed, loading data...');
        
        // Test if backend functions are available (simplified)
        console.log('[TABLE] Testing backend function availability...');
        try {
          var testResult = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .testGrokConnectivity();
          });
          console.log('[TABLE] Backend function test result:', testResult);
        } catch (error) {
          console.error('[TABLE] Backend function test failed:', error);
        }
        
        // Show loading state
        console.log('[TABLE] Calling getMapData API...');
        
        // SIMPLIFIED: Use only Method 1 (doPost via makeDoPostRequest) with longer timeout
        var data = await Promise.race([
          callBackendAPI('getMapData'),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Data loading timeout after 30 seconds')), 30000)
          )
        ]);
        
        console.log('[TABLE-INIT] Received data from backend:', data);
        
        // Check if backend returned null or invalid data
        if (!data || data === null) {
          console.error('[TABLE-INIT] Backend returned null data, initializing with empty data');
          showStatusMessage('⚠️ Backend returned no data. Starting with empty schedule.', 'warning');
          
          // Initialize with empty data
          therapistsData = [];
          clientsData = [];
          sessionsData = [];
          assignmentsData = [];
          notesData = {};
          
          buildScheduleTable();
          return;
        }
        
        if (typeof data !== 'object') {
          console.error('[TABLE-INIT] Backend returned invalid data type:', typeof data);
          throw new Error('Backend returned invalid data type: ' + typeof data);
        }
        
        console.log('[TABLE] Received table data:', {
          therapists: data.therapists ? data.therapists.length : 0,
          clients: data.clients ? data.clients.length : 0,
          sessions: data.sessions ? data.sessions.length : 0,
          assignments: data.assignments ? data.assignments.length : 0,
          notes: data.notes ? Object.keys(data.notes).length : 0
        });
        
                  // Single debug log for assignment structure
          if (data.assignments && Object.keys(data.assignments).length > 0) {
            const firstKey = Object.keys(data.assignments)[0];
            console.log('[TABLE] Backend assignment structure - first key:', firstKey, 'value:', data.assignments[firstKey]);
          }
        
        // Update global variables directly
        if (data.therapists) {
          therapists = data.therapists;
          therapistsData = therapists;
          console.log('[TABLE] Loaded therapists:', therapists.length, therapists);
        }
        
        if (data.clients) {
          clients = data.clients;
          clientsData = clients;
          console.log('[TABLE] Loaded clients:', clients.length);
        }
        
        if (data.sessions) {
          sessions = data.sessions;
          sessionsData = sessions;
          console.log('[TABLE] Loaded sessions:', sessions.length);
        }
        
        if (data.assignments) {
          assignments = data.assignments;
          
          // Enhanced debugging for assignment data
          console.log('[TABLE] 🔍 ASSIGNMENT DEBUGGING START');
          console.log('[TABLE] Raw assignments from backend:', assignments);
          console.log('[TABLE] Type of assignments:', typeof assignments);
          console.log('[TABLE] Assignments keys:', Object.keys(assignments || {}));
          
          // Log sample assignment structure if available
          if (assignments && typeof assignments === 'object' && !Array.isArray(assignments)) {
            const firstKey = Object.keys(assignments)[0];
            if (firstKey) {
              console.log('[TABLE] Sample time slot data:', firstKey, assignments[firstKey]);
            }
          }
          
          // STABILITY FIX: Add data integrity check before conversion
          if (!assignments || typeof assignments !== 'object') {
            console.error('[TABLE] ❌ Assignments data integrity check failed:', {
              assignments: assignments,
              type: typeof assignments,
              isNull: assignments === null,
              isUndefined: assignments === undefined
            });
            assignmentsData = [];
          } else {
            // Convert assignments from object format to array format for table
            try {
              console.log('[TABLE] 🔄 Starting assignment conversion...');
              assignmentsData = convertAssignmentsToArray(assignments);
              console.log('[TABLE] ✅ Converted assignments to array format:', assignmentsData.length, 'assignments');
              
              // Verify conversion was successful
              if (assignmentsData && Array.isArray(assignmentsData) && assignmentsData.length > 0) {
                console.log('[TABLE] ✅ Assignment conversion verified successful');
                
                // Log first few converted assignments for verification
                console.log('[TABLE] First 3 converted assignments:');
                assignmentsData.slice(0, 3).forEach((assignment, index) => {
                  console.log(`[TABLE] Assignment ${index}:`, {
                    timeSlot: assignment.timeSlot,
                    therapistId: assignment.therapistId,
                    clientId: assignment.clientId,
                    scheduleType: assignment.scheduleType,
                    isMultiTherapist: assignment.isMultiTherapist
                  });
                });
              } else {
                console.error('[TABLE] ❌ Assignment conversion failed - result is invalid:', {
                  assignmentsData: assignmentsData,
                  type: typeof assignmentsData,
                  isArray: Array.isArray(assignmentsData),
                  length: assignmentsData ? assignmentsData.length : 'undefined'
                });
                assignmentsData = [];
              }
            } catch (conversionError) {
              console.error('[TABLE] ❌ Assignment conversion threw error:', conversionError);
              assignmentsData = [];
            }
          }
          console.log('[TABLE] 🔍 ASSIGNMENT DEBUGGING END');
          
          // Debug: Show structure of first few converted assignments
          if (assignmentsData.length > 0) {
            console.log('[TABLE] First few converted assignments:');
            assignmentsData.slice(0, 5).forEach(function(assignment, index) {
              console.log(`[TABLE] Assignment ${index}:`, {
                timeSlot: assignment.timeSlot,
                therapistId: assignment.therapistId + ' (' + typeof assignment.therapistId + ')',
                clientId: assignment.clientId + ' (' + typeof assignment.clientId + ')',
                scheduleType: assignment.scheduleType,
                isMultiTherapist: assignment.isMultiTherapist
              });
            });
          }
          
          // No field mapping fix needed
          console.log('[TABLE] Assignments ready:', assignmentsData.length);
        } else {
          console.warn('[TABLE] No assignments data received');
          assignmentsData = [];
          
          // No fallback - keep assignments empty if primary load fails
          console.log('[TABLE] ⚠️ No assignments data received - keeping empty');
        }
        
        if (data.notes) {
          notes = data.notes;
          notesData = notes;
          console.log('[TABLE] Loaded notes:', Object.keys(notes).length);
        }
        
        // Debug: Test getAssignment function
        if (therapistsData.length > 0) {
          var testTherapist = therapistsData[0];
          var testAssignment = getAssignment(testTherapist.id, 'Monday', 'Morning');
          console.log('[TABLE] Test assignment for', testTherapist.name, 'Monday Morning:', testAssignment);
        }
        
        // Update UI
        populateFilters();
        buildScheduleTable();
        
        console.log('[TABLE] Table data loading completed successfully');
        
        // CACHE SAVE: Save successfully loaded data to cache
        if (assignmentsData.length > 0) {
          console.log('[TABLE] 💾 Saving loaded data to cache...');
          saveDataToCache();
        }
        
        // STABILITY MONITOR: Set up data integrity monitoring with auto-recovery
        setupDataStabilityMonitor();
        
                  // Show success message with data counts
          var assignmentCount = assignmentsData.length;
          var therapistCount = therapistsData.length;
          var clientCount = clientsData.length;
          
          if (assignmentCount > 0) {
            showStatusMessage(`✅ Data loaded and stable: ${therapistCount} therapists, ${clientCount} clients, ${assignmentCount} assignments`, 'success');
            console.log('[TABLE] ✅ Data loading completed successfully and data is stable');
          } else {
            showStatusMessage(`⚠️ Data loaded but no assignments found. Check console for debugging info.`, 'warning');
            console.log('[TABLE] ⚠️ Data loaded but no assignments found');
          }
        
        // --- ADD THIS BLOCK ---
        if (data.clientDistances) {
          clientDistances = data.clientDistances;
          console.log('[TABLE] Loaded clientDistances:', clientDistances.length);
        } else {
          clientDistances = [];
          console.warn('[TABLE] No clientDistances in getMapData response');
        }
        
      } catch (error) {
        console.error('[TABLE] Failed to load table data:', error);
        showStatusMessage('Failed to load schedule data: ' + error.message, 'error');
        throw error;
      } finally {
        // STABILITY FIX: Release data loading lock
        window.dataLoadingInProgress = false;
        console.log('[TABLE] 🔓 Data loading lock released');
      }
    }
    
    /**
     * Sends a session update to the parent page
     * @param {string} action - "create", "update", or "delete"
     * @param {Object} session - The session data
     */
    function sendSessionUpdate(action, session) {
      try {
        // Validate required fields
        if (!session || !session.therapistId || !session.clientId) {
          console.error("Cannot send session update: Missing required fields", session);
          showStatusMessage("Error: Invalid session data", "error");
          return false;
        }
        
        // Validate action
        var validActions = ['created', 'updated', 'deleted'];
        if (!validActions.includes(action)) {
          console.error("Cannot send session update: Invalid action", action);
          showStatusMessage("Error: Invalid session action", "error");
          return false;
        }
        
        // Send message to parent (WixPageCode.js)
        window.parent.postMessage({
          type: 'sessionUpdate',
          action: action,
          source: 'schedule',
          session: session
        }, "*");
        
        console.log("Sent " + action + " session update to parent for T" + session.therapistId + "-C" + session.clientId);
        return true;
        
      } catch (error) {
        console.error("Error sending session update:", error);
        showStatusMessage("Error communicating with parent page", "error");
        return false;
      }
    }
    
    /**
     * Processes a session update received from the parent
     * @param {Object} data - The message data containing session and action
     */
    function handleSessionUpdate(data) {
      var { action, session } = data;
      
      if (!session || !session.therapistId || !session.clientId) {
        console.error("Received invalid session data:", session);
        return;
      }
      
      console.log("Received " + action + " session update for T" + session.therapistId + "-C" + session.clientId);
      
      // Get therapist and client IDs as numbers for consistency
      var therapistId = Number(session.therapistId);
      var clientId = Number(session.clientId);
      
      if (action === 'created' || action === 'updated') {
        // Check if this session already exists in our local data
        var existingIndex = sessionsData.findIndex(function(s) {
          return Number(s.therapistId) === therapistId && 
                 Number(s.clientId) === clientId;
        });
        
        if (existingIndex >= 0) {
          // Update existing session
          sessionsData[existingIndex] = session;
          console.log("Updated existing session in schedule table data");
        } else {
          // Add new session
          sessionsData.push(session);
          console.log("Added new session to schedule table data");
        }
        
        // Update relevant UI elements
        updateSessionDisplay(therapistId, clientId);
      }
      else if (action === 'deleted') {
        // Remove from local data
        sessionsData = sessionsData.filter(function(s) {
          return !(Number(s.therapistId) === therapistId && 
                   Number(s.clientId) === clientId);
        });
        console.log("Removed session from schedule table data");
        
        // Update relevant UI elements
        updateSessionDisplay(therapistId, clientId);
      }
    }

    /**
     * Updates UI elements to reflect session changes
     * @param {number} therapistId - The therapist ID
     * @param {number} clientId - The client ID
     */
    function updateSessionDisplay(therapistId, clientId) {
      // If the client popup is open and showing this therapist's clients, refresh it
      if (currentSelection.therapistId && 
          Number(currentSelection.therapistId) === therapistId &&
          document.getElementById("assignmentPopup").style.display === "flex") {
        
        console.log("Refreshing client popup due to session update");
        populateClientList(therapistId);
      }
      
      // Note: We don't need to rebuild the entire table for session updates
      // since session data primarily affects the client selection popup
      // The table structure itself is based on assignments, not sessions
    }
    
    // Helper function to create or update session data when assignment happens
    function createOrUpdateSessionForAssignment(therapistId, clientId, timeSlot) {
      try {
        // Validate input parameters
        if (!therapistId || !clientId || !timeSlot) {
          console.error("Cannot create session: Missing required parameters", { therapistId, clientId, timeSlot });
          return null;
        }
        
        // Find existing session data
        var existingSession = sessionsData.find(function(s) {
          return Number(s.therapistId) === Number(therapistId) && 
                 Number(s.clientId) === Number(clientId);
        });
        
        if (existingSession) {
          console.log("Using existing session data for assignment");
          return Object.assign({}, existingSession, {
            timeSlot: timeSlot,
            // Ensure it has the up-to-date fields
            therapistId: Number(therapistId),
            clientId: Number(clientId)
          });
        }
        
        // No existing session data, we need to create it
        console.log("Creating new session data for assignment");
        
        // Find therapist and client objects
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        
        if (!therapist || !client) {
          console.error("Cannot create session: Therapist or client not found", { therapistId, clientId });
          return null;
        }
        
        // Extract day and time period from timeSlot format (e.g., "Monday-Morning")
        var [day, timePeriod] = timeSlot.split('-');
        
        if (!day || !timePeriod) {
          console.error("Cannot create session: Invalid timeSlot format", timeSlot);
          return null;
        }
        
        // Create basic session data
        var sessionData = {
          therapistId: Number(therapistId),
          clientId: Number(clientId),
          therapist_name: therapist.name,
          client_name: client.name,
          day: day,
          time: timePeriod,
          timeSlot: timeSlot,
          // If we have distance/duration data, use it
          distance_miles: getDistanceBetween(therapist, client),
          travelTime_minutes: getTravelTimeBetween(therapist, client)
        };
        
        console.log("Created session data:", sessionData);
        return sessionData;
        
      } catch (error) {
        console.error("Error creating session data:", error);
        return null;
      }
    }
    
    // Helper to calculate distance between therapist and client
    function getDistanceBetween(therapist, client) {
      // First look for existing session data
      var existingSession = sessionsData.find(function(s) {
        return Number(s.therapistId) === Number(therapist.id) && 
               Number(s.clientId) === Number(client.id);
      });
      
      if (existingSession && existingSession.distance_miles) {
        return existingSession.distance_miles;
      }
      
      // If no session data, calculate using Haversine formula
      if (therapist.lat && therapist.lng && client.lat && client.lng) {
        var R = 3958.8; // Earth's radius in miles
        var dLat = (client.lat - therapist.lat) * Math.PI / 180;
        var dLon = (client.lng - therapist.lng) * Math.PI / 180;
        var a = 
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(therapist.lat * Math.PI / 180) * Math.cos(client.lat * Math.PI / 180) * 
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      
      // Default fallback
      return 5.0; // Default to 5 miles
    }
    
    // Helper to estimate travel time between therapist and client
    function getTravelTimeBetween(therapist, client) {
      // First look for existing session data
      var existingSession = sessionsData.find(function(s) {
        return Number(s.therapistId) === Number(therapist.id) && 
               Number(s.clientId) === Number(client.id);
      });
      
      if (existingSession && existingSession.travelTime_minutes) {
        return existingSession.travelTime_minutes;
      }
      
      // If no session data, estimate based on distance
      var distance = getDistanceBetween(therapist, client);
      return Math.round(distance * 3); // Roughly 3 minutes per mile
    }
    
    // Set up event listeners
    document.addEventListener('DOMContentLoaded', function() {
      console.log('[TABLE-INIT] Table DOMContentLoaded fired!');
      
      // REMOVED: Duplicate data loading that was causing race conditions
      // Data loading is now handled by sendReadyMessage() -> loadTableDataFromAPI()
      
      /* Commented out to prevent duplicate initialization
      callBackendAPI('getMapData').then(function(data) {
        console.log('[TABLE-INIT] Received data from backend:', data);
        
        // Check if backend returned null or invalid data
        if (!data || data === null) {
          console.error('[TABLE-INIT] Failed to load initial data: Backend returned null data');
          showStatusMessage('⚠️ Backend returned no data. Starting with empty schedule.', 'warning');
          
          // Initialize with empty data
          therapistsData = [];
          clientsData = [];
          sessionsData = [];
          assignmentsData = [];
          notesData = {};
          
          buildScheduleTable();
          return;
        }
        
        if (typeof data !== 'object') {
          console.error('[TABLE-INIT] Backend returned invalid data type:', typeof data);
          throw new Error('Backend returned invalid data type: ' + typeof data);
        }
        
        console.log('[TABLE] Received table data:', {
          therapists: data.therapists ? data.therapists.length : 0,
          clients: data.clients ? data.clients.length : 0,
          sessions: data.sessions ? data.sessions.length : 0,
          assignments: data.assignments ? data.assignments.length : 0,
          notes: data.notes ? Object.keys(data.notes).length : 0
        });
        
        // Populate global data stores
        if (data.therapists) {
          therapistsData = data.therapists;
          console.log('[TABLE-INIT] Loaded', therapistsData.length, 'therapists');
        }
        
        if (data.clients) {
          clientsData = data.clients;
          console.log('[TABLE-INIT] Loaded', clientsData.length, 'clients');
        }
        
        if (data.sessions) {
          sessionsData = data.sessions;
          console.log('[TABLE-INIT] Loaded', sessionsData.length, 'sessions');
        }
        
        if (data.assignments) {
          // DIAGNOSE THE ASSIGNMENT DATA STRUCTURE ISSUE
          console.log('[TABLE-INIT] 🚨 DEBUGGING ASSIGNMENT DATA STRUCTURE');
          console.log('[TABLE-INIT] Raw assignments from backend:', data.assignments);
          console.log('[TABLE-INIT] Assignment data type:', typeof data.assignments);
          

          
          // Convert assignments data to the correct format
          assignmentsData = [];
          
          if (typeof data.assignments === 'object' && !Array.isArray(data.assignments)) {
            console.log('[TABLE-INIT] Converting nested assignment object to array...');
            
            // Backend structure: { "clientId": { "timeSlot": { assignmentData } } }
            // BUT THE BACKEND IS RETURNING IT WRONG - clientId and timeSlot are swapped!
            Object.keys(data.assignments).forEach(function(backendClientId) {
              var clientAssignments = data.assignments[backendClientId];
              
              Object.keys(clientAssignments).forEach(function(backendTimeSlot) {
                var assignment = clientAssignments[backendTimeSlot];
                // 🚨 BACKEND BUG FIX: The backend has clientId and timeSlot swapped!
                // What backend calls "clientId" is actually the timeSlot  
                // What backend calls "timeSlot" is actually the clientId
                var actualTimeSlot = backendClientId;  // Backend "clientId" is actually timeSlot
                var actualClientId = backendTimeSlot;   // Backend "timeSlot" is actually clientId
                
                // Extract therapist ID(s) from the assignment data
                if (assignment.isMultiTherapist && assignment.therapistIds) {
                  // Multi-therapist assignment - create one record per therapist
                  assignment.therapistIds.forEach(function(therapistId) {
                    assignmentsData.push({
                      clientId: String(actualClientId),
                      therapistId: String(therapistId),
                      timeSlot: actualTimeSlot,
                      assignmentType: assignment.assignmentType || 'regular',
                      assignmentStatus: assignment.assignmentStatus || 'red',
                      startDate: assignment.startDate || '',
                      notes: assignment.notes || '',
                      scheduleType: assignment.scheduleType || 'current',
                      isMultiTherapist: true,
                      therapistIds: assignment.therapistIds,
                      therapistCount: assignment.therapistCount || assignment.therapistIds.length,
                      multiTherapistGroupId: assignment.multiTherapistGroupId // Preserve group ID from backend
                    });
                  });
                } else {
                  // Single therapist assignment
                  var therapistId = assignment.therapistId || assignment.therapistIds?.[0];
                  if (therapistId) {
                    assignmentsData.push({
                      clientId: String(actualClientId),
                      therapistId: String(therapistId),
                      timeSlot: actualTimeSlot,
                      assignmentType: assignment.assignmentType || 'regular',
                      assignmentStatus: assignment.assignmentStatus || 'red',
                      startDate: assignment.startDate || '',
                      notes: assignment.notes || '',
                      scheduleType: assignment.scheduleType || 'current',
                      isMultiTherapist: assignment.isMultiTherapist || false,
                      therapistIds: assignment.therapistIds || null,
                      therapistCount: assignment.therapistCount || 1
                    });
                  }
                }
              });
            });
          } else if (Array.isArray(data.assignments)) {
            assignmentsData = data.assignments;
            console.log('[TABLE-INIT] Using assignments array directly');
          }
          
                    console.log('[TABLE-INIT] Final assignments processed:', assignmentsData.length);
        }
        
        // Load notes data from backend
        loadTherapistNotes().then(function() {
          console.log('[TABLE-INIT] Notes loading completed, building table...');
          console.log('[TABLE-INIT] NotesData after loading:', notesData);
          
          // Build the table after notes are loaded
          buildScheduleTable();
          
          if (data.notes) {
            // Legacy notes data (should be empty if using new system)
            console.log('[TABLE-INIT] Legacy notes data found:', data.notes);
            console.log('[TABLE-INIT] Loaded', Object.keys(data.notes).length, 'legacy notes');
          }
        }).catch(function(error) {
          console.error('[TABLE-INIT] Error loading notes:', error);
        });
        
        // Populate filter dropdowns
        populateFilters();
        
        // Build the initial table (will be done after notes are loaded)
        // buildScheduleTable(); // Commented out - now done in loadTherapistNotes().then()
        
        console.log('[TABLE-INIT] Initialization complete');
        console.log('[TABLE-INIT] Final assignmentsData length:', assignmentsData.length);
      }).catch(function(error) {
        console.error('[TABLE-INIT] Failed to load initial data:', error);
        showStatusMessage('Failed to load schedule data: ' + error.message, 'error');
      });
      */ // End of commented out duplicate initialization
      
      // Close popup on clicking close button or cancel
      document.getElementById("closePopup").addEventListener("click", closePopup);
      document.getElementById("cancelAssignment").addEventListener("click", closePopup);
      document.getElementById("clearAssignment").addEventListener("click", function() { clearAssignment(currentSelection.therapistId, currentSelection.timeSlot); });
      
//      // Assign client button event handler
//      document.getElementById("assignClientButton").addEventListener("click", function() {
//        if (currentSelection.selectedClientId) {
//          assignClient(currentSelection.therapistId, currentSelection.selectedClientId, currentSelection.timeSlot);
//        }
//      });
      
      // Filter change events
      document.getElementById("therapistFilter").addEventListener("change", function() {
        buildScheduleTable();
        updateCopyButtonState(); // Update button when filters change
      });
      document.getElementById("leadFilter").addEventListener("change", function() {
        buildScheduleTable();
        updateCopyButtonState(); // Update button when filters change
      });
      
      // Select all checkbox event listener  
      document.getElementById("selectAllTherapists").addEventListener("change", function(event) {
        handleSelectAllChange(event);
      });
      
      // Search functionality
      var searchInput = document.getElementById("searchInput");
      var clearSearch = document.getElementById("clearSearch");
      
      // Add event listener for search input
      searchInput.addEventListener("input", function() {
        var newSearchTerm = this.value;
        
        // Simple optimization: only rebuild if search term actually changed
        if (newSearchTerm !== currentSearchTerm) {
          currentSearchTerm = newSearchTerm;
          buildScheduleTable();
          updateCopyButtonState(); // Update button when search changes
        }
        
        // Show/hide clear button based on input
        clearSearch.style.display = this.value ? "flex" : "none";
        
        // Notify parent page about search (useful for analytics or cross-component interactions)
        window.parent.postMessage({
          type: 'searchFilterApplied',
          searchTerm: this.value
        }, '*');
      });
      
      // Add event listener for clear button
      clearSearch.addEventListener("click", function() {
        searchInput.value = "";
        currentSearchTerm = "";
        searchInput.focus();
        buildScheduleTable();
        updateCopyButtonState(); // Update button when search is cleared
        this.style.display = "none";
        
        // Notify parent that search was cleared
        window.parent.postMessage({
          type: 'searchFilterApplied',
          searchTerm: ""
        }, '*');
      });
      
      // Initially hide the clear button
      clearSearch.style.display = "none";
      
      // Popup search functionality
      var popupSearchInput = document.getElementById("popupSearchInput");
      var clearPopupSearch = document.getElementById("clearPopupSearch");
      
      // Add event listener for popup search input
      popupSearchInput.addEventListener("input", function() {
        filterClientList(this.value);
        
        // Show/hide clear button based on input
        clearPopupSearch.style.display = this.value ? "flex" : "none";
        
        // Notify parent page about client popup search (for analytics or future enhancements)
        window.parent.postMessage({
          type: 'clientPopupSearchApplied',
          searchTerm: this.value,
          context: {
            therapistId: currentSelection.therapistId,
            day: currentSelection.day,
            timeBlock: currentSelection.timeBlock
          }
        }, '*');
      });
      
      // Add event listener for popup clear button
      clearPopupSearch.addEventListener("click", function() {
        popupSearchInput.value = "";
        popupSearchInput.focus();
        filterClientList("");
        this.style.display = "none";
        
        // Notify parent that client popup search was cleared
        window.parent.postMessage({
          type: 'clientPopupSearchApplied',
          searchTerm: "",
          context: {
            therapistId: currentSelection.therapistId,
            day: currentSelection.day,
            timeBlock: currentSelection.timeBlock
          }
        }, '*');
      });
      
      // Initially hide the popup clear button
      clearPopupSearch.style.display = "none";
      
      // Add keyboard navigation for client list
      document.addEventListener("keydown", function(e) {
        // Only process if popup is open
        if (document.getElementById("assignmentPopup").style.display !== "flex") return;
        
        // Get all visible client options
        var clientOptions = Array.from(document.querySelectorAll('.client-option'));
        if (clientOptions.length === 0) return;
        
        // Find the currently selected option (if any)
        var selectedOption = document.querySelector('.client-option.selected');
        var selectedIndex = selectedOption ? clientOptions.indexOf(selectedOption) : -1;
        
        if (e.key === "Escape") {
          closePopup();
        } else if (e.key === "ArrowDown") {
          e.preventDefault(); // Prevent scrolling
          
          // Move to next option or first if none selected
          if (selectedIndex < clientOptions.length - 1) {
            if (selectedOption) selectedOption.classList.remove('selected');
            selectedIndex++;
            clientOptions[selectedIndex].classList.add('selected');
            ensureVisible(clientOptions[selectedIndex]);
          } else if (selectedIndex === -1 && clientOptions.length > 0) {
            clientOptions[0].classList.add('selected');
            ensureVisible(clientOptions[0]);
          }
        } else if (e.key === "ArrowUp") {
          e.preventDefault(); // Prevent scrolling
          
          // Move to previous option
          if (selectedIndex > 0) {
            if (selectedOption) selectedOption.classList.remove('selected');
            selectedIndex--;
            clientOptions[selectedIndex].classList.add('selected');
            ensureVisible(clientOptions[selectedIndex]);
          }
        } else if (e.key === "Enter" && selectedOption) {
          e.preventDefault();
          // Trigger click on the selected option
          selectedOption.click();
        }
      });
      
      // Helper function to ensure an element is visible in scrollable container
      function ensureVisible(element) {
        var container = document.getElementById('clientList');
        var containerRect = container.getBoundingClientRect();
        var elementRect = element.getBoundingClientRect();
        
        if (elementRect.bottom > containerRect.bottom) {
          element.scrollIntoView(false); // Align to bottom
        } else if (elementRect.top < containerRect.top) {
          element.scrollIntoView(true); // Align to top
        }
      }
      
      // Send ready message
      sendReadyMessage();
      
      // Load client distances data for routing functionality
      console.log("[INIT] Loading client distances for routing functionality...");
      loadClientDistances().then(function(distances) {
        console.log("[INIT] Client distances loaded:", distances.length, "records");
      }).catch(function(error) {
        console.warn("[INIT] Failed to load client distances:", error);
      });
      
      // Initialize copy button text and state
      updateCopyButtonState();
      
      // Copy selected menu item click handler
      document.getElementById('copySelectedMenuItem').addEventListener('click', function(e) {
        if (this.classList.contains('disabled')) {
          e.preventDefault();
          e.stopPropagation();
          showStatusMessage("Please select therapists first", "error");
          return false;
        }
        // If not disabled, the onclick will fire normally
      });
      
      // Initially hide the popup clear button
      clearPopupSearch.style.display = "none";
      
      // Context menu functionality
      var contextMenu = document.getElementById("contextMenu");
      var setNAMenuItem = document.getElementById("setNAMenuItem");
      var removeNAMenuItem = document.getElementById("removeNAMenuItem");
      
      // Add right-click event listener to the document
      document.addEventListener("contextmenu", function(e) {
        var cell = e.target.closest('td[data-therapist-id]');
        
        // Only show context menu for schedule cells
        if (!cell || !cell.dataset.therapistId || !cell.dataset.day || !cell.dataset.timeBlock) {
          hideContextMenu();
          return;
        }
        
        e.preventDefault();
        
        var isNA = cell.classList.contains('na');
        var isOpen = cell.classList.contains('open');
        var isAssigned = cell.classList.contains('assigned');
        
        // Only show context menu for open, assigned, or N/A cells
        if (!isOpen && !isAssigned && !isNA) {
          hideContextMenu();
          return;
        }
        
        contextMenuTarget = cell;
        
        console.log('[CONTEXT] Right-click on cell:', { 
          therapistId: cell.dataset.therapistId, 
          day: cell.dataset.day, 
          timeBlock: cell.dataset.timeBlock,
          isNA: isNA,
          isOpen: isOpen, 
          isAssigned: isAssigned,
          scheduleType: currentScheduleType
        });
        
        // Get assignment details for assigned cells in current schedule
        var currentAssignment = null;
        if (isAssigned) {
          var timeSlot = cell.dataset.day + "-" + cell.dataset.timeBlock;
          currentAssignment = assignmentsData.find(function(a) {
            return Number(a.therapistId) === Number(cell.dataset.therapistId) && 
                   a.timeSlot === timeSlot && 
                   a.clientId !== "N/A" &&
                   (a.scheduleType || "current") === currentScheduleType;
          });
          
          console.log('[CONTEXT] Found assignment:', currentAssignment);
        }
        
        // Show/hide menu items based on cell state
        var assignmentDivider = document.getElementById("assignmentDivider");
        var changeStatusMenuItem = document.getElementById("changeStatusMenuItem");
        var changeTypeMenuItem = document.getElementById("changeTypeMenuItem");
        var editNotesMenuItem = document.getElementById("editNotesMenuItem");
        var statusIndicator = changeStatusMenuItem.querySelector('.status-indicator');
        
        if (isNA) {
          // N/A cell - only show N/A options
          setNAMenuItem.style.display = "none";
          removeNAMenuItem.style.display = "block";
          assignmentDivider.style.display = "none";
          changeStatusMenuItem.style.display = "none";
          changeTypeMenuItem.style.display = "none";
          editNotesMenuItem.style.display = "none";
        } else if (isAssigned && currentAssignment) {
          // Assigned cell with found assignment - show all options
          setNAMenuItem.style.display = "block";
          removeNAMenuItem.style.display = "none";
          assignmentDivider.style.display = "block";
          changeStatusMenuItem.style.display = "block";
          changeTypeMenuItem.style.display = "block";
          editNotesMenuItem.style.display = "block";
          
          // Update status indicator color
          var assignmentStatus = currentAssignment.assignmentStatus || 'red';
          statusIndicator.className = 'status-indicator ' + assignmentStatus;
          
          console.log('[CONTEXT] Showing assignment options for status:', assignmentStatus);
        } else if (isAssigned && !currentAssignment) {
          // Assigned cell but no assignment found - this shouldn't happen, but handle gracefully
          console.warn('[CONTEXT] Assigned cell but no assignment found in current schedule');
          setNAMenuItem.style.display = "block";
          removeNAMenuItem.style.display = "none";
          assignmentDivider.style.display = "none";
          changeStatusMenuItem.style.display = "none";
          changeTypeMenuItem.style.display = "none";
          editNotesMenuItem.style.display = "none";
        } else {
          // Open cell - only show mark as N/A option
          setNAMenuItem.style.display = "block";
          removeNAMenuItem.style.display = "none";
          assignmentDivider.style.display = "none";
          changeStatusMenuItem.style.display = "none";
          changeTypeMenuItem.style.display = "none";
          editNotesMenuItem.style.display = "none";
        }
        
        // Position and show context menu
        contextMenu.style.left = e.pageX + "px";
        contextMenu.style.top = e.pageY + "px";
        contextMenu.style.display = "block";
        
        console.log('[CONTEXT] Context menu shown with options visible');
      });
      
      // Hide context menu when clicking elsewhere
      document.addEventListener("click", function(e) {
        if (!contextMenu.contains(e.target)) {
          hideContextMenu();
        }
      });
      
      // Context menu item event listeners
      setNAMenuItem.addEventListener("click", function() {
        if (contextMenuTarget) {
          var therapistId = contextMenuTarget.dataset.therapistId;
          var day = contextMenuTarget.dataset.day;
          var timeBlock = contextMenuTarget.dataset.timeBlock;
          
          setNAStatus(Number(therapistId), day, timeBlock);
          hideContextMenu();
        }
      });
      
      removeNAMenuItem.addEventListener("click", function() {
        if (contextMenuTarget) {
          var therapistId = contextMenuTarget.dataset.therapistId;
          var day = contextMenuTarget.dataset.day;
          var timeBlock = contextMenuTarget.dataset.timeBlock;
          
          removeNAStatus(Number(therapistId), day, timeBlock);
          hideContextMenu();
        }
      });
      
      // Function to hide context menu
      function hideContextMenu() {
        contextMenu.style.display = "none";
        contextMenuTarget = null;
      }
      
      // Add keyboard navigation for client list
      
      // Initially hide the popup clear button
      clearPopupSearch.style.display = "none";
      
      // Assignment controls event listeners
      var assignmentType = document.getElementById("assignmentType");
      var assignmentStatus = document.getElementById("assignmentStatus");
      var startDateSection = document.getElementById("startDateSection");
      var assignmentTypeInfo = document.getElementById("assignmentTypeInfo");
      var startDateWarning = document.getElementById("startDateWarning");
      
      // Show/hide Play Pals info when assignment type changes
      assignmentType.addEventListener("change", function() {
        if (this.value === "playPals") {
          assignmentTypeInfo.style.display = "block";
        } else {
          assignmentTypeInfo.style.display = "none";
        }
      });
      
      // Show/hide start date field and warning when status changes
      assignmentStatus.addEventListener("change", function() {
        if (this.value === "orange") {
          startDateSection.style.display = "block";
          startDateWarning.style.display = "block";
        } else {
          startDateSection.style.display = "none";
          startDateWarning.style.display = "none";
        }
      });
      
      // Clear warning when start date is entered
      document.getElementById("startDate").addEventListener("change", function() {
        if (this.value) {
          startDateWarning.style.display = "none";
        }
      });
      
      // Clear warning when notes mention start date
      document.getElementById("assignmentNotes").addEventListener("input", function() {
        if (this.value.toLowerCase().includes('start date')) {
          startDateWarning.style.display = "none";
        }
      });
      
      // Assignment management menu items event listeners
      var changeStatusMenuItem = document.getElementById("changeStatusMenuItem");
      var changeTypeMenuItem = document.getElementById("changeTypeMenuItem");
      var editNotesMenuItem = document.getElementById("editNotesMenuItem");
      
      if (changeStatusMenuItem) {
        changeStatusMenuItem.addEventListener("click", function() {
          if (contextMenuTarget) {
            openAssignmentEditPopup('status');
            hideContextMenu();
          }
        });
      }
      
      if (changeTypeMenuItem) {
        changeTypeMenuItem.addEventListener("click", function() {
          if (contextMenuTarget) {
            openAssignmentEditPopup('type');
            hideContextMenu();
          }
        });
      }
      
      if (editNotesMenuItem) {
        editNotesMenuItem.addEventListener("click", function() {
          if (contextMenuTarget) {
            openAssignmentEditPopup('notes');
            hideContextMenu();
          }
        });
      }
      
      // Assignment edit popup controls
      var assignmentEditPopup = document.getElementById("assignmentEditPopup");
      var closeEditPopup = document.getElementById("closeEditPopup");
      var cancelAssignmentEdit = document.getElementById("cancelAssignmentEdit");
      var saveAssignmentChanges = document.getElementById("saveAssignmentChanges");
      
      if (closeEditPopup) {
        closeEditPopup.addEventListener("click", function() {
          assignmentEditPopup.style.display = "none";
        });
      }
      
      if (cancelAssignmentEdit) {
        cancelAssignmentEdit.addEventListener("click", function() {
          assignmentEditPopup.style.display = "none";
        });
      }
      
      if (saveAssignmentChanges) {
        saveAssignmentChanges.addEventListener("click", function() {
          saveAssignmentDetails();
        });
      }
      
      // Edit popup assignment controls
      var editAssignmentStatus = document.getElementById("editAssignmentStatus");
      var editStartDateSection = document.getElementById("editStartDateSection");
      var editStartDateWarning = document.getElementById("editStartDateWarning");
      
      if (editAssignmentStatus) {
        editAssignmentStatus.addEventListener("change", function() {
          if (this.value === "orange") {
            editStartDateSection.style.display = "block";
            editStartDateWarning.style.display = "block";
          } else {
            editStartDateSection.style.display = "none";
            editStartDateWarning.style.display = "none";
          }
        });
      }
      
      var editStartDate = document.getElementById("editStartDate");
      if (editStartDate) {
        editStartDate.addEventListener("change", function() {
          if (this.value) {
            editStartDateWarning.style.display = "none";
          }
        });
      }
      
      var editAssignmentNotes = document.getElementById("editAssignmentNotes");
      if (editAssignmentNotes) {
        editAssignmentNotes.addEventListener("input", function() {
          if (this.value.toLowerCase().includes('start date')) {
            editStartDateWarning.style.display = "none";
          }
        });
      }
      
      // Context menu functionality
      
      // Add event handler for assign client button
//      document.getElementById("assignClientButton").addEventListener("click", function() {
//        if (currentSelection.selectedClientId) {
//          assignClient(currentSelection.therapistId, currentSelection.selectedClientId, currentSelection.timeSlot);
//        } else {
//          showStatusMessage("Please select a client first", "error");
//        }
//      });
      
      // Basic popup controls for assignment popup - THESE WERE MISSING!
      var closePopup = document.getElementById("closePopup");
      var cancelAssignment = document.getElementById("cancelAssignment");
      var clearAssignmentBtn = document.getElementById("clearAssignment");
      var assignClientButton = document.getElementById("assignClientButton");
      
      if (closePopup) {
        closePopup.addEventListener("click", function() {
          document.getElementById("assignmentPopup").style.display = "none";
        });
      }
      
      if (cancelAssignment) {
        cancelAssignment.addEventListener("click", function() {
          document.getElementById("assignmentPopup").style.display = "none";
        });
      }
      
      if (clearAssignmentBtn) {
        clearAssignmentBtn.addEventListener("click", function() {
          if (currentSelection.therapistId && currentSelection.timeSlot) {
            clearAssignment(currentSelection.therapistId, currentSelection.timeSlot);
          }
        });
      }
      
      // Fix the main assignClientButton handler - this was the missing piece!
      if (assignClientButton) {
        assignClientButton.addEventListener("click", function() {
          if (currentSelection.selectedClientId && currentSelection.selectedTherapistIds && currentSelection.timeSlot) {
            // Check if multiple therapists are selected
            if (currentSelection.selectedTherapistIds.length > 1) {
              // Multi-therapist assignment
              createMultiTherapistAssignment(currentSelection.selectedTherapistIds, currentSelection.selectedClientId, currentSelection.timeSlot);
            } else {
              // Single therapist assignment
              assignClient(currentSelection.therapistId, currentSelection.selectedClientId, currentSelection.timeSlot);
            }
          } else {
            showStatusMessage("Please select a client first", "error");
          }
        });
      }
      
      // Multi-therapist edit popup controls
      var closeMultiEditPopup = document.getElementById("closeMultiEditPopup");
      var cancelMultiTherapistEdit = document.getElementById("cancelMultiTherapistEdit");
      var saveMultiTherapistChanges = document.getElementById("saveMultiTherapistChanges");
      var clearMultiTherapistAssignment = document.getElementById("clearMultiTherapistAssignment");
      
      if (closeMultiEditPopup) {
        closeMultiEditPopup.addEventListener("click", function() {
          document.getElementById("multiTherapistEditPopup").style.display = "none";
        });
      }
      
      if (cancelMultiTherapistEdit) {
        cancelMultiTherapistEdit.addEventListener("click", function() {
          document.getElementById("multiTherapistEditPopup").style.display = "none";
        });
      }
      
      if (saveMultiTherapistChanges) {
        saveMultiTherapistChanges.addEventListener("click", function() {
          saveMultiTherapistChanges();
        });
      }
      
      if (clearMultiTherapistAssignment) {
        clearMultiTherapistAssignment.addEventListener("click", function() {
          clearMultiTherapistAssignmentConfirm();
        });
      }
      
      // Multi-edit popup assignment controls
      var multiEditAssignmentStatus = document.getElementById("multiEditAssignmentStatus");
      var multiEditStartDateSection = document.getElementById("multiEditStartDateSection");
      var multiEditStartDateWarning = document.getElementById("multiEditStartDateWarning");
      
      if (multiEditAssignmentStatus) {
        multiEditAssignmentStatus.addEventListener("change", function() {
          if (this.value === "orange") {
            multiEditStartDateSection.style.display = "block";
            multiEditStartDateWarning.style.display = "block";
          } else {
            multiEditStartDateSection.style.display = "none";
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
      
      var multiEditStartDate = document.getElementById("multiEditStartDate");
      if (multiEditStartDate) {
        multiEditStartDate.addEventListener("change", function() {
          if (this.value) {
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
      
      var multiEditAssignmentNotes = document.getElementById("multiEditAssignmentNotes");
      if (multiEditAssignmentNotes) {
        multiEditAssignmentNotes.addEventListener("input", function() {
          if (this.value.toLowerCase().includes('start date')) {
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
    });
    
    // Send ready message when the page loads (in case DOMContentLoaded already fired)
    if (document.readyState === "complete" || document.readyState === "interactive") {
      console.log("Page already loaded, sending scheduleReady message now");
      sendReadyMessage();
      
      // Load client distances data for routing functionality
      console.log("[INIT] Loading client distances for routing functionality...");
      loadClientDistances().then(function(distances) {
        console.log("[INIT] Client distances loaded:", distances.length, "records");
      }).catch(function(error) {
        console.warn("[INIT] Failed to load client distances:", error);
      });
    }
    
    // Function to start editing a note
    function startNoteEditing(cell) {
      // Don't start editing if already editing
      if (cell.contentEditable === 'true') {
        return;
      }
      
      console.log('[NOTES] Starting note editing for:', cell.dataset);
      
      // Store original text for cancellation
      cell.dataset.originalText = cell.textContent;
      
      // Make cell editable
      cell.contentEditable = true;
      cell.focus();
      
      // Select all text
      if (cell.textContent) {
        var range = document.createRange();
        range.selectNodeContents(cell);
        var selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      }
      
      // Add editing visual feedback
      cell.classList.add('editing');
      cell.style.backgroundColor = '#fff3cd';
      cell.style.border = '2px solid #ffc107';
    }
    
    // Function to finish editing a note
    function finishNoteEditing(cell, save) {
      // Don't finish if not editing
      if (cell.contentEditable !== 'true') {
        return;
      }
      
      console.log('[NOTES] Finishing note editing, save:', save);
      console.log('[NOTES] Cell dataset:', cell.dataset);
      console.log('[NOTES] Cell dataset values:', {
        therapistId: cell.dataset.therapistId,
        timeBlock: cell.dataset.timeBlock,
        scheduleType: cell.dataset.scheduleType,
        originalText: cell.dataset.originalText
      });
      
      var newText = cell.textContent.trim();
      var originalText = cell.dataset.originalText || '';
      
      if (save && newText !== originalText) {
        // Save the note for this specific time block
        console.log('[NOTES] Calling saveNote with:', {
          therapistId: cell.dataset.therapistId,
          timeBlock: cell.dataset.timeBlock,
          scheduleType: cell.dataset.scheduleType,
          newText: newText
        });
        saveNote(cell.dataset.therapistId, cell.dataset.timeBlock, cell.dataset.scheduleType, newText);
      } else if (!save) {
        // Cancel - restore original text
        cell.textContent = originalText;
      }
      
      // Remove editing state
      cell.contentEditable = false;
      cell.classList.remove('editing');
      cell.style.backgroundColor = '';
      cell.style.border = '';
      
      // Clean up
      delete cell.dataset.originalText;
    }
    
    // Function to load therapist notes from backend
    async function loadTherapistNotes() {
      try {
        console.log('[NOTES] Loading therapist notes from backend...');
        
        var result = await callBackendAPI('getTherapistNotes');
        
        console.log('[NOTES] Backend notes response:', result);
        
        if (result.success) {
          // Clear existing notes data
          notesData = {};
          
          // Process notes data
          if (result.notes && Array.isArray(result.notes)) {
            result.notes.forEach(function(note) {
              // Ensure consistent data types for key generation
              var therapistId = String(note.therapistId);
              var timeBlock = String(note.timeBlock);
              var scheduleType = String(note.scheduleType || 'current');
              
              // Create time-block-specific note key: therapistId-timeBlock-scheduleType
              var noteKey = therapistId + "-" + timeBlock + "-" + scheduleType;
              notesData[noteKey] = note.noteText;
              
              console.log('[NOTES] Processing note:', {
                original: note,
                noteKey: noteKey,
                noteText: note.noteText
              });
            });
          }
          
          console.log('[NOTES] Loaded', Object.keys(notesData).length, 'notes');
          console.log('[NOTES] NotesData object:', notesData);
          console.log('[NOTES] All note keys:', Object.keys(notesData));
        } else {
          console.warn('[NOTES] Failed to load notes:', result.error || 'Unknown error');
        }
        
      } catch (error) {
        console.error('[NOTES] Error loading notes:', error);
      }
    }
    
    // Function to save a note via backend API
    async function saveNote(therapistId, timeBlock, scheduleType, noteText) {
      try {
        console.log('[NOTES] Saving note for therapist', therapistId, 'timeBlock', timeBlock, 'schedule', scheduleType);
        
        // Validate parameters before sending
        if (!therapistId || !timeBlock || !scheduleType) {
          console.error('[NOTES] Missing required parameters:', {
            therapistId: therapistId,
            timeBlock: timeBlock,
            scheduleType: scheduleType
          });
          throw new Error('Missing required parameters: therapistId, timeBlock, or scheduleType');
        }
        
        // Show loading state
        showStatusMessage('Saving note...', 'info');
        
        // Prepare parameters for backend
        var params = {
          therapistId: String(therapistId),
          timeBlock: String(timeBlock),
          scheduleType: String(scheduleType),
          noteText: String(noteText || '')
        };
        
        // Call backend API
        var result = await callBackendAPI('saveTherapistNote', params);
        
        console.log('[NOTES] Save result:', result.success ? 'SUCCESS' : 'FAILED');
        
        if (result.success) {
          // Update local data with time-block-specific key generation
          var localNoteKey = String(therapistId) + "-" + String(timeBlock) + "-" + String(scheduleType);
          notesData[localNoteKey] = noteText;
          
          console.log('[NOTES] Updated local notesData:', {
            localNoteKey: localNoteKey,
            noteText: noteText,
            allKeys: Object.keys(notesData)
          });
          
          // Show success message
          var therapistName = getTherapistName(therapistId);
          var scheduleLabel = scheduleType === "current" ? "" : " (Future Schedule)";
          showStatusMessage("✅ Note saved for " + therapistName + " - " + timeBlock + scheduleLabel, "success");
          
        } else {
          throw new Error(result.error || 'Failed to save note');
        }
        
      } catch (error) {
        console.error('[NOTES] Error saving note:', error);
        showStatusMessage("❌ Failed to save note: " + error.message, "error");
        
        // Revert the UI on error
        buildScheduleTable();
      }
    }
    
    // Function to clear a specific assignment directly from the table
    async function clearSpecificAssignment(therapistId, day, timeBlock, clientId, showConfirm = true) {
      var timeSlot = day + "-" + timeBlock;
      
      try {
        // Get client and therapist names for display
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var clientName = client ? client.name : 'Unknown Client';
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
      // Confirm before removing if showConfirm is true
        if (showConfirm && !confirm("Remove the assignment for " + therapistName + " → " + clientName + " on " + day + " " + timeBlock + "?")) {
        return;
      }
      
        // Show loading state
        showStatusMessage('Clearing assignment for ' + clientName + '...', 'success');
        
        // Call the backend API to delete the assignment (like map component)
        console.log('[TABLE] Calling backend API to clear specific assignment...');
        var result = await callBackendAPI('clearAssignment', {
          clientId: clientId,
          timeSlot: timeSlot
        });
        
        console.log('[TABLE] Backend API response:', result);
        
        if (result.success) {
          console.log('[TABLE] Assignment cleared: ' + result.deleted + ' records');
          
          // Update local data only after successful backend call
          assignmentsData = assignmentsData.filter(function(a) {
            return !(a.timeSlot === timeSlot && Number(a.therapistId) === Number(therapistId));
          });
          console.log('[TABLE] Removed assignment from local data');
          
          // Update UI by rebuilding the table
      buildScheduleTable();
      
        // Show success message
          showStatusMessage("✅ Cleared assignment for " + clientName + " from " + therapistName + " on " + day + " " + timeBlock, "success");
          
        } else {
          throw new Error(result.error || 'Assignment clearing failed');
        }
        
      } catch (error) {
        console.error("[TABLE] Error in clearSpecificAssignment:", error);
        
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var clientName = client ? client.name : 'Unknown Client';
        showStatusMessage("❌ Failed to clear assignment for " + clientName + ": " + error.message, "error");
      }
    }
    
    // Drag and Drop handler functions
    function handleDragStart(e) {
      console.log("[DRAG] Drag started on element:", this);
      console.log("[DRAG] Element dataset:", this.dataset);
      
      // Add the dragging class to style the element
      this.classList.add("dragging");
      
      // Get complete assignment metadata from the source
      var sourceTimeSlot = this.dataset.day + "-" + this.dataset.timeBlock;
      var sourceAssignment = null;
      
      // Find the source assignment to get complete metadata
      if (this.dataset.clientId && this.dataset.clientId !== "N/A") {
        sourceAssignment = assignmentsData.find(function(a) {
          return Number(a.therapistId) === Number(this.dataset.therapistId) && 
                 a.timeSlot === sourceTimeSlot && 
                 Number(a.clientId) === Number(this.dataset.clientId) &&
                 (a.scheduleType || "current") === currentScheduleType;
        }.bind(this));
      } else if (this.dataset.clientId === "N/A") {
        // For N/A assignments, find by therapist and timeSlot
        sourceAssignment = assignmentsData.find(function(a) {
          return Number(a.therapistId) === Number(this.dataset.therapistId) && 
                 a.timeSlot === sourceTimeSlot && 
                 a.clientId === "N/A" &&
                 (a.scheduleType || "current") === currentScheduleType;
        }.bind(this));
      }
      
      console.log("[DRAG] Source assignment found:", sourceAssignment);
      
      // Store comprehensive data about what's being dragged
      var dragData = {
        clientId: this.dataset.clientId,
        therapistId: this.dataset.therapistId,
        day: this.dataset.day,
        timeBlock: this.dataset.timeBlock,
        timeSlot: sourceTimeSlot,
        clientName: getClientName(this.dataset.clientId),
        scheduleType: currentScheduleType,
        
        // Copy complete assignment metadata if available
        assignmentType: sourceAssignment ? (sourceAssignment.assignmentType || 'regular') : 'regular',
        assignmentStatus: sourceAssignment ? (sourceAssignment.assignmentStatus || 'red') : 'red',
        startDate: sourceAssignment ? (sourceAssignment.startDate || '') : '',
        notes: sourceAssignment ? (sourceAssignment.notes || '') : '',
        
        // Multi-therapist metadata
        isMultiTherapist: sourceAssignment ? (sourceAssignment.isMultiTherapist || false) : false,
        therapistIds: sourceAssignment ? (sourceAssignment.therapistIds || [this.dataset.therapistId]) : [this.dataset.therapistId],
        therapistCount: sourceAssignment ? (sourceAssignment.therapistCount || 1) : 1,
        multiTherapistGroupId: sourceAssignment ? sourceAssignment.multiTherapistGroupId : null
      };
      
      console.log("[DRAG] Complete drag data with metadata:", dragData);
      
      // Store the source cell info for analytics
      currentDragSource = {
        therapistId: this.dataset.therapistId,
        day: this.dataset.day,
        timeBlock: this.dataset.timeBlock,
        assignment: sourceAssignment
      };
      
      e.dataTransfer.setData("text/plain", JSON.stringify(dragData));
      
      // Always set copy mode
      e.dataTransfer.effectAllowed = "copy";
      
      // Show the static tooltip with assignment info
      var tooltip = document.getElementById("dragTooltip");
      if (tooltip) {
        var tooltipText = "Copy: " + dragData.clientName;
        if (dragData.assignmentType === 'playPals') {
          tooltipText += " (Play Pals)";
        }
        if (dragData.isMultiTherapist) {
          tooltipText += " (Multi-Therapist)";
        }
        tooltip.textContent = tooltipText;
        tooltip.style.display = "block";
        
        // Position it near the cursor
        tooltip.style.left = (e.clientX + 10) + "px";
        tooltip.style.top = (e.clientY + 10) + "px";
      }
    }
    
    function handleDragEnd(e) {
      console.log("Drag ended");
      // Remove the dragging class
      this.classList.remove("dragging");
      
      // Hide the tooltip
      document.getElementById("dragTooltip").style.display = "none";
      
      // Reset the current drag source
      currentDragSource = null;
    }
    
    function handleDragOver(e) {
      // Prevent default to allow drop
      e.preventDefault();
      
      // Always use copy effect
      e.dataTransfer.dropEffect = "copy";
      
      // Update tooltip position to follow the cursor
      var tooltip = document.getElementById("dragTooltip");
      tooltip.style.left = (e.clientX + 10) + "px";
      tooltip.style.top = (e.clientY + 10) + "px";
    }
    
    function handleDragEnter(e) {
      console.log("Drag entered element");
      // Add visual indicator that this is a valid drop target
      this.classList.add("drag-over");
    }
    
    function handleDragLeave(e) {
      console.log("Drag left element");
      // Remove the visual indicator
      this.classList.remove("drag-over");
    }
    
    function handleDrop(e) {
      console.log("[DROP] Drop event triggered on:", this);
      console.log("[DROP] Target element dataset:", this.dataset);
      console.log("[DROP] Target element classes:", this.className);
      e.preventDefault();
      
      // Remove the drag-over class
      this.classList.remove("drag-over");
      
      // Get the dragged data
      try {
        var data = JSON.parse(e.dataTransfer.getData("text/plain"));
        console.log("[DROP] Dropped data:", data);
        
        // Extract source info
        var sourceClientId = data.clientId;
        var sourceTherapistId = data.therapistId;
        var sourceDay = data.day;
        var sourceTimeBlock = data.timeBlock;
        var clientName = data.clientName;
        
        // Get target info
        var targetTherapistId = this.dataset.therapistId;
        var targetDay = this.dataset.day;
        var targetTimeBlock = this.dataset.timeBlock;
        
        console.log("[DROP] Source:", sourceTherapistId, sourceDay, sourceTimeBlock);
        console.log("[DROP] Target:", targetTherapistId, targetDay, targetTimeBlock);
        
        // Skip if dropping on the same cell
        if (sourceTherapistId === targetTherapistId && 
            sourceDay === targetDay && 
            sourceTimeBlock === targetTimeBlock) {
          console.log("[DROP] Dropped on the same cell, no action needed");
          return;
        }
        
        // Handle N/A assignments differently
        if (sourceClientId === "N/A") {
          console.log("[DROP] Copy operation: duplicating N/A assignment");
          duplicateNAAssignment(sourceTherapistId, targetTherapistId, targetDay, targetTimeBlock, data);
        } else {
          // Regular client assignment
          console.log("[DROP] Copy operation: duplicating client assignment with metadata");
          duplicateAssignment(sourceClientId, targetTherapistId, targetDay, targetTimeBlock, clientName, data);
        }
      } catch (error) {
        console.error("[DROP] Error processing drop:", error);
        showStatusMessage("Error processing drag and drop operation", "error");
      }
    }
    
    // Add these new functions for duplicating and moving assignments
    
    // Function to duplicate an assignment (copy operation) - FIXED to copy complete metadata
    async function duplicateAssignment(clientId, therapistId, day, timeBlock, clientName, sourceMetadata) {
      var targetTimeSlot = day + "-" + timeBlock;
      
      try {
        // Prevent duplicating N/A assignments
        if (clientId === "N/A") {
          showStatusMessage("N/A assignments cannot be duplicated", "error");
          return;
        }
        
        // Get therapist name for display
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
        // Check if the target cell already has an assignment
        var existingAssignment = assignmentsData.find(function(a) {
          return a.timeSlot === targetTimeSlot && 
                 Number(a.therapistId) === Number(therapistId) &&
                 (a.scheduleType || "current") === currentScheduleType;
        });
        
        if (existingAssignment) {
          // Confirm before overwriting an existing assignment
          var existingClientName = getClientName(existingAssignment.clientId);
          if (!confirm("This will replace " + existingClientName + " with " + clientName + " for " + therapistName + " on " + day + " " + timeBlock + ". Continue?")) {
            return;
          }
        }
        
        // Use source metadata or defaults
        var assignmentType = sourceMetadata ? sourceMetadata.assignmentType : 'regular';
        var assignmentStatus = sourceMetadata ? sourceMetadata.assignmentStatus : 'red';
        var startDate = sourceMetadata ? sourceMetadata.startDate : '';
        var notes = sourceMetadata ? sourceMetadata.notes : '';
        var isMultiTherapist = sourceMetadata ? sourceMetadata.isMultiTherapist : false;
        
        // Show loading state with metadata info
        var typeText = assignmentType === 'playPals' ? ' (Play Pals)' : '';
        var statusText = assignmentStatus === 'red' ? ' 🔴' : assignmentStatus === 'orange' ? ' 🟠' : ' 🟢';
        var multiText = isMultiTherapist ? ' (Multi-Therapist)' : '';
        var scheduleLabel = currentScheduleType === "current" ? "" : " to Future Schedule";
        
        showStatusMessage('Duplicating assignment for ' + clientName + typeText + statusText + multiText + scheduleLabel + '...', 'success');
        
        console.log('[DRAG] Duplicating assignment with complete metadata:', {
          assignmentType: assignmentType,
          assignmentStatus: assignmentStatus,
          startDate: startDate,
          notes: notes,
          isMultiTherapist: isMultiTherapist,
          scheduleType: currentScheduleType
        });
        
        // Set popup form values to match source assignment metadata
        document.getElementById("assignmentType").value = assignmentType;
        document.getElementById("assignmentStatus").value = assignmentStatus;
        document.getElementById("startDate").value = startDate;
        document.getElementById("assignmentNotes").value = notes;
        
        // Handle multi-therapist assignments
        if (isMultiTherapist && sourceMetadata && sourceMetadata.therapistIds && sourceMetadata.therapistIds.length > 1) {
          console.log('[DRAG] Source is multi-therapist with', sourceMetadata.therapistIds.length, 'therapists');
          console.log('[DRAG] Creating individual copy for therapist:', therapistId);
          
          // For multi-therapist source, we create a single-therapist copy
          // This is the expected behavior - copying one therapist from a multi-therapist assignment
          await assignClient(therapistId, clientId, targetTimeSlot);
        } else {
          // Regular single-therapist assignment
          await assignClient(therapistId, clientId, targetTimeSlot);
        }
        
        // Send enhanced drag operation data for analytics
        if (currentDragSource) {
          window.parent.postMessage({
            type: 'dragDropOperation',
            operation: 'copy',
            clientId: Number(clientId),
            clientName: clientName,
            metadata: {
              assignmentType: assignmentType,
              assignmentStatus: assignmentStatus,
              startDate: startDate,
              notes: notes,
              isMultiTherapist: isMultiTherapist,
              sourceScheduleType: sourceMetadata ? sourceMetadata.scheduleType : currentScheduleType,
              targetScheduleType: currentScheduleType
            },
            sourceInfo: {
              therapistId: currentDragSource ? Number(currentDragSource.therapistId) : null,
              day: currentDragSource ? currentDragSource.day : null,
              timeBlock: currentDragSource ? currentDragSource.timeBlock : null
            },
            targetInfo: {
              therapistId: Number(therapistId),
              day: day,
              timeBlock: timeBlock
            }
          }, '*');
        }
        
        console.log('[DRAG] Successfully duplicated assignment with complete metadata');
        
      } catch (error) {
        console.error("[TABLE] Error in duplicateAssignment:", error);
        showStatusMessage("❌ Failed to duplicate assignment for " + clientName + ": " + error.message, "error");
      }
    }
    
    /**
     * Convert assignments from object format (from backend) to array format (for table)
     * Handles multiple backend formats to ensure compatibility
     */
    function convertAssignmentsToArray(assignmentsObject) {
      var assignmentsArray = [];
      
      if (!assignmentsObject || typeof assignmentsObject !== 'object') {
        console.log('[CONVERT] No assignments data or invalid format, returning empty array');
        return assignmentsArray;
      }
      
      // Check if assignmentsObject is already an array (some backends might return array format)
      if (Array.isArray(assignmentsObject)) {
        console.log('[CONVERT] Input is already an array, returning as-is');
        return assignmentsObject;
      }
      
      // Log the structure for debugging
      console.log('[CONVERT] Backend structure - first key:', Object.keys(assignmentsObject)[0]);
      console.log('[CONVERT] Backend structure - sample value:', assignmentsObject[Object.keys(assignmentsObject)[0]]);
      
      // Determine whether the top-level keys represent time slots (contain '-')
      // or therapist IDs (numeric/strings without '-').
      var firstKey = Object.keys(assignmentsObject)[0];
      var isTimeSlotFirst = firstKey && firstKey.includes('-');
      console.log('[CONVERT] Detected', isTimeSlotFirst ? 'timeSlot-first' : 'therapist-first', 'structure');
      
      // Parse legacy therapist-first structure only when detected
      if (!isTimeSlotFirst) {
        Object.keys(assignmentsObject).forEach(function(therapistKey) {
          var therapistData = assignmentsObject[therapistKey];
          
          // Skip if not a valid object
          if (!therapistData || typeof therapistData !== 'object') {
            return;
          }
          
          // Parse therapist key to get day and timeBlock
          var therapistParts = therapistKey.split('-');
          if (therapistParts.length !== 2) {
            console.warn('[CONVERT] Invalid therapist key format:', therapistKey);
            return;
                }
                
          var day = therapistParts[0];
          var timeBlock = therapistParts[1];
          var timeSlot = day + '-' + timeBlock;
                    
          // Iterate through each timeSlot in the therapist data
          Object.keys(therapistData).forEach(function(timeSlotKey) {
            var assignmentData = therapistData[timeSlotKey];
            
            // Skip if not a valid assignment object
            if (!assignmentData || typeof assignmentData !== 'object') {
              return;
            }
            
            // Handle both N/A assignments and regular assignments
            if (timeSlotKey === 'N/A') {
              // This is an N/A assignment
              var assignment = {
                  timeSlot: timeSlot,
                therapistId: assignmentData.therapistIds ? assignmentData.therapistIds[0] : null,
                clientId: 'N/A',
                    assignmentType: assignmentData.assignmentType || 'regular',
                    assignmentStatus: assignmentData.assignmentStatus || 'red',
                    startDate: assignmentData.startDate || '',
                    notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [],
                therapistCount: assignmentData.therapistCount || 1,
                isNA: true
              };
              assignmentsArray.push(assignment);
            } else {
              // This is a regular assignment - timeSlotKey is the therapistId
              var therapistId = parseInt(timeSlotKey);
              
              // Create the assignment object
              var assignment = {
                timeSlot: timeSlot,
                  therapistId: therapistId,
                clientId: assignmentData.clientId || 'N/A',
                assignmentType: assignmentData.assignmentType || 'regular',
                assignmentStatus: assignmentData.assignmentStatus || 'red',
                startDate: assignmentData.startDate || '',
                notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [therapistId],
                therapistCount: assignmentData.therapistCount || 1,
                isNA: false
              };
              assignmentsArray.push(assignment);
                }
          });
        });
      } else {
        // Parse timeSlot-first structure
        Object.keys(assignmentsObject).forEach(function(timeSlot) {
          var timeSlotData = assignmentsObject[timeSlot];
          
          // Skip if not a valid object
          if (!timeSlotData || typeof timeSlotData !== 'object') {
            return;
          }
          
          Object.keys(timeSlotData).forEach(function(clientId) {
            var assignmentData = timeSlotData[clientId];
             
            // Skip if not a valid assignment object
            if (!assignmentData || typeof assignmentData !== 'object') {
              return;
            }
            
            // Handle both N/A assignments and regular assignments
            if (clientId === 'N/A') {
              // This is an N/A assignment
              var assignment = {
                  timeSlot: timeSlot,
                therapistId: assignmentData.therapistIds ? assignmentData.therapistIds[0] : null,
                clientId: 'N/A',
                  assignmentType: assignmentData.assignmentType || 'regular',
                  assignmentStatus: assignmentData.assignmentStatus || 'red',
                  startDate: assignmentData.startDate || '',
                  notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [],
                  therapistCount: assignmentData.therapistCount || 1,
                isNA: true
              };
              assignmentsArray.push(assignment);
                              } else {
              // This is a regular assignment - clientId is the key, therapistId is in assignmentData
              var therapistId = assignmentData.therapistId || assignmentData.therapistIds?.[0];
              
              if (!therapistId) {
                console.warn('[CONVERT] Skipping assignment without therapistId for client', clientId, 'in', timeSlot);
                return;
              }
              
              var assignment = {
                timeSlot: timeSlot,
                  therapistId: parseInt(therapistId),
                clientId: clientId,  // Use the key as clientId
                assignmentType: assignmentData.assignmentType || 'regular',
                assignmentStatus: assignmentData.assignmentStatus || 'red',
                startDate: assignmentData.startDate || '',
                notes: assignmentData.notes || '',
                scheduleType: assignmentData.scheduleType || 'current',
                multiTherapistGroupId: assignmentData.multiTherapistGroupId || '',
                isMultiTherapist: assignmentData.isMultiTherapist || false,
                therapistIds: assignmentData.therapistIds || [parseInt(therapistId)],
                therapistCount: assignmentData.therapistCount || 1,
                isNA: false
              };
              assignmentsArray.push(assignment);
            }
          });
        });
      }
      
      console.log('[CONVERT] Converted', assignmentsArray.length, 'assignment records');
      return assignmentsArray;
    }
    
    /**
     * Update the selection UI elements (select all checkbox, counters, etc.)
     */
    function updateSelectionUI() {
      var selectAllCheckbox = document.getElementById("selectAllTherapists");
      var visibleTherapists = getVisibleTherapists();
      var visibleSelected = visibleTherapists.filter(function(t) {
        return selectedTherapists.has(String(t.id));
      });
      
      // Update select all checkbox state
      if (visibleSelected.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
      } else if (visibleSelected.length === visibleTherapists.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
      } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
      }
      
      // Update selection counter
      var counter = document.getElementById("selectionCounter");
      if (selectedTherapists.size > 0) {
        counter.textContent = selectedTherapists.size + " selected";
        counter.style.display = "inline";
      } else {
        counter.style.display = "none";
      }
      
      console.log("[SELECTION] Updated UI: " + selectedTherapists.size + " therapists selected");
    }
    
    /**
     * Update copy button state based on selection
     */
    function updateCopyButtonState() {
      var copyButton = document.getElementById("copyScheduleButton");
      var copyText = document.getElementById("copyScheduleText");
      var copySelectedMenuItem = document.getElementById("copySelectedMenuItem");
      var copySelectedText = document.getElementById("copySelectedText");
      
      var hasSelection = selectedTherapists.size > 0;
      var targetSchedule = currentScheduleType === "current" ? "Future" : "Current";
      
      if (hasSelection) {
        // Update main button text
        var therapistWord = selectedTherapists.size === 1 ? "Therapist" : "Therapists";
        copyText.textContent = "Copy " + selectedTherapists.size + " " + therapistWord + " to " + targetSchedule;
        
        // Add visual emphasis
        copyButton.classList.add("has-selection");
        
        // Update menu item
        copySelectedText.textContent = "Copy " + selectedTherapists.size + " Selected " + therapistWord + " to " + targetSchedule;
        copySelectedMenuItem.classList.remove("disabled");
      } else {
        // Reset to default text
        copyText.textContent = "Copy to " + targetSchedule;
        
        // Remove visual emphasis
        copyButton.classList.remove("has-selection");
        
        // Update menu item
        copySelectedText.textContent = "Copy Selected Therapists to " + targetSchedule;
        copySelectedMenuItem.classList.add("disabled");
      }
    }
    
    /**
     * Clear all therapist selections
     */
    function clearTherapistSelection() {
      selectedTherapists.clear();
      updateSelectionUI();
      updateCopyButtonState();
      buildScheduleTable(); // Rebuild to update visual state
      console.log("[SELECTION] Cleared all therapist selections");
    }
    
    // =============================================
    // PATCH DISTANCES FUNCTIONALITY
    // =============================================
    
    /**
     * Show patch distances dialog and check for missing distances
     */
    async function showPatchDistancesDialog() {
      console.log('[PATCH] Showing patch distances dialog...');
      
      // Show the confirmation popup
      document.getElementById('patchConfirmationPopup').style.display = 'flex';
      
      try {
        // Reset UI state
        document.getElementById('patchConfirmationMessage').textContent = 'Checking for sessions with missing distance data...';
        document.getElementById('patchConfirmationDetails').style.display = 'none';
        document.getElementById('confirmPatchButton').style.display = 'none';
        
        console.log('[PATCH] Calling backend API to check missing distances...');
        
        // Call backend to check missing distances
        const checkResult = await callBackendAPI('checkMissingDistances', {});
        
        console.log('[PATCH] Check result:', checkResult);
        
        if (checkResult.success) {
          // Update UI with results
          document.getElementById('totalSessionsCount').textContent = checkResult.totalSessions;
          document.getElementById('missingSessionsCount').textContent = checkResult.missingSessions;
          
          if (checkResult.missingSessions > 0) {
            document.getElementById('patchConfirmationMessage').textContent = 
              `Found ${checkResult.missingSessions} sessions with missing distance data.`;
            document.getElementById('patchConfirmationDetails').style.display = 'block';
            document.getElementById('confirmPatchButton').style.display = 'inline-block';
          } else {
            document.getElementById('patchConfirmationMessage').textContent = 
              'Great! No sessions with missing distance data were found.';
          }
        } else {
          document.getElementById('patchConfirmationMessage').textContent = 
            `Error checking distances: ${checkResult.error}`;
        }
        
      } catch (error) {
        console.error('[PATCH] Error checking missing distances:', error);
        document.getElementById('patchConfirmationMessage').textContent = 
          `Error: ${error.message}`;
      }
    }
    
    /**
     * Start the patch process
     */
    async function startPatchProcess() {
      console.log('[PATCH] Starting patch process...');
      
      // Close confirmation popup and show progress popup
      document.getElementById('patchConfirmationPopup').style.display = 'none';
      document.getElementById('patchProgressPopup').style.display = 'flex';
      
      // Reset progress UI
      document.getElementById('patchProgressMessage').textContent = 'Starting patch process...';
      document.getElementById('patchProgressFill').style.width = '0%';
      document.getElementById('patchProgressText').textContent = 'Preparing...';
      
      try {
        // Update progress
        updatePatchProgress(10, 'Calling backend API...');
        
        console.log('[PATCH] Calling backend to patch missing distances...');
        
        // Call backend to patch distances
        const patchResult = await callBackendAPI('patchMissingDistances', {});
        
        console.log('[PATCH] Patch result:', patchResult);
        
        // Update progress to completion
        updatePatchProgress(100, 'Patching complete!');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Close progress popup and show results
        document.getElementById('patchProgressPopup').style.display = 'none';
        showPatchResults(patchResult);
        
      } catch (error) {
        console.error('[PATCH] Error in patch process:', error);
        
        // Show error in progress dialog
        document.getElementById('patchProgressMessage').textContent = 'Error occurred during patching';
        document.getElementById('patchProgressText').textContent = `Error: ${error.message}`;
        document.getElementById('patchProgressFill').style.backgroundColor = '#f44336';
        
        // Allow user to close after error
        setTimeout(() => {
          document.getElementById('patchProgressPopup').style.display = 'none';
          showPatchResults({
            success: false,
            error: error.message,
            totalSessions: 0,
            missingSessions: 0,
            patchedSessions: 0,
            failedSessions: 0,
            errors: [error.message]
          });
        }, 3000);
      }
    }
    
    /**
     * Update patch progress UI
     */
    function updatePatchProgress(percentage, message) {
      document.getElementById('patchProgressFill').style.width = percentage + '%';
      document.getElementById('patchProgressText').textContent = message;
      
      if (percentage >= 50) {
        document.getElementById('patchProgressMessage').textContent = 'Recalculating distances...';
      }
    }
    
    /**
     * Show patch results dialog
     */
    function showPatchResults(result) {
      console.log('[PATCH] Showing results:', result);
      
      // Update result counts
      document.getElementById('resultTotalSessions').textContent = result.totalSessions || '-';
      document.getElementById('resultPatchedSessions').textContent = result.patchedSessions || '0';
      document.getElementById('resultFailedSessions').textContent = result.failedSessions || '0';
      
      // Show errors if any
      if (result.errors && result.errors.length > 0) {
        document.getElementById('patchErrorSection').style.display = 'block';
        const errorList = document.getElementById('patchErrorList');
        errorList.innerHTML = '';
        
        result.errors.forEach(error => {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-item';
          errorDiv.textContent = error;
          errorList.appendChild(errorDiv);
        });
      } else {
        document.getElementById('patchErrorSection').style.display = 'none';
      }
      
      // Show results popup
      document.getElementById('patchResultsPopup').style.display = 'flex';
    }
    
    /**
     * Close patch confirmation dialog
     */
    function closePatchConfirmation() {
      document.getElementById('patchConfirmationPopup').style.display = 'none';
    }
    
    /**
     * Close patch results dialog
     */
    function closePatchResults() {
      document.getElementById('patchResultsPopup').style.display = 'none';
    }
    
    // Add event listeners for close buttons
    document.getElementById('closePatchConfirmation').addEventListener('click', closePatchConfirmation);
    document.getElementById('closePatchResults').addEventListener('click', closePatchResults);
    
    // =============================================
    // MULTI-THERAPIST MANAGEMENT FUNCTIONS
    // =============================================
    
    /**
     * Set up the multi-therapist section in the assignment popup
     */
    function setupMultiTherapistSection(primaryTherapistId, timeSlot) {
      console.log('[MULTI] Setting up multi-therapist section for:', primaryTherapistId, timeSlot);
      
      var therapistListSection = document.getElementById('therapistListSection');
      var enableMultiTherapist = document.getElementById('enableMultiTherapist');
      var multiTherapistControls = document.getElementById('multiTherapistControls');
      var assignClientButton = document.getElementById('assignClientButton');
      
      // Reset state
      enableMultiTherapist.checked = true;
      multiTherapistControls.style.display = 'block';
      therapistListSection.style.display = 'block';
      assignClientButton.style.display = 'inline-block';
      
      // Set up event listener for checkbox
      enableMultiTherapist.onchange = function() {
        if (this.checked) {
          multiTherapistControls.style.display = 'block';
          populateTherapistSelectionList(primaryTherapistId, timeSlot);
          updateSelectedTherapistsSummary();
        } else {
          multiTherapistControls.style.display = 'none';
          // Reset to single therapist
          currentSelection.selectedTherapistIds = [primaryTherapistId];
        }
      };
      
      // Initialize with primary therapist and auto-enable multi-therapist mode
      populateTherapistSelectionList(primaryTherapistId, timeSlot);
      updateSelectedTherapistsSummary();
      
      // Original initialization
      currentSelection.selectedTherapistIds = [primaryTherapistId];
    }
    
    /**
     * Populate the therapist selection list
     */
    function populateTherapistSelectionList(primaryTherapistId, timeSlot) {
      var therapistList = document.getElementById('therapistSelectionList');
      therapistList.innerHTML = '';
      
      // Get all therapists except the primary one
      var availableTherapists = therapistsData.filter(function(t) {
        return String(t.id) !== String(primaryTherapistId);
      });
      
      // Sort by name
      availableTherapists.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
      
      availableTherapists.forEach(function(therapist) {
        var item = document.createElement('div');
        item.className = 'therapist-selection-item';
        
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'therapist-checkbox';
        checkbox.dataset.therapistId = therapist.id;
        checkbox.checked = currentSelection.selectedTherapistIds.includes(String(therapist.id));
        
        var info = document.createElement('div');
        info.className = 'therapist-info';
        
        var name = document.createElement('div');
        name.className = 'therapist-name-select';
        name.textContent = therapist.name;
        
        // Get distance information for this therapist to the currently selected client
        var distanceInfo = document.createElement('div');
        distanceInfo.className = 'therapist-distance-info';
        distanceInfo.textContent = 'Distance: Will be calculated when client is selected';
        
        info.appendChild(name);
        info.appendChild(distanceInfo);
        
        item.appendChild(checkbox);
        item.appendChild(info);
        
        // Add change event listener
        checkbox.addEventListener('change', function() {
          var therapistId = this.dataset.therapistId;
          if (this.checked) {
            if (!currentSelection.selectedTherapistIds.includes(therapistId)) {
              currentSelection.selectedTherapistIds.push(therapistId);
            }
          } else {
            currentSelection.selectedTherapistIds = currentSelection.selectedTherapistIds.filter(function(id) {
              return id !== therapistId;
            });
          }
          updateSelectedTherapistsSummary();
        });
        
        therapistList.appendChild(item);
      });
    }
    
    /**
     * Update the selected therapists summary
     */
    function updateSelectedTherapistsSummary() {
      var summary = document.getElementById('selectedTherapistsSummary');
      var list = document.getElementById('selectedTherapistsList');
      
      if (currentSelection.selectedTherapistIds.length <= 1) {
        summary.style.display = 'none';
        return;
      }
      
      summary.style.display = 'block';
      list.innerHTML = '';
      
      currentSelection.selectedTherapistIds.forEach(function(therapistId) {
        var therapist = therapistsData.find(function(t) { return String(t.id) === String(therapistId); });
        if (therapist) {
          var tag = document.createElement('span');
          tag.className = 'therapist-tag';
          tag.textContent = therapist.name;
          list.appendChild(tag);
        }
      });
    }
    
    /**
     * Update therapist distance information when a client is selected
     */
    function updateTherapistDistances(clientId) {
      if (!currentSelection.selectedTherapistIds || currentSelection.selectedTherapistIds.length <= 1) {
        return;
      }
      
      console.log('[MULTI] Updating therapist distances for client:', clientId);
      
      var therapistItems = document.querySelectorAll('.therapist-selection-item');
      
      therapistItems.forEach(function(item) {
        var checkbox = item.querySelector('.therapist-checkbox');
        var distanceInfo = item.querySelector('.therapist-distance-info');
        var therapistId = checkbox.dataset.therapistId;
        
        // Find session data for this therapist and client
        var session = sessionsData.find(function(s) {
          return Number(s.therapistId) === Number(therapistId) && 
                 Number(s.clientId) === Number(clientId);
        });
        
        if (session) {
          var distanceText = formatDistance(session.distance_miles) + " mi";
          var timeText = session.travelTime_minutes + " mins";
          distanceInfo.textContent = `Distance: ${distanceText}, ${timeText}`;
        } else {
          distanceInfo.textContent = 'Distance: Unknown (no session data)';
        }
      });
    }
    
    /**
     * Open multi-therapist edit popup
     */
    function openMultiTherapistEditPopup(cell, timeSlot) {
      console.log('[MULTI] Opening multi-therapist edit popup for:', timeSlot);
      
      var therapistId = cell.dataset.therapistId;
      var clientId = cell.dataset.clientId;
      var day = currentSelection.day || cell.dataset.day;
      var timeBlock = currentSelection.timeBlock || cell.dataset.timeBlock;
      
      // Find the multi-therapist assignment
      var assignment = assignmentsData.find(function(a) {
        return a.timeSlot === timeSlot && 
               Number(a.clientId) === Number(clientId) && 
               a.isMultiTherapist &&
               (a.scheduleType || "current") === currentScheduleType;
      });
      
      if (!assignment) {
        console.error('[MULTI] Multi-therapist assignment not found');
        showStatusMessage("Multi-therapist assignment not found", "error");
        return;
      }
      
      console.log('[MULTI] Found assignment:', assignment);
      
      // Set popup title
      var clientName = getClientName(clientId);
      var scheduleLabel = currentScheduleType === "current" ? "" : " (Future Schedule)";
      document.getElementById("multiEditPopupTitle").textContent = 
        `Edit: ${clientName} - ${assignment.therapistCount} Therapists (${day} ${timeBlock})${scheduleLabel}`;
      
      // Populate assignment details
      document.getElementById("multiEditAssignmentType").value = assignment.assignmentType || 'regular';
      document.getElementById("multiEditAssignmentStatus").value = assignment.assignmentStatus || 'red';
      document.getElementById("multiEditStartDate").value = assignment.startDate || '';
      document.getElementById("multiEditAssignmentNotes").value = assignment.notes || '';
      
      // Show/hide start date section
      var startDateSection = document.getElementById("multiEditStartDateSection");
      var startDateWarning = document.getElementById("multiEditStartDateWarning");
      
      if (assignment.assignmentStatus === 'orange') {
        startDateSection.style.display = "block";
        startDateWarning.style.display = "block";
      } else {
        startDateSection.style.display = "none";
        startDateWarning.style.display = "none";
      }
      
      // Populate therapist management section
      populateCurrentTherapistsList(assignment);
      populateMultiEditTherapistList(assignment);
      populateTravelDistanceSummary(assignment);
      
      // Store assignment data for saving
      document.getElementById("multiTherapistEditPopup").dataset.currentAssignment = JSON.stringify(assignment);
      
      // Show popup
      document.getElementById("multiTherapistEditPopup").style.display = "flex";
    }
    
    /**
     * Populate current therapists list in edit popup
     */
    function populateCurrentTherapistsList(assignment) {
      var list = document.getElementById('currentTherapistsList');
      var countDisplay = document.getElementById('therapistCountDisplay');
      
      list.innerHTML = '';
      countDisplay.textContent = `(${assignment.therapistCount} therapists)`;
      
      assignment.therapistIds.forEach(function(therapistId) {
        var therapist = therapistsData.find(function(t) { return String(t.id) === String(therapistId); });
        if (therapist) {
          var tag = document.createElement('div');
          tag.className = 'current-therapist-tag';
          tag.innerHTML = `
            ${therapist.name}
            <span class="remove-therapist-x" data-therapist-id="${therapistId}">&times;</span>
          `;
          
          // Add remove functionality
          tag.querySelector('.remove-therapist-x').addEventListener('click', function() {
            removeTherapistFromAssignment(therapistId, assignment);
          });
          
          list.appendChild(tag);
        }
      });
    }
    
    /**
     * Populate therapist selection list in multi-edit popup
     */
    function populateMultiEditTherapistList(assignment) {
      var list = document.getElementById('multiEditTherapistList');
      list.innerHTML = '';
      
      // Get all therapists not currently assigned
      var availableTherapists = therapistsData.filter(function(t) {
        return !assignment.therapistIds.includes(String(t.id));
      });
      
      availableTherapists.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
      
      availableTherapists.forEach(function(therapist) {
        var item = document.createElement('div');
        item.className = 'therapist-selection-item';
        
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'therapist-checkbox';
        checkbox.dataset.therapistId = therapist.id;
        
        var info = document.createElement('div');
        info.className = 'therapist-info';
        
        var name = document.createElement('div');
        name.className = 'therapist-name-select';
        name.textContent = therapist.name;
        
        // Get distance information
        var session = sessionsData.find(function(s) {
          return Number(s.therapistId) === Number(therapist.id) && 
                 Number(s.clientId) === Number(assignment.clientId);
        });
        
        var distanceInfo = document.createElement('div');
        distanceInfo.className = 'therapist-distance-info';
        
        if (session) {
          distanceInfo.textContent = `Distance: ${formatDistance(session.distance_miles)} mi, ${session.travelTime_minutes} mins`;
        } else {
          distanceInfo.textContent = 'Distance: Unknown';
        }
        
        info.appendChild(name);
        info.appendChild(distanceInfo);
        
        item.appendChild(checkbox);
        item.appendChild(info);
        
        // Add click handler to add therapist
        checkbox.addEventListener('change', function() {
          if (this.checked) {
            addTherapistToAssignment(therapist.id, assignment);
            this.checked = false; // Reset checkbox
          }
        });
        
        list.appendChild(item);
      });
    }
    
    /**
     * Populate travel distance summary
     */
    function populateTravelDistanceSummary(assignment) {
      var list = document.getElementById('travelDistanceList');
      list.innerHTML = '';
      
      var totalDistance = 0;
      var totalTime = 0;
      var unknownCount = 0;
      
      assignment.therapistIds.forEach(function(therapistId) {
        var therapist = therapistsData.find(function(t) { return String(t.id) === String(therapistId); });
        var session = sessionsData.find(function(s) {
          return Number(s.therapistId) === Number(therapistId) && 
                 Number(s.clientId) === Number(assignment.clientId);
        });
        
        var item = document.createElement('div');
        item.style.marginBottom = '4px';
        
        if (session && therapist) {
          var distance = session.distance_miles || 0;
          var time = session.travelTime_minutes || 0;
          
          item.innerHTML = `<strong>${therapist.name}:</strong> ${formatDistance(distance)} mi, ${time} mins`;
          
          totalDistance += distance;
          totalTime += time;
        } else {
          unknownCount++;
          item.innerHTML = `<strong>${therapist ? therapist.name : 'Unknown'}:</strong> Distance unknown`;
        }
        
        list.appendChild(item);
      });
      
      // Add summary
      if (assignment.therapistIds.length > 1) {
        var summary = document.createElement('div');
        summary.style.marginTop = '8px';
        summary.style.paddingTop = '8px';
        summary.style.borderTop = '1px solid #ddd';
        summary.style.fontWeight = 'bold';
        
        if (unknownCount === 0) {
          summary.innerHTML = `<strong>Total:</strong> ${formatDistance(totalDistance)} mi, ${totalTime} mins`;
        } else {
          summary.innerHTML = `<strong>Total:</strong> ${formatDistance(totalDistance)} mi, ${totalTime} mins (${unknownCount} unknown)`;
        }
        
        list.appendChild(summary);
      }
    }
    
    /**
     * Add therapist to multi-therapist assignment
     */
    function addTherapistToAssignment(therapistId, assignment) {
      console.log('[MULTI] Adding therapist', therapistId, 'to assignment');
      
      // Update the assignment object
      if (!assignment.therapistIds.includes(String(therapistId))) {
        assignment.therapistIds.push(String(therapistId));
        assignment.therapistCount = assignment.therapistIds.length;
        
        // Refresh the UI
        populateCurrentTherapistsList(assignment);
        populateMultiEditTherapistList(assignment);
        populateTravelDistanceSummary(assignment);
        
        showStatusMessage(`Added ${getTherapistName(therapistId)} to assignment`, 'success');
      }
    }
    
    /**
     * Remove therapist from multi-therapist assignment
     */
    function removeTherapistFromAssignment(therapistId, assignment) {
      console.log('[MULTI] Removing therapist', therapistId, 'from assignment');
      
      if (assignment.therapistIds.length <= 2) {
        showStatusMessage("Cannot remove therapist - minimum 2 therapists required for multi-therapist assignment", 'error');
        return;
      }
      
      // Update the assignment object
      assignment.therapistIds = assignment.therapistIds.filter(function(id) {
        return String(id) !== String(therapistId);
      });
      assignment.therapistCount = assignment.therapistIds.length;
      
      // Refresh the UI
      populateCurrentTherapistsList(assignment);
      populateMultiEditTherapistList(assignment);
      populateTravelDistanceSummary(assignment);
      
      showStatusMessage(`Removed ${getTherapistName(therapistId)} from assignment`, 'success');
    }
    
    /**
     * Create a multi-therapist assignment
     */
    async function createMultiTherapistAssignment(therapistIds, clientId, timeSlot) {
      console.log('[MULTI] Creating multi-therapist assignment:', { therapistIds, clientId, timeSlot });
      
      if (therapistIds.length < 2) {
        showStatusMessage("Multi-therapist assignment requires at least 2 therapists", 'error');
        return;
      }
      
      try {
        // Get assignment details from popup controls
        var assignmentType = document.getElementById("assignmentType").value;
        var assignmentStatus = document.getElementById("assignmentStatus").value;
        var startDate = document.getElementById("startDate").value;
        var notes = document.getElementById("assignmentNotes").value;
        
        // Validate orange status requires start date
        if (assignmentStatus === 'orange' && !startDate && !notes.includes('start date')) {
          showStatusMessage("Orange status requires a start date. Please enter a date or mention it in notes.", 'error');
          document.getElementById("startDateWarning").style.display = "block";
          return;
        }
        
        // Get client and therapist names for display
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var clientName = client ? client.name : 'Unknown Client';
        
        var therapistNames = therapistIds.map(function(id) {
          var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(id); });
          return therapist ? therapist.name : 'Unknown Therapist';
        });
        
        var typeText = assignmentType === 'playPals' ? '(Play Pals)' : '';
        var scheduleLabel = currentScheduleType === "current" ? "" : " to Future Schedule";
        showStatusMessage(`Creating multi-therapist assignment for ${clientName} ${typeText}${scheduleLabel}...`, 'success');
        
        // Call the backend API to create multi-therapist assignment
        console.log('[MULTI] Creating multi-therapist assignment with multiple API calls...');
        
        // Generate unique group ID upfront to link all related assignments
        var multiTherapistGroupId = 'multi_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        console.log('[MULTI] Generated group ID:', multiTherapistGroupId);
        
        // Track successful API calls for rollback if needed
        var successfulAssignments = [];
        var failedAssignments = [];
        
        try {
          // Make single multi-therapist createAssignment API call 
          console.log('[MULTI] Making single multi-therapist API call for', therapistIds.length, 'therapists...');
          
          var therapistNames = therapistIds.map(id => getTherapistName(id)).join(', ');
          console.log(`[MULTI] Creating multi-therapist assignment for: ${therapistNames}`);
          
          try {
            // Call createAssignment with therapistIds array (proper multi-therapist format)
            const result = await callBackendAPI('createAssignment', {
              therapistIds: therapistIds, // Array of therapist IDs (backend expects this for multi-therapist)
              clientId: clientId,
              timeSlot: timeSlot,
              scheduleType: currentScheduleType,
              assignmentType: assignmentType,
              assignmentStatus: assignmentStatus,
              startDate: startDate,
              notes: notes,
              multiTherapistGroupId: multiTherapistGroupId // Store group ID for linking
            });
            
            console.log('[MULTI] Backend API response:', result);
            console.log('[MULTI] Assignment details:', result.assignmentDetails);
            
            if (result.success) {
              console.log(`[MULTI] ✅ Successfully created multi-therapist assignment for ${therapistNames}`);
              
              // Track successful creation
              therapistIds.forEach(therapistId => {
                successfulAssignments.push({
                  therapistId: therapistId,
                  therapistName: getTherapistName(therapistId),
                  assignmentId: result.assignmentId
                });
              });
            } else {
              throw new Error(`Multi-therapist assignment failed: ${result.error || 'Unknown error'}`);
            }
            
          } catch (apiError) {
            console.error('[MULTI] ❌ Failed to create multi-therapist assignment:', apiError);
            throw new Error(`Multi-therapist assignment creation failed: ${apiError.message}`);
          }
          
          // API call succeeded - proceed with local data update
          console.log('[MULTI] ✅ Multi-therapist assignment created successfully. Updating local data...');
          
          // Remove any existing assignments for these therapists at this time slot
          assignmentsData = assignmentsData.filter(function(a) {
            return !(a.timeSlot === timeSlot && 
                     therapistIds.includes(String(a.therapistId)) &&
                     (a.scheduleType || "current") === currentScheduleType);
          });
          
          // Create separate assignment record for each therapist
          var addedAssignments = [];
          therapistIds.forEach(function(therapistId) {
            var individualAssignment = {
              therapistId: Number(therapistId), // Individual therapist ID
              therapistIds: therapistIds.map(Number), // All therapist IDs (for reference)
              clientId: Number(clientId),
              timeSlot: timeSlot,
              scheduleType: currentScheduleType,
              assignmentType: assignmentType,
              assignmentStatus: assignmentStatus,
              startDate: startDate,
              notes: notes,
              isMultiTherapist: true,
              therapistCount: therapistIds.length,
              multiTherapistGroupId: multiTherapistGroupId // Link all related assignments
            };
            
            assignmentsData.push(individualAssignment);
            addedAssignments.push(individualAssignment);
          });
          
          console.log('[MULTI] Added', addedAssignments.length, 'individual assignment records for group:', multiTherapistGroupId);
          console.log('[MULTI] Added multi-therapist assignments to local data for ' + currentScheduleType + ' schedule');
          
          // Update the UI
          buildScheduleTable();
          closePopup();
          
          // Show success message with details
          var statusIcon = assignmentStatus === 'red' ? '🔴' : assignmentStatus === 'orange' ? '🟠' : '🟢';
          var scheduleText = currentScheduleType === "current" ? "" : " in Future Schedule";
          var successDetails = successfulAssignments.map(sa => sa.therapistName).join(', ');
          showStatusMessage(`${statusIcon} Successfully created multi-therapist assignment: ${clientName} → ${successDetails} ${typeText}${scheduleText}`, 'success');
          
        } catch (overallError) {
          // Handle partial failure scenario
          console.error('[MULTI] Multi-therapist assignment creation failed:', overallError);
          
          if (successfulAssignments.length > 0) {
            console.warn('[MULTI] ⚠️ Partial failure: Some assignments were created successfully');
            console.log('[MULTI] Successful assignments:', successfulAssignments);
            console.log('[MULTI] Failed assignments:', failedAssignments);
            
            // Show partial success message
            var successNames = successfulAssignments.map(sa => sa.therapistName).join(', ');
            var failedNames = failedAssignments.map(fa => fa.therapistName).join(', ');
            showStatusMessage(`⚠️ Partial success: Created assignments for ${successNames}. Failed for ${failedNames}. Please retry for failed therapists.`, 'error');
          } else {
            // Complete failure
            console.log('[MULTI] Complete failure: No assignments were created');
            showStatusMessage("❌ Failed to create multi-therapist assignment for " + clientName + ": " + overallError.message, 'error');
          }
          
          throw overallError;
        }
        
      } catch (error) {
        console.error("[MULTI] Error in createMultiTherapistAssignment:", error);
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var clientName = client ? client.name : 'Unknown Client';
        showStatusMessage("❌ Failed to create multi-therapist assignment for " + clientName + ": " + error.message, 'error');
      }
    }
    
    /**
     * Save changes to multi-therapist assignment
     */
    async function saveMultiTherapistChanges() {
      try {
        var popup = document.getElementById("multiTherapistEditPopup");
        var currentAssignment = JSON.parse(popup.dataset.currentAssignment);
        
        console.log('[MULTI] Saving multi-therapist assignment changes for:', currentAssignment);
        
        // Get new values
        var newType = document.getElementById("multiEditAssignmentType").value;
        var newStatus = document.getElementById("multiEditAssignmentStatus").value;
        var newStartDate = document.getElementById("multiEditStartDate").value;
        var newNotes = document.getElementById("multiEditAssignmentNotes").value;
        
        // Validate orange status requires start date
        if (newStatus === 'orange' && !newStartDate && !newNotes.includes('start date')) {
          showStatusMessage("Orange status requires a start date. Please enter a date or mention it in notes.", 'error');
          document.getElementById("multiEditStartDateWarning").style.display = "block";
          return;
        }
        
        // Show loading
        var clientName = getClientName(currentAssignment.clientId);
        var scheduleLabel = (currentAssignment.scheduleType || currentScheduleType) === "current" ? "" : " in Future Schedule";
        showStatusMessage(`Updating multi-therapist assignment for ${clientName}${scheduleLabel}...`, 'success');
        
        console.log('[MULTI] Calling backend API with:', {
          timeSlot: currentAssignment.timeSlot,
          clientId: currentAssignment.clientId,
          therapistIds: currentAssignment.therapistIds,
          scheduleType: currentAssignment.scheduleType || currentScheduleType,
          assignmentType: newType,
          assignmentStatus: newStatus,
          startDate: newStartDate,
          notes: newNotes,
          isMultiTherapist: true
        });
        
        // Call backend API to update multi-therapist assignment
        var result = await callBackendAPI('updateAssignmentDetails', {
          timeSlot: currentAssignment.timeSlot,
          clientId: currentAssignment.clientId,
          therapistIds: currentAssignment.therapistIds,
          scheduleType: currentAssignment.scheduleType || currentScheduleType,
          assignmentType: newType,
          assignmentStatus: newStatus,
          startDate: newStartDate,
          notes: newNotes,
          isMultiTherapist: true
        });
        
        console.log('[MULTI] Backend API response:', result);
        
        if (result.success) {
          // Update local data - find all assignment records for this multi-therapist assignment
          var updatedCount = 0;
          assignmentsData.forEach(function(assignment, index) {
            if (assignment.timeSlot === currentAssignment.timeSlot && 
                Number(assignment.clientId) === Number(currentAssignment.clientId) &&
                assignment.isMultiTherapist &&
                (assignment.scheduleType || "current") === (currentAssignment.scheduleType || currentScheduleType)) {
              
              // Update the assignment data
              assignmentsData[index].assignmentType = newType;
              assignmentsData[index].assignmentStatus = newStatus;
              assignmentsData[index].startDate = newStartDate;
              assignmentsData[index].notes = newNotes;
              assignmentsData[index].therapistIds = currentAssignment.therapistIds;
              assignmentsData[index].therapistCount = currentAssignment.therapistCount;
              
              updatedCount++;
            }
          });
          
          console.log('[MULTI] Updated', updatedCount, 'local assignment records');
          
          // Close popup
          popup.style.display = "none";
          
          // Rebuild table to show changes
          buildScheduleTable();
          
          // Show success with status icon and type info
          var statusIcon = newStatus === 'red' ? '🔴' : newStatus === 'orange' ? '🟠' : '🟢';
          var typeText = newType === 'playPals' ? ' (Play Pals)' : '';
          showStatusMessage(`${statusIcon} Updated multi-therapist assignment for ${clientName}${typeText}${scheduleLabel}`, 'success');
          
        } else {
          throw new Error(result.error || 'Update failed');
        }
        
      } catch (error) {
        console.error("[MULTI] Error saving multi-therapist assignment:", error);
        showStatusMessage("❌ Failed to update multi-therapist assignment: " + error.message, 'error');
      }
    }
    
    // Multi-therapist popup event listeners
    document.addEventListener('DOMContentLoaded', function() {
      // Multi-therapist edit popup controls
      var closeMultiEditPopup = document.getElementById("closeMultiEditPopup");
      var cancelMultiTherapistEdit = document.getElementById("cancelMultiTherapistEdit");
      var saveMultiTherapistChanges = document.getElementById("saveMultiTherapistChanges");
      var clearMultiTherapistAssignment = document.getElementById("clearMultiTherapistAssignment");
      
      if (closeMultiEditPopup) {
        closeMultiEditPopup.addEventListener("click", function() {
          document.getElementById("multiTherapistEditPopup").style.display = "none";
        });
      }
      
      if (cancelMultiTherapistEdit) {
        cancelMultiTherapistEdit.addEventListener("click", function() {
          document.getElementById("multiTherapistEditPopup").style.display = "none";
        });
      }
      
      if (saveMultiTherapistChanges) {
        saveMultiTherapistChanges.addEventListener("click", function() {
          saveMultiTherapistChanges();
        });
      }
      
      if (clearMultiTherapistAssignment) {
        clearMultiTherapistAssignment.addEventListener("click", function() {
          clearMultiTherapistAssignmentConfirm();
        });
      }
      
      // Multi-edit popup assignment controls
      var multiEditAssignmentStatus = document.getElementById("multiEditAssignmentStatus");
      var multiEditStartDateSection = document.getElementById("multiEditStartDateSection");
      var multiEditStartDateWarning = document.getElementById("multiEditStartDateWarning");
      
      if (multiEditAssignmentStatus) {
        multiEditAssignmentStatus.addEventListener("change", function() {
          if (this.value === "orange") {
            multiEditStartDateSection.style.display = "block";
            multiEditStartDateWarning.style.display = "block";
          } else {
            multiEditStartDateSection.style.display = "none";
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
      
      var multiEditStartDate = document.getElementById("multiEditStartDate");
      if (multiEditStartDate) {
        multiEditStartDate.addEventListener("change", function() {
          if (this.value) {
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
      
      var multiEditAssignmentNotes = document.getElementById("multiEditAssignmentNotes");
      if (multiEditAssignmentNotes) {
        multiEditAssignmentNotes.addEventListener("input", function() {
          if (this.value.toLowerCase().includes('start date')) {
            multiEditStartDateWarning.style.display = "none";
          }
        });
      }
    });
    
    /**
     * Clear multi-therapist assignment with confirmation
     */
    async function clearMultiTherapistAssignmentConfirm() {
      var popup = document.getElementById("multiTherapistEditPopup");
      var currentAssignment = JSON.parse(popup.dataset.currentAssignment);
      
      var clientName = getClientName(currentAssignment.clientId);
      var therapistNames = currentAssignment.therapistIds.map(function(id) {
        return getTherapistName(id);
      });
      
      var confirmMessage = `Clear multi-therapist assignment for ${clientName}?\n\nThis will remove:\n${therapistNames.join('\n')}`;
      
      if (confirm(confirmMessage)) {
        try {
          // Show loading state
          var scheduleLabel = (currentAssignment.scheduleType || currentScheduleType) === "current" ? "" : " from Future Schedule";
          showStatusMessage(`Clearing multi-therapist assignment for ${clientName}${scheduleLabel}...`, 'success');
          
          // Call backend API to clear the assignment
          var result = await callBackendAPI('clearAssignment', {
            clientId: currentAssignment.clientId,
            timeSlot: currentAssignment.timeSlot,
            scheduleType: currentAssignment.scheduleType || currentScheduleType,
            isMultiTherapist: true
          });
          
          if (result.success) {
            // Remove from local data
            assignmentsData = assignmentsData.filter(function(a) {
              return !(a.timeSlot === currentAssignment.timeSlot && 
                       Number(a.clientId) === Number(currentAssignment.clientId) &&
                       a.isMultiTherapist &&
                       (a.scheduleType || "current") === (currentAssignment.scheduleType || currentScheduleType));
            });
            
            // Close popup and rebuild table
            popup.style.display = "none";
            buildScheduleTable();
            
            // Show success message
            var scheduleText = (currentAssignment.scheduleType || currentScheduleType) === "current" ? "" : " from Future Schedule";
            showStatusMessage(`✅ Successfully cleared multi-therapist assignment for ${clientName}${scheduleText}`, "success");
            
          } else {
            throw new Error(result.error || 'Clearing failed');
          }
          
        } catch (error) {
          console.error("[MULTI] Error clearing multi-therapist assignment:", error);
          showStatusMessage("❌ Failed to clear multi-therapist assignment: " + error.message, "error");
        }
      }
    }
    
    // REMOVED: createAssignmentAPI function - now using assignClient instead
    
    // Filter the client list based on search term
    function filterClientList(searchTerm) {
      if (!currentSelection.allClients) return;
      
      searchTerm = searchTerm.toLowerCase().trim();
      
      if (!searchTerm) {
        // If search is empty, show all clients
        createClientElements(currentSelection.allClients);
        return;
      }
      
      // Filter clients by name
      var filteredClients = currentSelection.allClients.filter(function(client) {
        return client.name.toLowerCase().includes(searchTerm);
      });
      
      // Create elements with the filtered list
      createClientElements(filteredClients);
      
      // Highlight the matching text
      if (searchTerm) {
        document.querySelectorAll('.client-name').forEach(function(nameSpan) {
          var name = nameSpan.textContent;
          nameSpan.innerHTML = highlightText(name, searchTerm);
        });
      }
    }
    
    // Assign a client to the current selection (FIXED VERSION)
    async function assignClient(therapistId, clientId, timeSlot) {
      console.log("[ASSIGN] Creating assignment:", { therapistId, clientId, timeSlot, scheduleType: currentScheduleType });
      
      // Prevent multiple concurrent calls
      if (assignClient.isRunning) {
        console.log('[ASSIGN] Assignment creation already in progress, ignoring duplicate call');
        return;
      }
      assignClient.isRunning = true;
      
      try {
        // Get assignment details from popup controls
        var assignmentType = document.getElementById("assignmentType").value;
        var assignmentStatus = document.getElementById("assignmentStatus").value;
        var startDate = document.getElementById("startDate").value;
        var notes = document.getElementById("assignmentNotes").value;
        
        // Validate orange status requires start date
        if (assignmentStatus === 'orange' && !startDate && !notes.includes('start date')) {
          showStatusMessage("Orange status requires a start date. Please enter a date or mention it in notes.", 'error');
          document.getElementById("startDateWarning").style.display = "block";
          return;
        }
        
        // Show loading state
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var therapist = therapistsData.find(function(t) { return Number(t.id) === Number(therapistId); });
        var clientName = client ? client.name : 'Unknown Client';
        var therapistName = therapist ? therapist.name : 'Unknown Therapist';
        
        var typeText = assignmentType === 'playPals' ? '(Play Pals)' : '';
        var scheduleLabel = currentScheduleType === "current" ? "" : " to Future Schedule";
        showStatusMessage('Creating assignment for ' + clientName + ' ' + typeText + scheduleLabel + '...', 'success');
        
        // Filter assignments by current schedule type for conflict checking
        var scheduleAssignments = assignmentsData.filter(function(a) {
          return (a.scheduleType || "current") === currentScheduleType;
        });
        
        // Check if this client is already assigned to another therapist at this time in current schedule
        var existingAssignment = scheduleAssignments.find(function(a) {
          return Number(a.clientId) === Number(clientId) && a.timeSlot === timeSlot;
        });
        
        if (existingAssignment && Number(existingAssignment.therapistId) !== Number(therapistId)) {
          var conflictTherapist = therapistsData.find(function(t) { return Number(t.id) === Number(existingAssignment.therapistId); });
          var conflictTherapistName = conflictTherapist ? conflictTherapist.name : 'Unknown Therapist';
          var errorMessage = `${clientName} is already assigned to ${conflictTherapistName} at ${timeSlot} in ${currentScheduleType} schedule`;
          console.log('[ASSIGN] Client conflict detected:', errorMessage);
          
          // Ask user if they want to move the client from one therapist to another
          if (!confirm(`${errorMessage}. Move ${clientName} from ${conflictTherapistName} to ${therapistName}?`)) {
            console.log('[ASSIGN] User cancelled assignment move');
            showStatusMessage("⚠️ " + errorMessage, 'error');
            return;
          }
          
          // Remove the conflicting assignment from local data
          console.log('[ASSIGN] Removing conflicting client assignment from local data');
          assignmentsData = assignmentsData.filter(function(a) {
            return !(Number(a.clientId) === Number(clientId) && a.timeSlot === timeSlot && (a.scheduleType || "current") === currentScheduleType);
          });
          
          // Also try to clear it from backend
          console.log('[ASSIGN] Clearing conflicting client assignment from backend');
          await clearAssignment(existingAssignment.therapistId, timeSlot);
          
          // Update scheduleAssignments after removal
          scheduleAssignments = assignmentsData.filter(function(a) {
            return (a.scheduleType || "current") === currentScheduleType;
          });
        }
        
        // Check if this therapist already has an assignment at this time in current schedule
        var therapistAssignment = scheduleAssignments.find(function(a) {
          return Number(a.therapistId) === Number(therapistId) && a.timeSlot === timeSlot;
        });
        
        if (therapistAssignment && Number(therapistAssignment.clientId) !== Number(clientId)) {
          var existingClient = clientsData.find(function(c) { return Number(c.id) === Number(therapistAssignment.clientId); });
          var existingClientName = existingClient ? existingClient.name : 'Unknown Client';
          
          console.log('[ASSIGN] Therapist conflict detected, will clear existing assignment:', {
            therapistId: therapistId,
            timeSlot: timeSlot,
            existingClient: existingClientName,
            newClient: clientName
          });
          
          // Ask for confirmation before clearing existing assignment
          if (!confirm(`${therapistName} is currently assigned to ${existingClientName} at ${timeSlot}. Replace with ${clientName}?`)) {
            console.log('[ASSIGN] User cancelled assignment replacement');
            return;
          }
          
          // Clear existing assignment FIRST to avoid backend conflict issues
          console.log('[ASSIGN] Clearing existing assignment before creating new one');
          await clearAssignment(therapistId, timeSlot);
          
          // Refresh assignments data after clearing
          scheduleAssignments = assignmentsData.filter(function(a) {
            return (a.scheduleType || "current") === currentScheduleType;
          });
        }
        
        // Try updateAssignmentDetails first (workaround for createAssignment bug)
        console.log('[ASSIGN] Attempting to save assignment to backend...');
        
        var assignmentData = {
          therapistId: therapistId,
          clientId: clientId,
          timeSlot: timeSlot,
          scheduleType: currentScheduleType,
          assignmentType: assignmentType,
          assignmentStatus: assignmentStatus,
          startDate: startDate,
          notes: notes
        };
        
        var result = await callBackendAPI('updateAssignmentDetails', assignmentData);
        
        // If updateAssignmentDetails fails, try other backend approaches
        if (!result.success) {
          console.log('[ASSIGN] updateAssignmentDetails failed:', result.error);
          console.log('[ASSIGN] Trying clear-then-create approach...');
          
          try {
            // Clear first
            await callBackendAPI('clearAssignment', {
              therapistId: therapistId,
              timeSlot: timeSlot,
              scheduleType: currentScheduleType
            });
            
            // Wait a bit for backend to process
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Then create
            result = await callBackendAPI('createAssignment', assignmentData);
            
            if (result.success) {
              console.log('[ASSIGN] ✅ Clear-then-create worked!');
            } else {
              console.log('[ASSIGN] ❌ Clear-then-create also failed:', result.error);
            }
          } catch (error) {
            console.log('[ASSIGN] ❌ Clear-then-create threw error:', error.message);
            result = { success: false, error: error.message };
          }
        } else {
          console.log('[ASSIGN] ✅ updateAssignmentDetails worked!');
        }
        
        // If all backend attempts fail, create locally but warn user
        if (!result.success) {
          console.log('[ASSIGN] ⚠️ ALL BACKEND APIs FAILED - saving locally only');
          console.log('[ASSIGN] This assignment will disappear on page refresh');
          showStatusMessage('⚠️ Backend error - assignment saved locally only. Will disappear on refresh!', 'warning');
          
          // Create assignment locally
          assignmentsData.push({
            therapistId: Number(therapistId),
            clientId: Number(clientId),
            timeSlot: timeSlot,
            scheduleType: currentScheduleType,
            assignmentType: assignmentType,
            assignmentStatus: assignmentStatus,
            startDate: startDate,
            notes: notes
          });
          
          result = { success: true, action: 'created_locally_only' };
        } else {
          console.log('[ASSIGN] ✅ Assignment successfully saved to backend');
        }
        
        if (result.success) {
          console.log('[ASSIGN] Assignment ' + (result.action || 'created') + ' successfully');
          
          // Update local assignments data if not already done
          if (result.action !== 'created_locally_only') {
            var existingIndex = assignmentsData.findIndex(function(a) {
              return Number(a.therapistId) === Number(therapistId) && 
                     Number(a.clientId) === Number(clientId) && 
                     a.timeSlot === timeSlot &&
                     (a.scheduleType || "current") === currentScheduleType;
            });
            
            if (existingIndex === -1) {
              // Add new assignment to local data
              assignmentsData.push({
                therapistId: Number(therapistId),
                clientId: Number(clientId),
                timeSlot: timeSlot,
                scheduleType: currentScheduleType,
                assignmentType: assignmentType,
                assignmentStatus: assignmentStatus,
                startDate: startDate,
                notes: notes
              });
              console.log('[ASSIGN] Added assignment to local data for ' + currentScheduleType + ' schedule');
            } else {
              // Update existing assignment
              assignmentsData[existingIndex] = {
                therapistId: Number(therapistId),
                clientId: Number(clientId),
                timeSlot: timeSlot,
                scheduleType: currentScheduleType,
                assignmentType: assignmentType,
                assignmentStatus: assignmentStatus,
                startDate: startDate,
                notes: notes
              };
              console.log('[ASSIGN] Updated existing assignment in local data for ' + currentScheduleType + ' schedule');
            }
          }
          
          // Update the UI
          buildScheduleTable();
          closePopup();
          
          // Show success message
          var statusIcon = assignmentStatus === 'red' ? '🔴' : assignmentStatus === 'orange' ? '🟠' : '🟢';
          var scheduleText = currentScheduleType === "current" ? "" : " in Future Schedule";
          var methodText = result.action === 'created_locally_only' ? ' (local mode)' : '';
          showStatusMessage(statusIcon + " Successfully assigned " + clientName + " to " + therapistName + " " + typeText + scheduleText + methodText, 'success');
          
        } else {
          throw new Error(result.error || 'Assignment creation failed');
        }
        
      } catch (error) {
        console.error("[ERROR] Assignment creation failed:", error);
        var client = clientsData.find(function(c) { return Number(c.id) === Number(clientId); });
        var clientName = client ? client.name : 'Unknown Client';
        showStatusMessage("Assignment failed: " + error.message, 'error');
      } finally {
        // Always reset the running flag
        assignClient.isRunning = false;
      }
    }
    
    /**
     * Safer createAssignment wrapper that handles backend bugs
     * Works around the "this.clearAssignment is not a function" bug in Google Apps Script backend
     */
    async function safeCreateAssignment(assignmentData) {
      try {
        // Option 1: Try updateAssignmentDetails instead of createAssignment
        console.log('[SAFE] Option 1: Trying updateAssignmentDetails instead of createAssignment...');
        var result = await callBackendAPI('updateAssignmentDetails', assignmentData);
        
        if (result.success) {
          console.log('[SAFE] Option 1 succeeded: updateAssignmentDetails worked');
          return result;
        }
        
        console.log('[SAFE] Option 1 failed:', result.error);
        
        // Option 2: Try clear-then-create approach
        console.log('[SAFE] Option 2: Trying clear-then-create approach...');
        var clearCreateResult = await clearThenCreateAssignment(assignmentData);
        
        if (clearCreateResult.success) {
          console.log('[SAFE] Option 2 succeeded: clear-then-create worked');
          return clearCreateResult;
        }
        
        console.log('[SAFE] Option 2 failed:', clearCreateResult.error);
        
        // Option 3: Try the original createAssignment as last resort
        console.log('[SAFE] Option 3: Attempting original createAssignment as last resort...');
        var originalResult = await callBackendAPI('createAssignment', assignmentData);
        
        if (originalResult.success) {
          console.log('[SAFE] Option 3 succeeded: original createAssignment worked');
          return originalResult;
        }
        
        console.log('[SAFE] All backend options failed. Errors:', {
          updateAssignmentDetails: result.error,
          clearThenCreate: clearCreateResult.error,
          createAssignment: originalResult.error
        });
        
        // Check if it's the known backend bug
        if (originalResult.error && originalResult.error.includes('clearAssignment')) {
          return {
            success: false,
            error: 'Backend bug detected: All backend assignment APIs have failed. The createAssignment function has a bug. Consider using manual assignment mode.',
            requiresManualMode: true
          };
        }
        
        // Return the most informative error
        return {
          success: false,
          error: 'All assignment methods failed. Errors: updateAssignmentDetails: ' + result.error + '; clearThenCreate: ' + clearCreateResult.error + '; createAssignment: ' + originalResult.error
        };
        
      } catch (error) {
        console.error('[SAFE] Exception in safeCreateAssignment:', error);
        return {
          success: false,
          error: 'Assignment creation failed: ' + error.message
        };
      }
    }
    
    // Close popup function
    function closePopup() {
      document.getElementById("assignmentPopup").style.display = "none";
      // Reset any selection state
      currentSelection.selectedClientId = null;
      document.getElementById("assignClientButton").style.display = "none";
    }
    
    /**
     * Manual assignment creation that bypasses the buggy backend createAssignment (Option 2)
     * This creates the assignment locally and could sync to backend later
     */
    async function manualCreateAssignment(assignmentData) {
      try {
        console.log('[MANUAL] Creating assignment locally:', assignmentData);
        
        // First, remove any existing conflicting assignments from local data
        console.log('[MANUAL] Clearing any conflicting assignments from local data');
        var conflictsRemoved = 0;
        
        // Remove client conflicts (same client, same time slot)
        var initialLength = assignmentsData.length;
        assignmentsData = assignmentsData.filter(function(a) {
          var isConflict = (Number(a.clientId) === Number(assignmentData.clientId) && 
                           a.timeSlot === assignmentData.timeSlot &&
                           (a.scheduleType || "current") === (assignmentData.scheduleType || currentScheduleType));
          if (isConflict) conflictsRemoved++;
          return !isConflict;
        });
        
        // Remove therapist conflicts (same therapist, same time slot)
        assignmentsData = assignmentsData.filter(function(a) {
          var isConflict = (Number(a.therapistId) === Number(assignmentData.therapistId) && 
                           a.timeSlot === assignmentData.timeSlot &&
                           (a.scheduleType || "current") === (assignmentData.scheduleType || currentScheduleType));
          if (isConflict) conflictsRemoved++;
          return !isConflict;
        });
        
        console.log('[MANUAL] Removed', conflictsRemoved, 'conflicting assignments from local data');
        
        // Create assignment object
        var newAssignment = {
          therapistId: Number(assignmentData.therapistId),
          clientId: Number(assignmentData.clientId),
          timeSlot: assignmentData.timeSlot,
          scheduleType: assignmentData.scheduleType || currentScheduleType,
          assignmentType: assignmentData.assignmentType || 'regular',
          assignmentStatus: assignmentData.assignmentStatus || 'red',
          startDate: assignmentData.startDate || '',
          notes: assignmentData.notes || '',
          isMultiTherapist: false,
          therapistCount: 1
        };
        
        // Add the new assignment
        assignmentsData.push(newAssignment);
        console.log('[MANUAL] Added new assignment to local data');
        
        // Immediately update the UI to show the change
        buildScheduleTable();
        
        console.log('[MANUAL] Assignment created locally successfully');
        return {
          success: true,
          action: 'created_locally',
          assignmentId: assignmentData.therapistId + '-' + assignmentData.timeSlot + '-' + assignmentData.clientId,
          message: 'Assignment created locally (backend sync skipped due to createAssignment bug)'
        };
        
      } catch (error) {
        console.error('[MANUAL] Error in manual assignment creation:', error);
        return {
          success: false,
          error: 'Manual assignment creation failed: ' + error.message
        };
      }
    }
    
    /**
     * Option 3: Clear-then-create approach to avoid backend conflicts entirely
     */
    async function clearThenCreateAssignment(assignmentData) {
      try {
        console.log('[CLEAR-CREATE] Starting clear-then-create approach...');
        
        // Always clear any existing assignment first to ensure clean slate
        console.log('[CLEAR-CREATE] Clearing any existing assignment first...');
        var clearResult = await callBackendAPI('clearAssignment', {
          clientId: assignmentData.clientId,
          timeSlot: assignmentData.timeSlot,
          scheduleType: assignmentData.scheduleType
        });
        
        // Don't fail if clear fails (maybe nothing was there to clear)
        if (clearResult.success) {
          console.log('[CLEAR-CREATE] Successfully cleared existing assignment');
        } else {
          console.log('[CLEAR-CREATE] Clear failed (maybe nothing to clear):', clearResult.error);
        }
        
        // Also clear the therapist's slot
        console.log('[CLEAR-CREATE] Clearing therapist slot...');
        var therapistClearResult = await callBackendAPI('clearAssignment', {
          therapistId: assignmentData.therapistId,
          timeSlot: assignmentData.timeSlot,
          scheduleType: assignmentData.scheduleType
        });
        
        if (therapistClearResult.success) {
          console.log('[CLEAR-CREATE] Successfully cleared therapist slot');
        } else {
          console.log('[CLEAR-CREATE] Therapist clear failed:', therapistClearResult.error);
        }
        
        // Wait a moment for backend to process
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Now try createAssignment on clean slate
        console.log('[CLEAR-CREATE] Creating assignment on clean slate...');
        var createResult = await callBackendAPI('createAssignment', assignmentData);
        
        if (createResult.success) {
          console.log('[CLEAR-CREATE] Successfully created assignment after clearing');
          return createResult;
        } else {
          console.log('[CLEAR-CREATE] Create still failed after clearing:', createResult.error);
          return createResult;
        }
        
      } catch (error) {
        console.error('[CLEAR-CREATE] Exception in clearThenCreateAssignment:', error);
        return {
          success: false,
          error: 'Clear-then-create failed: ' + error.message
        };
      }
    }
    
    /**
     * Manual assignment creation that bypasses the buggy backend createAssignment (Option 2)
     */
    // Create assignment using various backend methods with fallback to local creation
    async function createAssignment(assignmentData) {
      console.log('[ASSIGN] Creating assignment:', assignmentData);
      
      // Prevent duplicate assignment creation calls
      if (assignmentCreationInProgress) {
        console.log('[ASSIGN] Assignment creation already in progress, ignoring duplicate call');
        return;
      }
      
      assignmentCreationInProgress = true;
      
      try {
        // STEP 1: Try updateAssignmentDetails first (works for existing assignments)
        console.log('[ASSIGN] Attempting to save assignment to backend...');
        var updateResult = await callBackendAPI('updateAssignmentDetails', assignmentData);
        
        if (updateResult.success) {
          console.log('[ASSIGN] ✅ Assignment updated successfully via updateAssignmentDetails');
          await handleSuccessfulAssignment(assignmentData, 'updated');
          return;
        }
        
        console.log('[ASSIGN] updateAssignmentDetails failed:', updateResult.error);
        
        // STEP 2: If update fails with "Assignment not found", try clearAssignment followed by local creation
        if (updateResult.error && updateResult.error.includes('Assignment not found')) {
          console.log('[ASSIGN] Trying clear-then-local-create approach...');
          
          // Clear the slot first
          var clearResult = await callBackendAPI('clearAssignment', {
            therapistId: assignmentData.therapistId,
            timeSlot: assignmentData.timeSlot,
            scheduleType: assignmentData.scheduleType
          });
          
          // NOTE: We skip createAssignment since it has a backend bug ("this.clearAssignment is not a function")
          console.log('[ASSIGN] ⚠️ Backend createAssignment is broken - creating assignment locally only');
          console.log('[ASSIGN] This assignment will persist until the backend bug is fixed');
          
          // Create assignment locally
          await handleSuccessfulAssignment(assignmentData, 'created_locally_with_backend_clear');
          return;
        }
        
        // STEP 3: If all else fails, create locally only
        console.log('[ASSIGN] ⚠️ ALL BACKEND APIs FAILED - saving locally only');
        console.log('[ASSIGN] This assignment will disappear on page refresh');
        
        await handleSuccessfulAssignment(assignmentData, 'created_locally_only');
        
      } catch (error) {
        console.error('[ASSIGN] Error in createAssignment:', error);
        
        // Even if there's an error, try to create locally as fallback
        console.log('[ASSIGN] 🆘 Creating assignment locally as final fallback');
        await handleSuccessfulAssignment(assignmentData, 'created_locally_fallback');
        
      } finally {
        assignmentCreationInProgress = false;
      }
    }
    
    // Handle successful assignment creation (both backend and local)
    async function handleSuccessfulAssignment(assignmentData, mode) {
      try {
        // Update local assignments data
        var existingIndex = assignmentsData.findIndex(function(a) {
          return Number(a.therapistId) === Number(assignmentData.therapistId) && 
                 a.timeSlot === assignmentData.timeSlot && 
                 (a.scheduleType || "current") === (assignmentData.scheduleType || "current");
        });
        
        if (existingIndex !== -1) {
          // Update existing assignment
          assignmentsData[existingIndex] = Object.assign({}, assignmentsData[existingIndex], assignmentData);
          console.log('[ASSIGN] Updated existing local assignment');
        } else {
          // Add new assignment
          assignmentsData.push(Object.assign({
            assignmentType: 'regular',
            assignmentStatus: 'red',
            startDate: '',
            notes: '',
            scheduleType: 'current'
          }, assignmentData));
          console.log('[ASSIGN] Added new local assignment');
        }
        
        // Rebuild the table to reflect changes
        buildScheduleTable();
        
        // Show appropriate success message based on mode
        var clientName = getClientName(assignmentData.clientId);
        var therapistName = getTherapistName(assignmentData.therapistId);
        var timeSlotParts = assignmentData.timeSlot.split('-');
        var day = timeSlotParts[0];
        var timeBlock = timeSlotParts[1];
        var scheduleLabel = (assignmentData.scheduleType || 'current') === 'current' ? '' : ' (Future Schedule)';
        
        if (mode === 'updated') {
          showStatusMessage("✅ Assignment updated: " + clientName + " → " + therapistName + " (" + day + " " + timeBlock + ")" + scheduleLabel, "success");
        } else if (mode === 'created_locally_with_backend_clear') {
          showStatusMessage("✅ Assignment created: " + clientName + " → " + therapistName + " (" + day + " " + timeBlock + ")" + scheduleLabel + " (backend slot cleared)", "success");
        } else if (mode.includes('locally')) {
          showStatusMessage("✅ Assignment created: " + clientName + " → " + therapistName + " (" + day + " " + timeBlock + ")" + scheduleLabel + " (local mode)", "success");
        } else {
          showStatusMessage("✅ Assignment " + mode + ": " + clientName + " → " + therapistName + " (" + day + " " + timeBlock + ")" + scheduleLabel, "success");
        }
        
        console.log('[ASSIGN] Assignment ' + mode + ' successfully');
        
      } catch (error) {
        console.error('[ASSIGN] Error in handleSuccessfulAssignment:', error);
        showStatusMessage("❌ Error finalizing assignment: " + error.message, "error");
      }
    }

    // =============================================
    // TABLE BUILDING FUNCTION - WAS MISSING!
    // =============================================
    
    /**
     * Build the schedule table from loaded data
     */
    function buildScheduleTable() {
      console.log('[BUILD] Building schedule table...');
      console.log('[BUILD] Data available:', {
        therapists: therapistsData.length,
        assignments: assignmentsData.length,
        currentScheduleType: currentScheduleType
      });
      
      var tableBody = document.getElementById('scheduleBody');
      if (!tableBody) {
        console.error('[BUILD] Table body not found!');
        return;
      }
      
      // Clear existing content
      tableBody.innerHTML = '';
      
      if (therapistsData.length === 0) {
        var emptyRow = document.createElement('tr');
        emptyRow.innerHTML = '<td colspan="10" style="text-align: center; padding: 20px; color: #666;">No therapists data available</td>';
        tableBody.appendChild(emptyRow);
        return;
      }
      
      console.log('[BUILD] Building table for', currentScheduleType, 'schedule with', therapistsData.length, 'therapists');
      
      // Filter assignments by current schedule type
      var scheduleAssignments = assignmentsData.filter(function(a) {
        return (a.scheduleType || "current") === currentScheduleType;
      });
      
      console.log('[BUILD] Found', scheduleAssignments.length, 'assignments for', currentScheduleType, 'schedule');
      
      // Filter therapists based on search term
      var filteredTherapists = therapistsData;
      if (currentSearchTerm && currentSearchTerm.trim()) {
        var searchTerm = currentSearchTerm.toLowerCase().trim();
        
        filteredTherapists = therapistsData.filter(function(therapist) {
          // Check if therapist name matches
          if (therapist.name.toLowerCase().includes(searchTerm)) {
            return true;
          }
          
          // Check if any of their assigned clients match
          var hasMatchingClient = scheduleAssignments.some(function(assignment) {
            if (String(assignment.therapistId) === String(therapist.id) && assignment.clientId !== "N/A") {
              var clientName = getClientName(assignment.clientId);
              return clientName.toLowerCase().includes(searchTerm);
            }
            return false;
          });
          
          return hasMatchingClient;
        });
        
        console.log('[BUILD] Search filter applied:', filteredTherapists.length, 'of', therapistsData.length, 'therapists match');
      }
      
      // Build table rows
      filteredTherapists.forEach(function(therapist, therapistIndex) {
        // Create rows for each time block
        timeBlocks.forEach(function(timeBlock, blockIndex) {
          var row = document.createElement('tr');
          row.className = therapistIndex % 2 === 0 ? 'therapist-group-even' : '';
          
          // Add checkbox column
          var checkboxCell = document.createElement('td');
          checkboxCell.className = 'therapist-checkbox';
          if (blockIndex === 0) { // Only show checkbox in first row for each therapist
            var checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'therapist-select';
            checkbox.dataset.therapistId = therapist.id;
            checkbox.addEventListener('change', function() {
              updateTherapistSelection(therapist.id, this.checked);
            });
            checkboxCell.appendChild(checkbox);
          }
          row.appendChild(checkboxCell);
          
          // Therapist name (only in first row)
          var nameCell = document.createElement('td');
          if (blockIndex === 0) {
            // Apply highlighting to therapist name if search is active
            if (currentSearchTerm) {
              nameCell.innerHTML = highlightText(therapist.name, currentSearchTerm);
            } else {
              nameCell.textContent = therapist.name;
            }
          }
          row.appendChild(nameCell);
          
          // Lead BCBA (only in first row)
          var leadCell = document.createElement('td');
          if (blockIndex === 0) {
            // Create dropdown for lead BCBA assignment
            var leadDropdown = document.createElement('select');
            leadDropdown.className = 'lead-bcba-dropdown';
            leadDropdown.dataset.therapistId = therapist.id;
            
            // Get available lead BCBAs
            var availableLeads = getAvailableLeadBCBAs();
            
            // Add "Unassigned" option
            var unassignedOption = document.createElement('option');
            unassignedOption.value = 'Unassigned';
            unassignedOption.textContent = 'Unassigned';
            leadDropdown.appendChild(unassignedOption);
            
            // Add BCBA options
            if (availableLeads.length > 0) {
              availableLeads.forEach(function(leadName) {
                var option = document.createElement('option');
                option.value = leadName;
                option.textContent = leadName;
                leadDropdown.appendChild(option);
              });
            } else {
              // Add placeholder option if no BCBAs found
              var noLeadsOption = document.createElement('option');
              noLeadsOption.value = '';
              noLeadsOption.textContent = 'No BCBAs found';
              noLeadsOption.disabled = true;
              leadDropdown.appendChild(noLeadsOption);
              console.warn('[LEAD_BCBA] No therapists with BCBA title found in data');
            }
            
            // Set current value
            var currentLead = therapist.lead || 'Unassigned';
            leadDropdown.value = currentLead;
            
            // Add change event listener
            leadDropdown.addEventListener('change', function() {
              var newLead = this.value;
              var therapistId = this.dataset.therapistId;
              
              // Add loading state
              this.classList.add('lead-bcba-loading');
              this.disabled = true;
              
              // Update the lead assignment
              updateTherapistLead(therapistId, newLead).finally(function() {
                // Remove loading state
                leadDropdown.classList.remove('lead-bcba-loading');
                leadDropdown.disabled = false;
              });
            });
            
            leadCell.appendChild(leadDropdown);
          }
          row.appendChild(leadCell);
          
          // Time block
          var blockCell = document.createElement('td');
          blockCell.textContent = timeBlock;
          blockCell.className = 'time-block';
          row.appendChild(blockCell);
          
          // Day columns (Monday through Friday)
          daySlots.forEach(function(day) {
            var dayCell = document.createElement('td');
            var timeSlot = day + '-' + timeBlock;
            
            // Set data attributes for interaction
            dayCell.dataset.therapistId = therapist.id;
            dayCell.dataset.day = day;
            dayCell.dataset.timeBlock = timeBlock;
            dayCell.dataset.timeSlot = timeSlot;
            
            // Find assignment for this therapist/timeslot
            var assignment = getAssignment(therapist.id, day, timeBlock);
            
            // Enhanced debugging for assignment display
            if (assignment && assignment.clientId && assignment.clientId !== "N/A") {
              console.log('[BUILD_DEBUG] ✅ Found assignment for', therapist.name, day, timeBlock, ':', {
                clientName: assignment.clientName,
                isMultiTherapist: assignment.isMultiTherapist,
                therapistCount: assignment.therapistCount,
                therapistIds: assignment.therapistIds
              });
            } else if (assignment && assignment.clientId === "N/A") {
              console.log('[BUILD_DEBUG] 🔴 Found N/A assignment for', therapist.name, day, timeBlock);
            } else {
              // Only log occasionally to avoid spam
              if (Math.random() < 0.01) { // 1% chance to log
                console.log('[BUILD_DEBUG] ⚪ No assignment found for', therapist.name, day, timeBlock);
              }
            }
            
            if (assignment) {
              if (assignment.isNA) {
                dayCell.className = 'na';
                dayCell.textContent = 'N/A';
                
                // Set N/A data attributes for drag-and-drop functionality
                dayCell.dataset.clientId = 'N/A';
                dayCell.dataset.isNA = 'true';
                
                // Make N/A cells draggable
                dayCell.draggable = true;
                dayCell.addEventListener('dragstart', handleDragStart);
                dayCell.addEventListener('dragend', handleDragEnd);
              } else {
                dayCell.className = 'assigned';
                if (assignment.assignmentType === 'playPals') {
                  dayCell.classList.add('play-pals');
                }
                
                // Set clientId for ALL assigned cells (needed for drag and drop)
                dayCell.dataset.clientId = assignment.clientId;
                
                // Make assigned cells draggable
                dayCell.draggable = true;
                dayCell.addEventListener('dragstart', handleDragStart);
                dayCell.addEventListener('dragend', handleDragEnd);
                
                // Add multi-therapist class and visual indicators
                if (assignment.isMultiTherapist) {
                  dayCell.classList.add('multi-therapist');
                  // clientId already set above for all assignments
                  
                  // Add tooltip showing all assigned therapists
                  if (assignment.allTherapistNames && assignment.allTherapistNames.length > 0) {
                    dayCell.title = "Multi-Therapist Assignment:\n" + 
                                   assignment.allTherapistNames.join(", ") + 
                                   "\n\nClick to edit assignment details";
                  } else {
                    dayCell.title = assignment.therapistCount + " therapists assigned\n\nClick to edit assignment details";
                  }
                } else {
                  // Regular single-therapist assignment tooltip
                  dayCell.title = "Single therapist assignment\n\nClick to view/edit details";
                }
                
                // Add status class
                if (assignment.assignmentStatus) {
                  dayCell.classList.add('status-' + assignment.assignmentStatus);
                }
                
                var statusIcon = assignment.assignmentStatus === 'red' ? '🔴' : 
                               assignment.assignmentStatus === 'orange' ? '🟠' : 
                               assignment.assignmentStatus === 'green' ? '🟢' : '';
                
                var typeIcon = assignment.assignmentType === 'playPals' ? '🎮 ' : '';
                
                // Add multi-therapist icon for visual distinction
                var multiTherapistIcon = assignment.isMultiTherapist ? '👥 ' : '';
                
                // Create multi-therapist count indicator
                var therapistCountIndicator = '';
                if (assignment.isMultiTherapist && assignment.therapistCount > 1) {
                  therapistCountIndicator = '<span class="therapist-count-badge">' + assignment.therapistCount + ' therapists</span>';
                }
                
                // Apply highlighting to client name if search is active
                var highlightedClientName = currentSearchTerm ? 
                  highlightText(assignment.clientName, currentSearchTerm) : 
                  assignment.clientName;
                
                dayCell.innerHTML = '<span class="client-name">' + highlightedClientName + '</span>' +
                                   '<span class="assignment-indicators">' + multiTherapistIcon + typeIcon + statusIcon + '</span>' +
                                   therapistCountIndicator;
                
                // Add clear button for assignments (not N/A)
                if (assignment.clientId !== "N/A") {
                  var clearBtn = document.createElement("button");
                  clearBtn.className = "clear-btn";
                  clearBtn.innerHTML = "×";
                  clearBtn.title = "Clear assignment";
                  
                  clearBtn.addEventListener("click", function(e) {
                    e.stopPropagation();
                    clearSpecificAssignment(therapist.id, day, timeBlock, assignment.clientId, false);
                  });
                  
                  dayCell.appendChild(clearBtn);
                }
              }
            } else {
              dayCell.className = 'open';
              dayCell.textContent = '';
            }
            
            // Make ALL cells valid drop targets (both open and assigned)
            dayCell.addEventListener('dragover', handleDragOver);
            dayCell.addEventListener('dragenter', handleDragEnter);
            dayCell.addEventListener('dragleave', handleDragLeave);
            dayCell.addEventListener('drop', handleDrop);
            
            // Add click handler
            dayCell.addEventListener('click', function(event) {
              handleCellClick(event);
            });
            
            // Add context menu handler
            dayCell.addEventListener('contextmenu', function(e) {
              e.preventDefault();
              showContextMenu(e, this);
            });
            
            row.appendChild(dayCell);
          });
          
          // Notes column
          var notesCell = document.createElement('td');
          notesCell.className = 'notes-cell';
          notesCell.contentEditable = false; // Initially not editable
          notesCell.dataset.therapistId = therapist.id;
          notesCell.dataset.timeBlock = timeBlock;
          notesCell.dataset.scheduleType = currentScheduleType;
          
          // Create time-block-specific note key for this therapist + timeBlock + schedule
          var therapistId = String(therapist.id);
          var timeBlockStr = String(timeBlock);
          var scheduleTypeStr = String(currentScheduleType);
          var noteKey = therapistId + "-" + timeBlockStr + "-" + scheduleTypeStr;
          var noteText = notesData[noteKey] || '';
          
          console.log('[NOTES] Looking up note for therapist', therapistId, 'timeBlock', timeBlockStr, 'schedule', scheduleTypeStr);
          console.log('[NOTES] Generated noteKey:', noteKey);
          console.log('[NOTES] Found noteText:', noteText);
          console.log('[NOTES] Available notes keys:', Object.keys(notesData));
          
          // Show note text for each time block (each has its own note)
          if (noteText) {
            notesCell.textContent = noteText;
            console.log('[NOTES] Applied note text to', timeBlock, 'cell:', noteText);
          } else {
            console.log('[NOTES] No note text found for key:', noteKey);
          }
          
          // Add event listeners to ALL notes cells (not just blockIndex === 0)
          // This allows clicking on any time block to edit the shared note
          notesCell.addEventListener('click', function(e) {
            e.stopPropagation();
            startNoteEditing(this);
          });
          
          // Add keyboard handlers
          notesCell.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              finishNoteEditing(this, true);
            } else if (e.key === 'Escape') {
              e.preventDefault();
              finishNoteEditing(this, false);
            }
          });
          
          // Add blur handler to save when clicking away
          notesCell.addEventListener('blur', function() {
            finishNoteEditing(this, true);
          });
          
          row.appendChild(notesCell);
          
          tableBody.appendChild(row);
        });
      });
      
      console.log('[BUILD] Table built successfully with', tableBody.children.length, 'rows');
    }

    /**
     * Update therapist selection for bulk operations
     */
    function updateTherapistSelection(therapistId, selected) {
      if (selected) {
        selectedTherapists.add(therapistId);
      } else {
        selectedTherapists.delete(therapistId);
      }
      updateSelectionCounter();
    }

    /**
     * Update selection counter display
     */
    function updateSelectionCounter() {
      var counter = document.getElementById('selectionCounter');
      if (selectedTherapists.size > 0) {
        counter.textContent = selectedTherapists.size + ' therapists selected';
        counter.style.display = 'inline';
      } else {
        counter.style.display = 'none';
      }
    }
  </script>
  <script>
// Filter the therapist list based on search term
function filterTherapistList(searchTerm) {
  console.log('[SEARCH] filterTherapistList called with:', searchTerm);
  
  searchTerm = (searchTerm || '').toLowerCase().trim();
  
  if (!currentSelection || !currentSelection.therapistId) {
    console.warn('[SEARCH] No current selection available for filtering, currentSelection:', currentSelection);
    return;
  }
  
  var primaryTherapistId = currentSelection.therapistId;
  var therapistList = document.getElementById('therapistSelectionList');
  
  if (!therapistList) {
    console.warn('[SEARCH] Therapist selection list not found');
    return;
  }
  
  console.log('[SEARCH] Primary therapist ID:', primaryTherapistId);
  console.log('[SEARCH] Available therapistsData:', therapistsData.length, 'therapists');
  
  // Get available therapists (excluding primary therapist)
  var availableTherapists = therapistsData.filter(function(t) {
    return String(t.id) !== String(primaryTherapistId);
  });
  
  console.log('[SEARCH] Available therapists before search filter:', availableTherapists.length);
  
  // Filter by search term if provided
  if (searchTerm) {
    availableTherapists = availableTherapists.filter(function(therapist) {
      var matches = therapist.name.toLowerCase().includes(searchTerm);
      console.log('[SEARCH] Checking:', therapist.name, 'matches:', matches);
      return matches;
    });
  }
  
  console.log('[SEARCH] Available therapists after search filter:', availableTherapists.length);
  
  // Sort by name for consistency
  availableTherapists.sort(function(a, b) {
    return a.name.localeCompare(b.name);
  });
  
  // Clear and rebuild the list
  therapistList.innerHTML = '';
  
  availableTherapists.forEach(function(therapist) {
    var item = document.createElement('div');
    item.className = 'therapist-selection-item';
    
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'therapist-checkbox';
    checkbox.dataset.therapistId = therapist.id;
    checkbox.checked = currentSelection.selectedTherapistIds && 
                      currentSelection.selectedTherapistIds.includes(String(therapist.id));
    
    var info = document.createElement('div');
    info.className = 'therapist-info';
    
    var name = document.createElement('div');
    name.className = 'therapist-name-select';
    name.textContent = therapist.name;
    
    // Highlight matching text if there's a search term
    if (searchTerm) {
      var highlightedName = highlightText(therapist.name, searchTerm);
      name.innerHTML = highlightedName;
    }
    
    var distanceInfo = document.createElement('div');
    distanceInfo.className = 'therapist-distance-info';
    distanceInfo.textContent = 'Distance: Will be calculated when client is selected';
    
    info.appendChild(name);
    info.appendChild(distanceInfo);
    
    item.appendChild(checkbox);
    item.appendChild(info);
    
    // Add change event listener
    checkbox.addEventListener('change', function() {
      var therapistId = this.dataset.therapistId;
      if (this.checked) {
        if (!currentSelection.selectedTherapistIds.includes(therapistId)) {
          currentSelection.selectedTherapistIds.push(therapistId);
        }
      } else {
        currentSelection.selectedTherapistIds = currentSelection.selectedTherapistIds.filter(function(id) {
          return id !== therapistId;
        });
      }
      updateSelectedTherapistsSummary();
    });
    
    therapistList.appendChild(item);
  });
  
  console.log('[SEARCH] Filtered therapist list completed:', availableTherapists.length, 'therapists shown');
}

// Therapist search bar event listeners (standalone, runs after DOM is loaded)
document.addEventListener('DOMContentLoaded', function() {
  console.log('[SEARCH] Setting up therapist search event listeners');
  var therapistSearchInput = document.getElementById("therapistSearchInput");
  var clearTherapistSearch = document.getElementById("clearTherapistSearch");
  console.log('[SEARCH] Found elements:', therapistSearchInput ? 'input found' : 'input NOT found', 
              clearTherapistSearch ? 'clear button found' : 'clear button NOT found');
  
  if (therapistSearchInput && clearTherapistSearch) {
    therapistSearchInput.addEventListener("input", function() {
      console.log('[SEARCH] Input event fired, value:', this.value);
      filterTherapistList(this.value);
      clearTherapistSearch.style.display = this.value ? "flex" : "none";
    });
    clearTherapistSearch.addEventListener("click", function() {
      console.log('[SEARCH] Clear button clicked');
      therapistSearchInput.value = "";
      therapistSearchInput.focus();
      filterTherapistList("");
      this.style.display = "none";
    });
    clearTherapistSearch.style.display = "none";
    console.log('[SEARCH] Event listeners attached successfully');
  } else {
    console.error('[SEARCH] Failed to find search elements during DOMContentLoaded');
  }
});

async function calculateFullDistancesForClient() {
  const clientId = document.getElementById('testClientSelect').value;
  
  if (!clientId) {
    showStatusMessage('Please select a client first', 'error');
    return;
  }
  
  try {
    showStatusMessage('Calculating full distances for selected client...', 'info');
    
    const result = await callBackendAPI('calculateDistancesForClient', { sourceClientId: clientId });
    
    if (result.success) {
      console.log('[CALC] Calculation result:', result);
      showStatusMessage(`✅ Successfully calculated distances for the client`, 'success');
    } else {
      throw new Error(result.error || 'Calculation failed');
    }
  } catch (error) {
    console.error('[CALC] Error calculating distances:', error);
    showStatusMessage(`❌ Failed to calculate distances: ${error.message}`, 'error');
  }
}

/**
 * Detect and display count of new clients (clients with no distance records)
 */
async function refreshNewClientsDetection() {
  console.log('[NEW_CLIENTS] Refreshing new clients detection...');
  
  try {
    // Update UI to show loading state
    const countElement = document.getElementById('newClientsCount');
    const processButton = document.getElementById('processNewClientsButton');
    
    countElement.textContent = 'Detecting new clients...';
    countElement.style.color = '#666';
    processButton.style.display = 'none';
    
    // Call backend API to identify new clients
    const result = await callBackendAPI('identifyNewClientsAPI', {});
    
    if (result.success) {
      const newCount = result.newClientsCount || 0;
      
      if (newCount === 0) {
        countElement.textContent = 'No new clients found - all clients have distance records';
        countElement.style.color = '#4CAF50';
        processButton.style.display = 'none';
      } else {
        countElement.textContent = `New clients detected: ${newCount}`;
        countElement.style.color = '#FF9800';
        processButton.style.display = 'inline-block';
        
        console.log('[NEW_CLIENTS] Found new clients:', result.newClientDetails);
      }
      
      console.log('[NEW_CLIENTS] Detection result:', result);
      
    } else {
      throw new Error(result.error || 'Failed to detect new clients');
    }
    
  } catch (error) {
    console.error('[NEW_CLIENTS] Error detecting new clients:', error);
    
    const countElement = document.getElementById('newClientsCount');
    countElement.textContent = `Error: ${error.message}`;
    countElement.style.color = '#f44336';
    
    showStatusMessage(`❌ Failed to detect new clients: ${error.message}`, 'error');
  }
}

/**
 * Process new clients using existing infrastructure
 */
async function processNewClients() {
  console.log('[NEW_CLIENTS] Starting new clients processing...');
  
  try {
    // Show existing progress popup
    const progressPopup = document.getElementById('clientDistancesProgressPopup');
    const progressMessage = document.getElementById('clientDistancesProgressMessage');
    const progressFill = document.getElementById('clientDistancesProgressFill');
    const progressText = document.getElementById('clientDistancesProgressText');
    
    // Initialize progress UI
    progressPopup.style.display = 'flex';
    progressMessage.textContent = 'Processing new clients only...';
    progressFill.style.width = '0%';
    progressText.textContent = 'Starting new client processing...';
    
    // Call backend API to process new clients
    console.log('[NEW_CLIENTS] Calling initializeNewClientsDistancesAPI...');
    const result = await callBackendAPI('initializeNewClientsDistancesAPI', {});
    
    // Hide progress popup
    progressPopup.style.display = 'none';
    
    if (result.success) {
      console.log('[NEW_CLIENTS] Processing completed successfully:', result);
      
      // Show existing results popup
      const resultsPopup = document.getElementById('clientDistancesResultsPopup');
      const clientsProcessed = document.getElementById('resultClientsProcessed');
      const calculationsCompleted = document.getElementById('resultCalculationsCompleted');
      const processingTime = document.getElementById('resultProcessingTime');
      const apiCalls = document.getElementById('resultApiCalls');
      const resultMessage = document.getElementById('clientDistancesResultMessage');
      
      // Update results display
      clientsProcessed.textContent = result.newClientsProcessed || 0;
      calculationsCompleted.textContent = result.calculationsCompleted || 0;
      processingTime.textContent = `${result.durationSeconds || 0} seconds`;
      apiCalls.textContent = result.apiCallsUsed || 0;
      
      resultMessage.innerHTML = `
        <h4 style="margin: 0 0 10px 0; color: #4CAF50;">✅ New Clients Processing Complete!</h4>
        <p style="margin: 5px 0;">${result.message}</p>
        <p style="margin: 5px 0; font-size: 12px; color: #666;">
          Mode: ${result.mode} | 
          Processed: ${result.newClientsProcessed} new clients | 
          Calculated: ${result.calculationsCompleted} distances
        </p>
      `;
      
      // Show results dialog
      resultsPopup.style.display = 'flex';
      
      // Refresh the new clients detection to update counts
      await refreshNewClientsDetection();
      
      // Refresh main statistics
      await refreshClientDistanceStats();
      
      showStatusMessage(`✅ Successfully processed ${result.newClientsProcessed} new clients with ${result.calculationsCompleted} distance calculations`, 'success');
      
    } else {
      throw new Error(result.error || 'Failed to process new clients');
    }
    
  } catch (error) {
    console.error('[NEW_CLIENTS] Error processing new clients:', error);
    
    // Hide progress popup on error
    const progressPopup = document.getElementById('clientDistancesProgressPopup');
    progressPopup.style.display = 'none';
    
    showStatusMessage(`❌ Failed to process new clients: ${error.message}`, 'error');
  }
}
</script>

<script>
// Drag and Drop Debugging Script
console.log('[DRAG_DEBUG] Initializing drag and drop debugging...');

// Test if drag handlers exist
setTimeout(function() {
  console.log('[DRAG_DEBUG] Testing drag functionality after page load...');
  
  // Check if drag handler functions exist
  console.log('[DRAG_DEBUG] handleDragStart exists:', typeof handleDragStart);
  console.log('[DRAG_DEBUG] handleDragEnd exists:', typeof handleDragEnd);
  console.log('[DRAG_DEBUG] handleDragOver exists:', typeof handleDragOver);
  console.log('[DRAG_DEBUG] handleDrop exists:', typeof handleDrop);
  
  // Find draggable elements
  var draggableElements = document.querySelectorAll('[draggable="true"]');
  console.log('[DRAG_DEBUG] Found', draggableElements.length, 'draggable elements');
  
  // Find drop targets
  var dropTargets = document.querySelectorAll('.open');
  console.log('[DRAG_DEBUG] Found', dropTargets.length, 'potential drop targets');
  
  // Test if assigned cells are draggable
  var assignedCells = document.querySelectorAll('.assigned');
  console.log('[DRAG_DEBUG] Found', assignedCells.length, 'assigned cells');
  
  assignedCells.forEach(function(cell, index) {
    if (index < 3) { // Log first 3 for debugging
      console.log('[DRAG_DEBUG] Assigned cell', index, ':', {
        draggable: cell.draggable,
        dataset: cell.dataset,
        className: cell.className
      });
    }
  });
  
}, 2000); // Wait 2 seconds for table to build

// Add global drag event listeners for debugging
document.addEventListener('dragstart', function(e) {
  console.log('[DRAG_DEBUG] Global dragstart detected on:', e.target);
});

document.addEventListener('dragend', function(e) {
  console.log('[DRAG_DEBUG] Global dragend detected on:', e.target);
});

document.addEventListener('drop', function(e) {
  console.log('[DRAG_DEBUG] Global drop detected on:', e.target);
});

console.log('[DRAG_DEBUG] Debugging script loaded successfully');

// Data recovery information
console.log('%c📊 Therapist Schedule Data Management', 'font-size: 16px; font-weight: bold; color: #2196F3;');
console.log('%c✅ Data caching and auto-recovery enabled', 'color: #4CAF50;');
console.log('%cAvailable recovery commands:', 'font-weight: bold;');
console.log('  • forceRefreshData() - Force reload data from backend');
console.log('  • runDiagnostics() - Run system diagnostics');
console.log('  • testDataStability() - Check current data status');
console.log('  • debugAssignments() - Debug assignment data');
console.log('  • checkAssignmentDataIntegrity() - Check data integrity');
console.log('  • clearDataCache() - Clear cached data');
console.log('%cData is automatically cached and will recover if it disappears', 'color: #FF9800;');
console.log('%c💡 Fixed: Field mapping now applied to cached data', 'color: #4CAF50; font-weight: bold;');
</script>

</body>
</html> 
